import {
  require_react_dom
} from "./chunk-GVSLPJMJ.js";
import {
  require_prop_types
} from "./chunk-VFNNQF7S.js";
import {
  require_react
} from "./chunk-ZLZLTJQL.js";
import {
  __require,
  __toESM
} from "./chunk-2LSFTFF7.js";

// node_modules/@devexpress/dx-react-scheduler/dist/dx-react-scheduler.es.js
var import_react2 = __toESM(require_react());

// node_modules/@devexpress/dx-react-core/dist/dx-react-core.es.js
var import_react = __toESM(require_react());

// node_modules/@devexpress/dx-core/dist/dx-core.es.js
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spreadArray(to2, from2, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from2.length, ar; i < l; i++) {
      if (ar || !(i in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i);
        ar[i] = from2[i];
      }
    }
  return to2.concat(ar || from2);
}
var DELAY = 200;
var compare = function(a, b) {
  var aPosition = a.position();
  var bPosition = b.position();
  for (var i = 0; i < Math.min(aPosition.length, bPosition.length); i += 1) {
    if (aPosition[i] < bPosition[i])
      return -1;
    if (aPosition[i] > bPosition[i])
      return 1;
  }
  return aPosition.length - bPosition.length;
};
var insertPlugin = function(array, newItem) {
  var result = array.slice();
  var nextItemIndex = array.findIndex(function(item) {
    return compare(newItem, item) <= 0;
  });
  var targetIndex = nextItemIndex < 0 ? array.length : nextItemIndex;
  var alreadyExists = targetIndex >= 0 && targetIndex < array.length && compare(newItem, array[targetIndex]) === 0;
  var deletedItems = 0;
  if (alreadyExists) {
    deletedItems = 1;
    var targetItemPosition = result[targetIndex].position();
    if (targetItemPosition.length > 1) {
      for (var i = targetIndex + 1; i < result.length; i += 1) {
        var itemPosition = result[i].position();
        if (targetItemPosition.length === itemPosition.length && targetItemPosition[targetItemPosition.length - 2] === itemPosition[itemPosition.length - 2]) {
          deletedItems += 1;
        } else {
          break;
        }
      }
    }
  }
  result.splice(targetIndex, deletedItems, newItem);
  return result;
};
var removePlugin = function(array, item) {
  var itemIndex = array.indexOf(item);
  return itemIndex >= 0 ? __spreadArray(__spreadArray([], __read(array.slice(0, itemIndex)), false), __read(array.slice(itemIndex + 1)), false) : array;
};
var createClickHandlers = function(click, dblClick) {
  var timeoutId;
  var events = {};
  if (click) {
    events.onClick = function(e) {
      if (!timeoutId) {
        timeoutId = setTimeout(function() {
          clearTimeout(timeoutId);
          click(e);
        }, DELAY);
      }
    };
  }
  if (dblClick) {
    events.onDoubleClick = function(e) {
      clearTimeout(timeoutId);
      dblClick(e);
    };
  }
  return events;
};
var slice = function(arr) {
  return Array.prototype.slice.call(arr);
};
var getDependencyError = function(pluginName, dependencyName) {
  return new Error("The '".concat(pluginName, "' plugin requires '").concat(dependencyName, "' to be defined before it."));
};
var PluginHost = function() {
  function PluginHost3() {
    this.gettersCache = {};
    this.knownKeysCache = {};
    this.validationRequired = true;
    this.plugins = [];
    this.subscriptions = /* @__PURE__ */ new Set();
  }
  PluginHost3.prototype.ensureDependencies = function() {
    var defined = /* @__PURE__ */ new Set();
    var knownOptionals = /* @__PURE__ */ new Map();
    this.plugins.filter(function(plugin) {
      return plugin.container;
    }).forEach(function(plugin) {
      var pluginName = plugin.name || "";
      if (knownOptionals.has(pluginName)) {
        throw getDependencyError(knownOptionals.get(pluginName), pluginName);
      }
      (plugin.dependencies || []).forEach(function(dependency) {
        if (defined.has(dependency.name))
          return;
        if (dependency.optional) {
          if (!knownOptionals.has(dependency.name)) {
            knownOptionals.set(dependency.name, pluginName);
          }
          return;
        }
        throw getDependencyError(pluginName, dependency.name);
      });
      defined.add(pluginName);
    });
  };
  PluginHost3.prototype.registerPlugin = function(plugin) {
    this.plugins = insertPlugin(this.plugins, plugin);
    this.cleanPluginsCache();
  };
  PluginHost3.prototype.unregisterPlugin = function(plugin) {
    this.plugins = removePlugin(this.plugins, plugin);
    this.cleanPluginsCache();
  };
  PluginHost3.prototype.knownKeys = function(postfix) {
    if (!this.knownKeysCache[postfix]) {
      this.knownKeysCache[postfix] = Array.from(this.plugins.map(function(plugin) {
        return Object.keys(plugin);
      }).map(function(keys2) {
        return keys2.filter(function(key) {
          return key.endsWith(postfix);
        })[0];
      }).filter(function(key) {
        return !!key;
      }).reduce(function(acc, key) {
        return acc.add(key);
      }, /* @__PURE__ */ new Set())).map(function(key) {
        return key.replace(postfix, "");
      });
    }
    return this.knownKeysCache[postfix];
  };
  PluginHost3.prototype.collect = function(key, upTo) {
    if (this.validationRequired) {
      this.ensureDependencies();
      this.validationRequired = false;
    }
    var res = this.gettersCache[key];
    if (!res) {
      var indexCache = this.plugins.map(function(plugin, index) {
        return { key: plugin[key], index };
      }).filter(function(plugin) {
        return !!plugin.key;
      });
      this.gettersCache["".concat(key, "_i")] = indexCache;
      res = indexCache.map(function(item) {
        return item.key;
      });
      this.gettersCache[key] = res;
    }
    if (!upTo)
      return res;
    var upToIndex = this.plugins.indexOf(upTo);
    var upToIndexKey = key + upToIndex;
    var upToRes = this.gettersCache[upToIndexKey];
    if (!upToRes) {
      var indexCache_1 = this.gettersCache["".concat(key, "_i")];
      upToRes = this.gettersCache[key].filter(function(getter, index) {
        return indexCache_1[index].index < upToIndex;
      });
      this.gettersCache[upToIndexKey] = upToRes;
    }
    return upToRes;
  };
  PluginHost3.prototype.get = function(key, upTo) {
    var plugins = this.collect(key, upTo);
    if (!plugins.length)
      return void 0;
    var result;
    plugins.forEach(function(plugin) {
      result = plugin(result);
    });
    return result;
  };
  PluginHost3.prototype.registerSubscription = function(subscription) {
    this.subscriptions.add(subscription);
  };
  PluginHost3.prototype.unregisterSubscription = function(subscription) {
    this.subscriptions.delete(subscription);
  };
  PluginHost3.prototype.broadcast = function(event, message) {
    this.subscriptions.forEach(function(subscription) {
      return subscription[event] && subscription[event](message);
    });
  };
  PluginHost3.prototype.cleanPluginsCache = function() {
    this.validationRequired = true;
    this.gettersCache = {};
    this.knownKeysCache = {};
  };
  return PluginHost3;
}();
var EventEmitter = function() {
  function EventEmitter2() {
    this.handlers = [];
  }
  EventEmitter2.prototype.emit = function(e) {
    this.handlers.forEach(function(handler) {
      return handler(e);
    });
  };
  EventEmitter2.prototype.subscribe = function(handler) {
    this.handlers.push(handler);
  };
  EventEmitter2.prototype.unsubscribe = function(handler) {
    this.handlers.splice(this.handlers.indexOf(handler), 1);
  };
  return EventEmitter2;
}();
var shallowEqual = function(objA, objB) {
  if (objA === objB) {
    return true;
  }
  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) {
    return false;
  }
  var hasOwn = Object.prototype.hasOwnProperty;
  for (var i = 0; i < keysA.length; i += 1) {
    if (!hasOwn.call(objB, keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
      return false;
    }
    var valA = objA[keysA[i]];
    var valB = objB[keysA[i]];
    if (valA !== valB) {
      return false;
    }
  }
  return true;
};
var argumentsShallowEqual = function(prev, next) {
  if (prev === null || next === null || prev.length !== next.length) {
    return false;
  }
  for (var i = 0; i < prev.length; i += 1) {
    if (prev[i] !== next[i]) {
      return false;
    }
  }
  return true;
};
var memoize = function(func) {
  var lastArgs = null;
  var lastResult = null;
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (lastArgs === null || !argumentsShallowEqual(lastArgs, args)) {
      lastResult = func.apply(void 0, __spreadArray([], __read(args), false));
    }
    lastArgs = args;
    return lastResult;
  };
};
var processPattern = function(pattern, params) {
  return Object.keys(params).reduce(function(msg, key) {
    return msg.replace("{".concat(key, "}"), params[key]);
  }, pattern);
};
var getMessagesFormatter = function(messages) {
  return function(key, params) {
    var message = messages[key];
    if (typeof message === "function") {
      return message(params);
    }
    if (params) {
      return processPattern(message, params);
    }
    return message !== null && message !== void 0 ? message : "";
  };
};

// node_modules/@devexpress/dx-react-core/dist/dx-react-core.es.js
var import_react_dom = __toESM(require_react_dom());
var import_prop_types = __toESM(require_prop_types());
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign5(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __read2(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spreadArray2(to2, from2, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from2.length, ar; i < l; i++) {
      if (ar || !(i in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i);
        ar[i] = from2[i];
      }
    }
  return to2.concat(ar || from2);
}
var PluginHostContext = (0, import_react.createContext)(null);
var PositionContext = (0, import_react.createContext)(function() {
  return [];
});
var TemplateHostContext = (0, import_react.createContext)(null);
var PluginIndexer = function(_super) {
  __extends(PluginIndexer2, _super);
  function PluginIndexer2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.indexes = {};
    _this.memoize = function(index, positionContext) {
      if (_this.indexes[index])
        return _this.indexes[index];
      var fn = function() {
        var calculatedPosition = positionContext();
        return __spreadArray2(__spreadArray2([], __read2(calculatedPosition), false), [index], false);
      };
      _this.indexes[index] = fn;
      return fn;
    };
    return _this;
  }
  PluginIndexer2.prototype.render = function() {
    var _this = this;
    var children = this.props.children;
    return (0, import_react.createElement)(PositionContext.Consumer, null, function(positionContext) {
      return import_react.Children.map(children, function(child, index) {
        if (!child || !child.type)
          return child;
        var childPosition = _this.memoize(index, positionContext);
        return (0, import_react.createElement)(PositionContext.Provider, { key: String(index), value: childPosition }, child);
      });
    });
  };
  return PluginIndexer2;
}(import_react.PureComponent);
var PLUGIN_HOST_CONTEXT = "dxcore_pluginHost_context";
var POSITION_CONTEXT = "dxcore_position_context";
var TEMPLATE_HOST_CONTEXT = "dxcore_templateHost_context";
var RERENDER_TEMPLATE_EVENT = Symbol("rerenderTemplate");
var RERENDER_TEMPLATE_SCOPE_EVENT = Symbol("rerenderTemplateScope");
var UPDATE_CONNECTION_EVENT = Symbol("updateConnection");
var withContext = function(Context, name) {
  return function(Component2) {
    return function(props) {
      return (0, import_react.createElement)(Context.Consumer, null, function(context) {
        var _a2;
        return (0, import_react.createElement)(Component2, __assign({}, props, (_a2 = {}, _a2[name] = context, _a2)));
      });
    };
  };
};
var withHostAndPosition = function(Component2) {
  return withContext(PluginHostContext, PLUGIN_HOST_CONTEXT)(withContext(PositionContext, POSITION_CONTEXT)(Component2));
};
var PluginBase = function(_super) {
  __extends(PluginBase2, _super);
  function PluginBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  PluginBase2.prototype.componentDidMount = function() {
    var _a2 = this.props, _b = PLUGIN_HOST_CONTEXT, pluginHost = _a2[_b], _c = POSITION_CONTEXT, position = _a2[_c];
    var _d = this.props, name = _d.name, dependencies = _d.dependencies;
    this.plugin = {
      position,
      name,
      dependencies,
      container: true
    };
    pluginHost.registerPlugin(this.plugin);
    pluginHost.ensureDependencies();
  };
  PluginBase2.prototype.componentDidUpdate = function() {
    var _a2 = this.props, _b = PLUGIN_HOST_CONTEXT, pluginHost = _a2[_b];
    pluginHost.ensureDependencies();
  };
  PluginBase2.prototype.componentWillUnmount = function() {
    var _a2 = this.props, _b = PLUGIN_HOST_CONTEXT, pluginHost = _a2[_b];
    pluginHost.unregisterPlugin(this.plugin);
  };
  PluginBase2.prototype.render = function() {
    var children = this.props.children;
    return (0, import_react.createElement)(PluginIndexer, null, children);
  };
  return PluginBase2;
}(import_react.PureComponent);
var Plugin = withHostAndPosition(PluginBase);
var getRenderingData = function(props) {
  var name = props.name, params = props.params;
  if (name) {
    var _a2 = props, _b = PLUGIN_HOST_CONTEXT, pluginHost = _a2[_b];
    return {
      params,
      templates: pluginHost.collect("".concat(name, "Template")).filter(function(template) {
        return template.predicate(params);
      }).reverse()
    };
  }
  var _c = props, _d = TEMPLATE_HOST_CONTEXT, templateHost = _c[_d];
  return {
    params: params || templateHost.params(),
    templates: templateHost.templates()
  };
};
var TemplatePlaceholderBase = function(_super) {
  __extends(TemplatePlaceholderBase2, _super);
  function TemplatePlaceholderBase2() {
    var _a2;
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.subscription = (_a2 = {}, _a2[RERENDER_TEMPLATE_EVENT] = function(id) {
      if (_this.template && _this.template.id === id) {
        _this.forceUpdate();
      }
    }, _a2[RERENDER_TEMPLATE_SCOPE_EVENT] = function(name) {
      var propsName = _this.props.name;
      if (propsName === name) {
        _this.forceUpdate();
      }
    }, _a2);
    _this.template = null;
    _this.params = {};
    return _this;
  }
  TemplatePlaceholderBase2.prototype.componentDidMount = function() {
    var _a2 = this.props, _b = PLUGIN_HOST_CONTEXT, pluginHost = _a2[_b];
    pluginHost.registerSubscription(this.subscription);
  };
  TemplatePlaceholderBase2.prototype.shouldComponentUpdate = function(nextProps) {
    var _a2 = getRenderingData(nextProps), params = _a2.params, templates = _a2.templates;
    var _b = __read2(templates, 1), template = _b[0];
    var children = this.props.children;
    return children !== nextProps.children || templates.length !== getRenderingData(this.props).templates.length || this.template !== template || !shallowEqual(this.params, params);
  };
  TemplatePlaceholderBase2.prototype.componentWillUnmount = function() {
    var _a2 = this.props, _b = PLUGIN_HOST_CONTEXT, pluginHost = _a2[_b];
    pluginHost.unregisterSubscription(this.subscription);
  };
  TemplatePlaceholderBase2.prototype.render = function() {
    var _a2;
    var _this = this;
    var _b = getRenderingData(this.props), params = _b.params, templates = _b.templates;
    this.params = params;
    _a2 = __read2(templates, 1), this.template = _a2[0];
    var restTemplates = templates.slice(1);
    var content = null;
    if (this.template) {
      var templateContent = this.template.children;
      content = templateContent() || null;
      if (content && typeof content === "function") {
        content = content(params);
      }
    }
    var templatePlaceholder = this.props.children;
    return (0, import_react.createElement)(TemplateHostContext.Provider, { value: {
      templates: function() {
        return restTemplates;
      },
      params: function() {
        return _this.params;
      }
    } }, templatePlaceholder ? templatePlaceholder(content) : content);
  };
  return TemplatePlaceholderBase2;
}(import_react.Component);
var TemplatePlaceholder = withContext(PluginHostContext, PLUGIN_HOST_CONTEXT)(withContext(TemplateHostContext, TEMPLATE_HOST_CONTEXT)(TemplatePlaceholderBase));
var PlaceholderWithRef = function(_a2) {
  var params = _a2.params, forwardedRef = _a2.forwardedRef;
  return (0, import_react.createElement)(TemplatePlaceholder, { params: __assign(__assign({}, params), { forwardedRef }) });
};
var PluginHostBase = function(_super) {
  __extends(PluginHostBase2, _super);
  function PluginHostBase2(props) {
    var _this = _super.call(this, props) || this;
    _this.host = new PluginHost();
    return _this;
  }
  PluginHostBase2.prototype.render = function() {
    var children = this.props.children;
    return (0, import_react.createElement)(
      PluginHostContext.Provider,
      { value: this.host },
      (0, import_react.createElement)(PluginIndexer, null, children),
      (0, import_react.createElement)(TemplatePlaceholder, { name: "root" })
    );
  };
  return PluginHostBase2;
}(import_react.PureComponent);
var PluginHost2 = PluginHostBase;
var getAvailableGetters = function(pluginHost, getGetterValue) {
  if (getGetterValue === void 0) {
    getGetterValue = function(getterName) {
      return pluginHost.get("".concat(getterName, "Getter"));
    };
  }
  var trackedDependencies = {};
  var getters;
  if (typeof Proxy !== "undefined") {
    getters = new Proxy({}, {
      get: function(target, prop) {
        if (typeof prop !== "string")
          return void 0;
        var result = getGetterValue(prop);
        trackedDependencies[prop] = result;
        return result;
      },
      getOwnPropertyDescriptor: function(target, prop) {
        return {
          configurable: true,
          enumerable: true,
          value: this.get(target, prop, void 0)
        };
      },
      ownKeys: function() {
        return pluginHost.knownKeys("Getter");
      }
    });
  } else {
    getters = pluginHost.knownKeys("Getter").reduce(function(acc, getterName) {
      Object.defineProperty(acc, getterName, {
        get: function() {
          var result = getGetterValue(getterName);
          trackedDependencies[getterName] = result;
          return result;
        }
      });
      return acc;
    }, {});
  }
  return { getters, trackedDependencies };
};
var isTrackedDependenciesChanged = function(pluginHost, prevTrackedDependencies, getGetterValue) {
  if (getGetterValue === void 0) {
    getGetterValue = function(getterName) {
      return pluginHost.get("".concat(getterName, "Getter"));
    };
  }
  var trackedDependencies = Object.keys(prevTrackedDependencies).reduce(function(acc, getterName) {
    var _a2;
    return Object.assign(acc, (_a2 = {}, _a2[getterName] = getGetterValue(getterName), _a2));
  }, {});
  return !shallowEqual(prevTrackedDependencies, trackedDependencies);
};
var getAvailableActions = function(pluginHost, getAction) {
  if (getAction === void 0) {
    getAction = function(actionName) {
      return pluginHost.collect("".concat(actionName, "Action")).slice().reverse()[0];
    };
  }
  var actions;
  if (typeof Proxy !== "undefined") {
    actions = new Proxy({}, {
      get: function(target, prop) {
        if (typeof prop !== "string")
          return void 0;
        return getAction(prop);
      },
      getOwnPropertyDescriptor: function(target, prop) {
        return {
          configurable: true,
          enumerable: true,
          value: this.get(target, prop, void 0)
        };
      },
      ownKeys: function() {
        return pluginHost.knownKeys("Action");
      }
    });
  } else {
    actions = pluginHost.knownKeys("Action").reduce(function(acc, actionName) {
      Object.defineProperty(acc, actionName, {
        get: function() {
          return getAction(actionName);
        }
      });
      return acc;
    }, {});
  }
  return actions;
};
var ActionBase = function(_super) {
  __extends(ActionBase2, _super);
  function ActionBase2(props) {
    var _a2;
    var _this = _super.call(this, props) || this;
    var _b = props, _c = PLUGIN_HOST_CONTEXT, pluginHost = _b[_c], _d = POSITION_CONTEXT, positionContext = _b[_d];
    var name = props.name;
    _this.plugin = (_a2 = {
      position: function() {
        return positionContext();
      }
    }, _a2["".concat(name, "Action")] = function(params) {
      var action = _this.props.action;
      var getters = getAvailableGetters(pluginHost, function(getterName) {
        return pluginHost.get("".concat(getterName, "Getter"), _this.plugin);
      }).getters;
      var nextParams = params;
      var actions = getAvailableActions(pluginHost, function(actionName) {
        return actionName === name ? function(newParams) {
          nextParams = newParams;
        } : pluginHost.collect("".concat(actionName, "Action"), _this.plugin).slice().reverse()[0];
      });
      action(params, getters, actions);
      var nextAction = pluginHost.collect("".concat(name, "Action"), _this.plugin).slice().reverse()[0];
      if (nextAction) {
        nextAction(nextParams);
      }
    }, _a2);
    pluginHost.registerPlugin(_this.plugin);
    return _this;
  }
  ActionBase2.prototype.componentWillUnmount = function() {
    var _a2 = this.props, _b = PLUGIN_HOST_CONTEXT, pluginHost = _a2[_b];
    pluginHost.unregisterPlugin(this.plugin);
  };
  ActionBase2.prototype.render = function() {
    return null;
  };
  return ActionBase2;
}(import_react.PureComponent);
var Action = withHostAndPosition(ActionBase);
var GetterBase = function(_super) {
  __extends(GetterBase2, _super);
  function GetterBase2(props) {
    var _a2;
    var _this = _super.call(this, props) || this;
    var _b = props, _c = PLUGIN_HOST_CONTEXT, pluginHost = _b[_c], _d = POSITION_CONTEXT, positionContext = _b[_d];
    var name = props.name;
    var lastComputed;
    var lastTrackedDependencies = {};
    var lastResult;
    _this.plugin = (_a2 = {
      position: function() {
        return positionContext();
      }
    }, _a2["".concat(name, "Getter")] = function(original) {
      var _a3 = _this.props, value = _a3.value, computed2 = _a3.computed;
      if (computed2 === void 0)
        return value;
      var getGetterValue = function(getterName) {
        return getterName === name ? original : pluginHost.get("".concat(getterName, "Getter"), _this.plugin);
      };
      if (computed2 === lastComputed && !isTrackedDependenciesChanged(pluginHost, lastTrackedDependencies, getGetterValue)) {
        return lastResult;
      }
      var _b2 = getAvailableGetters(pluginHost, getGetterValue), getters = _b2.getters, trackedDependencies = _b2.trackedDependencies;
      var actions = getAvailableActions(pluginHost);
      lastComputed = computed2;
      lastTrackedDependencies = trackedDependencies;
      lastResult = computed2(getters, actions);
      return lastResult;
    }, _a2);
    pluginHost.registerPlugin(_this.plugin);
    return _this;
  }
  GetterBase2.prototype.componentDidUpdate = function() {
    var _a2 = this.props, _b = PLUGIN_HOST_CONTEXT, pluginHost = _a2[_b];
    pluginHost.broadcast(UPDATE_CONNECTION_EVENT);
  };
  GetterBase2.prototype.componentWillUnmount = function() {
    var _a2 = this.props, _b = PLUGIN_HOST_CONTEXT, pluginHost = _a2[_b];
    pluginHost.unregisterPlugin(this.plugin);
  };
  GetterBase2.prototype.render = function() {
    return null;
  };
  return GetterBase2;
}(import_react.PureComponent);
var Getter = withHostAndPosition(GetterBase);
var globalTemplateId = 0;
var TemplateBase = function(_super) {
  __extends(TemplateBase2, _super);
  function TemplateBase2(props) {
    var _a2;
    var _this = _super.call(this, props) || this;
    _this.children = function() {
      return void 0;
    };
    globalTemplateId += 1;
    _this.id = globalTemplateId;
    var _b = props, _c = PLUGIN_HOST_CONTEXT, pluginHost = _b[_c], _d = POSITION_CONTEXT, positionContext = _b[_d];
    var name = props.name, predicate = props.predicate;
    _this.plugin = (_a2 = {
      position: function() {
        return positionContext();
      }
    }, _a2["".concat(name, "Template")] = {
      id: _this.id,
      predicate: function(params) {
        return predicate ? predicate(params) : true;
      },
      children: function() {
        var children = _this.props.children;
        return children;
      }
    }, _a2);
    pluginHost.registerPlugin(_this.plugin);
    pluginHost.broadcast(RERENDER_TEMPLATE_SCOPE_EVENT, name);
    return _this;
  }
  TemplateBase2.prototype.componentDidUpdate = function() {
    var _a2 = this.props, _b = PLUGIN_HOST_CONTEXT, pluginHost = _a2[_b];
    pluginHost.broadcast(RERENDER_TEMPLATE_EVENT, this.id);
  };
  TemplateBase2.prototype.componentWillUnmount = function() {
    var _a2 = this.props, _b = PLUGIN_HOST_CONTEXT, pluginHost = _a2[_b];
    var name = this.props.name;
    pluginHost.unregisterPlugin(this.plugin);
    pluginHost.broadcast(RERENDER_TEMPLATE_SCOPE_EVENT, name);
  };
  TemplateBase2.prototype.render = function() {
    return null;
  };
  return TemplateBase2;
}(import_react.PureComponent);
var Template = withHostAndPosition(TemplateBase);
var TemplateConnectorBase = function(_super) {
  __extends(TemplateConnectorBase2, _super);
  function TemplateConnectorBase2(props, context) {
    var _a2;
    var _this = _super.call(this, props, context) || this;
    _this.trackedDependencies = {};
    _this.subscription = (_a2 = {}, _a2[UPDATE_CONNECTION_EVENT] = function() {
      return _this.updateConnection();
    }, _a2);
    return _this;
  }
  TemplateConnectorBase2.prototype.componentDidMount = function() {
    var pluginHost = this.context;
    pluginHost.registerSubscription(this.subscription);
  };
  TemplateConnectorBase2.prototype.componentWillUnmount = function() {
    var pluginHost = this.context;
    pluginHost.unregisterSubscription(this.subscription);
  };
  TemplateConnectorBase2.prototype.updateConnection = function() {
    var pluginHost = this.context;
    if (isTrackedDependenciesChanged(pluginHost, this.trackedDependencies)) {
      this.forceUpdate();
    }
  };
  TemplateConnectorBase2.prototype.render = function() {
    var pluginHost = this.context;
    var children = this.props.children;
    var _a2 = getAvailableGetters(pluginHost), getters = _a2.getters, trackedDependencies = _a2.trackedDependencies;
    this.trackedDependencies = trackedDependencies;
    var actions = getAvailableActions(pluginHost);
    return children(getters, actions);
  };
  return TemplateConnectorBase2;
}(import_react.Component);
TemplateConnectorBase.contextType = PluginHostContext;
var TemplateConnector = TemplateConnectorBase;
var TIMEOUT = 180;
var TouchStrategy = function() {
  function TouchStrategy2(delegate) {
    this.delegate = delegate;
    this.touchStartTimeout = null;
    this.dragging = false;
  }
  TouchStrategy2.prototype.isDragging = function() {
    return this.dragging;
  };
  TouchStrategy2.prototype.isWaiting = function() {
    return !!this.touchStartTimeout;
  };
  TouchStrategy2.prototype.cancelWaiting = function() {
    clearTimeout(this.touchStartTimeout);
    this.touchStartTimeout = void 0;
  };
  TouchStrategy2.prototype.start = function(e) {
    var _this = this;
    var _a2 = e.touches[0], x = _a2.clientX, y = _a2.clientY;
    this.touchStartTimeout = setTimeout(function() {
      _this.delegate.onStart({ x, y });
      _this.dragging = true;
    }, TIMEOUT);
  };
  TouchStrategy2.prototype.move = function(e) {
    this.cancelWaiting();
    if (this.dragging) {
      var _a2 = e.touches[0], clientX = _a2.clientX, clientY = _a2.clientY;
      e.preventDefault();
      this.delegate.onMove({ x: clientX, y: clientY });
    }
  };
  TouchStrategy2.prototype.end = function(e) {
    this.cancelWaiting();
    if (this.dragging) {
      var _a2 = e.changedTouches[0], clientX = _a2.clientX, clientY = _a2.clientY;
      this.delegate.onEnd({ x: clientX, y: clientY });
    }
    this.dragging = false;
  };
  return TouchStrategy2;
}();
var gestureCover;
var toggleGestureCover = function(toggle, cursor) {
  var style = {
    pointerEvents: toggle ? "all" : "none"
  };
  if (toggle && cursor) {
    style = __assign(__assign({}, style), { cursor });
  }
  if (!gestureCover) {
    style = __assign(__assign({}, style), { position: "fixed", top: 0, right: 0, left: 0, bottom: 0, opacity: 0, zIndex: 2147483647 });
    gestureCover = document.createElement("div");
    document.body.appendChild(gestureCover);
  }
  Object.keys(style).forEach(function(key) {
    gestureCover.style[key] = style[key];
  });
};
var clear = function() {
  var selection = window.getSelection && window.getSelection();
  if (selection) {
    if (selection.empty) {
      selection.empty();
    } else if (selection.removeAllRanges) {
      selection.removeAllRanges();
    }
  }
};
var BOUNDARY = 10;
var clamp = function(value, min2, max2) {
  return Math.max(Math.min(value, max2), min2);
};
var isBoundExceeded = function(_a2, _b) {
  var initialX = _a2.x, initialY = _a2.y;
  var x = _b.x, y = _b.y;
  return clamp(x, initialX - BOUNDARY, initialX + BOUNDARY) !== x || clamp(y, initialY - BOUNDARY, initialY + BOUNDARY) !== y;
};
var MouseStrategy = function() {
  function MouseStrategy2(delegate) {
    this.delegate = delegate;
    this.mouseInitialOffset = null;
    this.dragging = false;
  }
  MouseStrategy2.prototype.isDragging = function() {
    return this.dragging;
  };
  MouseStrategy2.prototype.start = function(e) {
    var x = e.clientX, y = e.clientY;
    this.e = e;
    this.mouseInitialOffset = { x, y };
  };
  MouseStrategy2.prototype.move = function(e) {
    var x = e.clientX, y = e.clientY;
    var dragStarted = false;
    if (!this.dragging && this.mouseInitialOffset) {
      if (isBoundExceeded(this.mouseInitialOffset, { x, y })) {
        this.delegate.onStart(this.mouseInitialOffset);
        clear();
        dragStarted = true;
        this.dragging = true;
      }
    }
    if (this.dragging) {
      e.preventDefault();
      this.delegate.onMove({ x, y });
    }
    if (dragStarted) {
      var element = document.elementFromPoint(x, y);
      var cursor = element ? window.getComputedStyle(element).cursor : null;
      toggleGestureCover(true, cursor);
    }
  };
  MouseStrategy2.prototype.end = function(e) {
    if (this.dragging) {
      var x = e.clientX, y = e.clientY;
      toggleGestureCover(false);
      this.delegate.onEnd({ x, y });
    }
    this.mouseInitialOffset = null;
    this.dragging = false;
  };
  return MouseStrategy2;
}();
var eventEmitter;
var getSharedEventEmitter = function() {
  if (!eventEmitter) {
    eventEmitter = new EventEmitter();
    ["mousemove", "mouseup", "touchmove", "touchend", "touchcancel"].forEach(function(name) {
      return window.addEventListener(name, function(e) {
        return eventEmitter.emit([name, e]);
      }, { passive: false });
    });
  }
  return eventEmitter;
};
var RefHolder = (0, import_react.forwardRef)(function(_a2, ref) {
  var _b;
  var children = _a2.children;
  return (0, import_react.isValidElement)(children) ? typeof children.type === "string" ? (0, import_react.cloneElement)(children, { ref }) : (0, import_react.cloneElement)(children, {
    forwardedRef: ((_b = children.props) === null || _b === void 0 ? void 0 : _b.forwardedRef) ? function(node) {
      children.props.forwardedRef(node);
      if (typeof ref === "function") {
        ref(node);
      } else if (ref) {
        ref.current = node;
      }
    } : ref
  }) : (0, import_react.createElement)("div", { ref, style: { display: "contents" } }, children);
});
var draggingHandled = Symbol("draggingHandled");
var Draggable = function(_super) {
  __extends(Draggable2, _super);
  function Draggable2(props) {
    var _this = _super.call(this, props) || this;
    _this.eventParams = null;
    _this.detachNodeEvents = null;
    var delegate = {
      onStart: function(_a2) {
        var x = _a2.x, y = _a2.y;
        var onStart = _this.props.onStart;
        if (!onStart)
          return;
        (0, import_react_dom.unstable_batchedUpdates)(function() {
          onStart({ x, y });
        });
      },
      onMove: function(_a2) {
        var x = _a2.x, y = _a2.y;
        var onUpdate = _this.props.onUpdate;
        if (!onUpdate)
          return;
        (0, import_react_dom.unstable_batchedUpdates)(function() {
          onUpdate({ x, y });
        });
      },
      onEnd: function(_a2) {
        var x = _a2.x, y = _a2.y;
        var onEnd = _this.props.onEnd;
        if (!onEnd)
          return;
        (0, import_react_dom.unstable_batchedUpdates)(function() {
          onEnd({ x, y });
        });
      }
    };
    _this.mouseStrategy = new MouseStrategy(delegate);
    _this.touchStrategy = new TouchStrategy(delegate);
    _this.elementRef = (0, import_react.createRef)();
    _this.mouseDownListener = _this.mouseDownListener.bind(_this);
    _this.touchStartListener = _this.touchStartListener.bind(_this);
    _this.globalListener = _this.globalListener.bind(_this);
    return _this;
  }
  Draggable2.prototype.componentDidMount = function() {
    getSharedEventEmitter().subscribe(this.globalListener);
    this.setupNodeSubscription();
  };
  Draggable2.prototype.componentDidUpdate = function() {
    this.setupNodeSubscription();
  };
  Draggable2.prototype.componentWillUnmount = function() {
    var _a2;
    if (this.eventParams) {
      var _b = this.eventParams, isMouseEvent = _b.isMouseEvent, e = _b.e;
      if (isMouseEvent) {
        this.mouseStrategy.end(e);
      } else {
        this.touchStrategy.end(e);
      }
      this.eventParams = null;
    }
    (_a2 = this.detachNodeEvents) === null || _a2 === void 0 ? void 0 : _a2.call(this);
    getSharedEventEmitter().unsubscribe(this.globalListener);
  };
  Draggable2.prototype.setupNodeSubscription = function() {
    var _this = this;
    var _a2;
    var node = this.elementRef.current;
    if (!node)
      return;
    (_a2 = this.detachNodeEvents) === null || _a2 === void 0 ? void 0 : _a2.call(this);
    node.addEventListener("mousedown", this.mouseDownListener);
    node.addEventListener("touchstart", this.touchStartListener, { passive: true });
    this.detachNodeEvents = function() {
      node.removeEventListener("mousedown", _this.mouseDownListener);
      node.removeEventListener("touchstart", _this.touchStartListener);
    };
  };
  Draggable2.prototype.mouseDownListener = function(e) {
    if (this.touchStrategy.isWaiting() || e[draggingHandled])
      return;
    e.preventDefault();
    this.mouseStrategy.start(e);
    e[draggingHandled] = true;
  };
  Draggable2.prototype.touchStartListener = function(e) {
    if (e[draggingHandled])
      return;
    this.touchStrategy.start(e);
    e[draggingHandled] = true;
  };
  Draggable2.prototype.saveEvent = function(e, isMouseEvent) {
    this.eventParams = {
      e,
      isMouseEvent
    };
  };
  Draggable2.prototype.globalListener = function(_a2) {
    var _b = __read2(_a2, 2), name = _b[0], e = _b[1];
    switch (name) {
      case "mousemove":
        this.saveEvent(e, true);
        this.mouseStrategy.move(e);
        break;
      case "mouseup":
        this.eventParams = null;
        this.mouseStrategy.end(e);
        break;
      case "touchmove": {
        this.saveEvent(e, false);
        this.touchStrategy.move(e);
        break;
      }
      case "touchend":
      case "touchcancel": {
        this.eventParams = null;
        this.touchStrategy.end(e);
        break;
      }
    }
    if (this.mouseStrategy.isDragging() || this.touchStrategy.isDragging()) {
      clear();
    }
  };
  Draggable2.prototype.render = function() {
    var _this = this;
    var _a2 = this.props, children = _a2.children, dragItem = _a2.dragItem;
    return (0, import_react.createElement)(RefHolder, { ref: function(node) {
      _this.elementRef.current = node;
      if (typeof dragItem === "function") {
        dragItem(node);
      } else if (dragItem) {
        dragItem.current = node;
      }
    } }, children);
  };
  return Draggable2;
}(import_react.PureComponent);
var DragDropContext = (0, import_react.createContext)(null);
var DragDropProviderCore = function() {
  function DragDropProviderCore2() {
    this.payload = null;
    this.dragEmitter = new EventEmitter();
  }
  DragDropProviderCore2.prototype.start = function(payload, clientOffset) {
    this.payload = payload;
    this.dragEmitter.emit({ clientOffset, payload: this.payload });
  };
  DragDropProviderCore2.prototype.update = function(clientOffset) {
    this.dragEmitter.emit({ clientOffset, payload: this.payload });
  };
  DragDropProviderCore2.prototype.end = function(clientOffset) {
    this.dragEmitter.emit({ clientOffset, payload: this.payload, end: true });
    this.payload = null;
  };
  return DragDropProviderCore2;
}();
var defaultProps = {
  onChange: function(_a2) {
    var payload = _a2.payload, clientOffset = _a2.clientOffset;
  }
};
var DragDropProvider = function(_super) {
  __extends(DragDropProvider3, _super);
  function DragDropProvider3(props) {
    var _this = _super.call(this, props) || this;
    var onChange = _this.props.onChange;
    _this.dragDropProvider = new DragDropProviderCore();
    _this.dragDropProvider.dragEmitter.subscribe(function(_a2) {
      var payload = _a2.payload, clientOffset = _a2.clientOffset, end = _a2.end;
      onChange({
        payload: end ? null : payload,
        clientOffset: end ? null : clientOffset
      });
    });
    return _this;
  }
  DragDropProvider3.prototype.shouldComponentUpdate = function(nextProps) {
    var children = this.props.children;
    return nextProps.children !== children;
  };
  DragDropProvider3.prototype.render = function() {
    var children = this.props.children;
    return (0, import_react.createElement)(DragDropContext.Provider, { value: this.dragDropProvider }, children);
  };
  DragDropProvider3.defaultProps = defaultProps;
  return DragDropProvider3;
}(import_react.Component);
var defaultProps$1 = {
  onStart: function(_a2) {
    var clientOffset = _a2.clientOffset;
  },
  onUpdate: function(_a2) {
    var clientOffset = _a2.clientOffset;
  },
  onEnd: function(_a2) {
    var clientOffset = _a2.clientOffset;
  }
};
var DragSource = (0, import_react.forwardRef)(function(_a2, ref) {
  var onStart = _a2.onStart, onUpdate = _a2.onUpdate, onEnd = _a2.onEnd, payload = _a2.payload, children = _a2.children;
  var context = (0, import_react.useContext)(DragDropContext);
  var dragDropProvider = context;
  return (0, import_react.createElement)(Draggable, { onStart: function(_a3) {
    var x = _a3.x, y = _a3.y;
    dragDropProvider === null || dragDropProvider === void 0 ? void 0 : dragDropProvider.start(payload, { x, y });
    onStart === null || onStart === void 0 ? void 0 : onStart({ clientOffset: { x, y } });
  }, onUpdate: function(_a3) {
    var x = _a3.x, y = _a3.y;
    dragDropProvider === null || dragDropProvider === void 0 ? void 0 : dragDropProvider.update({ x, y });
    onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate({ clientOffset: { x, y } });
  }, onEnd: function(_a3) {
    var x = _a3.x, y = _a3.y;
    dragDropProvider === null || dragDropProvider === void 0 ? void 0 : dragDropProvider.end({ x, y });
    onEnd === null || onEnd === void 0 ? void 0 : onEnd({ clientOffset: { x, y } });
  }, dragItem: ref }, children);
});
DragSource.defaultProps = defaultProps$1;
var clamp$1 = function(value, min2, max2) {
  return Math.max(Math.min(value, max2), min2);
};
var defaultProps$2 = {
  onEnter: function(args) {
  },
  onOver: function(args) {
  },
  onLeave: function(args) {
  },
  onDrop: function(args) {
  }
};
var DropTarget = function(_super) {
  __extends(DropTarget2, _super);
  function DropTarget2(props) {
    var _this = _super.call(this, props) || this;
    _this.isOver = false;
    _this.handleDrag = _this.handleDrag.bind(_this);
    _this.elementRef = (0, import_react.createRef)();
    return _this;
  }
  DropTarget2.prototype.componentDidMount = function() {
    var dragEmitter = this.context.dragEmitter;
    dragEmitter.subscribe(this.handleDrag);
  };
  DropTarget2.prototype.shouldComponentUpdate = function(nextProps) {
    var children = this.props.children;
    return nextProps.children !== children;
  };
  DropTarget2.prototype.componentWillUnmount = function() {
    var dragEmitter = this.context.dragEmitter;
    dragEmitter.unsubscribe(this.handleDrag);
  };
  DropTarget2.prototype.handleDrag = function(_a2) {
    var payload = _a2.payload, clientOffset = _a2.clientOffset, end = _a2.end;
    var _b = this.elementRef.current.getBoundingClientRect(), left = _b.left, top = _b.top, right = _b.right, bottom = _b.bottom;
    var _c = this.props, onDrop = _c.onDrop, onEnter = _c.onEnter, onLeave = _c.onLeave, onOver = _c.onOver;
    var isOver = clientOffset && clamp$1(clientOffset.x, left, right) === clientOffset.x && clamp$1(clientOffset.y, top, bottom) === clientOffset.y;
    if (!this.isOver && isOver)
      onEnter({ payload, clientOffset });
    if (this.isOver && isOver)
      onOver({ payload, clientOffset });
    if (this.isOver && !isOver)
      onLeave({ payload, clientOffset });
    if (isOver && end)
      onDrop({ payload, clientOffset });
    this.isOver = isOver && !end;
  };
  DropTarget2.prototype.render = function() {
    var children = this.props.children;
    return (0, import_react.createElement)(RefHolder, { ref: this.elementRef }, import_react.Children.only(children));
  };
  DropTarget2.defaultProps = defaultProps$2;
  return DropTarget2;
}(import_react.Component);
DropTarget.contextType = DragDropContext;
var SCROLL_OFFSET = 2;
var styles = {
  root: {
    position: "relative"
  },
  triggersRoot: {
    position: "absolute",
    top: 0,
    left: 0,
    height: "100%",
    width: "100%",
    overflow: "hidden",
    zIndex: -1,
    visibility: "hidden",
    opacity: 0
  },
  expandTrigger: {
    position: "absolute",
    top: 0,
    left: 0,
    height: "100%",
    width: "100%",
    overflow: "auto"
  },
  contractTrigger: {
    position: "absolute",
    top: 0,
    left: 0,
    height: "100%",
    width: "100%",
    overflow: "auto",
    minHeight: "1px",
    minWidth: "1px"
  },
  contractNotifier: {
    position: "absolute",
    top: 0,
    left: 0,
    width: "200%",
    height: "200%",
    minHeight: "2px",
    minWidth: "2px"
  }
};
var Sizer = function(_super) {
  __extends(Sizer2, _super);
  function Sizer2(props) {
    var _this = _super.call(this, props) || this;
    _this.getSize = function() {
      return {
        height: _this.rootNode.clientHeight,
        width: _this.rootNode.clientWidth
      };
    };
    _this.setupListeners = _this.setupListeners.bind(_this);
    _this.updateScrolling = _this.updateScrolling.bind(_this);
    _this.rootRef = (0, import_react.createRef)();
    return _this;
  }
  Sizer2.prototype.componentDidMount = function() {
    this.rootNode = this.rootRef.current;
    this.createListeners();
    this.expandTrigger.addEventListener("scroll", this.setupListeners);
    this.contractTrigger.addEventListener("scroll", this.setupListeners);
    this.setupListeners();
  };
  Sizer2.prototype.shouldComponentUpdate = function(prevProps) {
    if (prevProps.scrollTop !== this.props.scrollTop || prevProps.scrollLeft !== this.props.scrollLeft || prevProps.style && this.props.style && !shallowEqual(prevProps.style, this.props.style) || prevProps.style && !this.props.style || prevProps.children !== this.props.children) {
      return true;
    }
    return false;
  };
  Sizer2.prototype.componentDidUpdate = function() {
    var _a2 = this.props, scrollTop = _a2.scrollTop, scrollLeft = _a2.scrollLeft;
    if (scrollTop !== void 0 && scrollTop > -1) {
      this.rootNode.scrollTop = scrollTop;
    }
    if (scrollLeft !== void 0 && scrollLeft > -1) {
      this.rootNode.scrollLeft = scrollLeft;
    }
    this.updateScrolling(this.getSize());
  };
  Sizer2.prototype.componentWillUnmount = function() {
    this.expandTrigger.removeEventListener("scroll", this.setupListeners);
    this.contractTrigger.removeEventListener("scroll", this.setupListeners);
  };
  Sizer2.prototype.setupListeners = function() {
    var size = this.getSize();
    var width = size.width, height = size.height;
    this.expandNotifier.style.width = "".concat(width + SCROLL_OFFSET, "px");
    this.expandNotifier.style.height = "".concat(height + SCROLL_OFFSET, "px");
    this.updateScrolling(size);
    var onSizeChange = this.props.onSizeChange;
    onSizeChange(size);
  };
  Sizer2.prototype.createListeners = function() {
    this.triggersRoot = document.createElement("div");
    Object.assign(this.triggersRoot.style, styles.triggersRoot);
    this.rootNode.appendChild(this.triggersRoot);
    this.expandTrigger = document.createElement("div");
    Object.assign(this.expandTrigger.style, styles.expandTrigger);
    this.expandTrigger.addEventListener("scroll", this.setupListeners);
    this.triggersRoot.appendChild(this.expandTrigger);
    this.expandNotifier = document.createElement("div");
    this.expandTrigger.appendChild(this.expandNotifier);
    this.contractTrigger = document.createElement("div");
    Object.assign(this.contractTrigger.style, styles.contractTrigger);
    this.contractTrigger.addEventListener("scroll", this.setupListeners);
    this.triggersRoot.appendChild(this.contractTrigger);
    this.contractNotifier = document.createElement("div");
    Object.assign(this.contractNotifier.style, styles.contractNotifier);
    this.contractTrigger.appendChild(this.contractNotifier);
  };
  Sizer2.prototype.updateScrolling = function(size) {
    var width = size.width, height = size.height;
    this.contractTrigger.scrollTop = height;
    this.contractTrigger.scrollLeft = width;
    this.expandTrigger.scrollTop = SCROLL_OFFSET;
    this.expandTrigger.scrollLeft = SCROLL_OFFSET;
  };
  Sizer2.prototype.render = function() {
    var _a2 = this.props, onSizeChange = _a2.onSizeChange, Container = _a2.containerComponent, style = _a2.style, scrollTop = _a2.scrollTop, scrollLeft = _a2.scrollLeft, restProps = __rest(_a2, ["onSizeChange", "containerComponent", "style", "scrollTop", "scrollLeft"]);
    return (0, import_react.createElement)(
      Container,
      __assign({ forwardedRef: this.rootRef, style: style ? __assign(__assign({}, styles.root), style) : styles.root }, restProps)
    );
  };
  Sizer2.defaultProps = {
    containerComponent: "div"
  };
  return Sizer2;
}(import_react.Component);
var createStateHelper = function(component, controlledStateProperties) {
  if (controlledStateProperties === void 0) {
    controlledStateProperties = {};
  }
  var notifyStateChange = function(nextState, state) {
    Object.keys(controlledStateProperties).forEach(function(propertyName) {
      var changeEvent = controlledStateProperties[propertyName]();
      if (changeEvent && nextState[propertyName] !== state[propertyName]) {
        changeEvent(nextState[propertyName]);
      }
    });
  };
  var lastStateUpdater;
  var initialState = null;
  var lastInitialState = null;
  var newState = null;
  var shouldNotify = false;
  var applyReducer = function(reduce, payload, callback) {
    var stateUpdater = function(prevState) {
      if (initialState === null) {
        initialState = prevState;
      }
      var stateChange = reduce(__assign({}, prevState), payload);
      var state = __assign(__assign({}, prevState), stateChange);
      if (typeof callback === "function") {
        callback(state, prevState);
      }
      if (stateUpdater === lastStateUpdater) {
        if (lastInitialState !== initialState) {
          newState = state;
          if (!shouldNotify) {
            lastInitialState = initialState;
            shouldNotify = true;
          }
        }
        initialState = null;
      }
      return stateChange;
    };
    lastStateUpdater = stateUpdater;
    component.setState(stateUpdater, function() {
      if (shouldNotify) {
        notifyStateChange(newState, lastInitialState);
        shouldNotify = false;
      }
    });
  };
  var applyFieldReducer = function(field, reduce, payload) {
    applyReducer(function(state) {
      var _a2;
      return _a2 = {}, _a2[field] = reduce(state[field], payload), _a2;
    });
  };
  return {
    applyReducer,
    applyFieldReducer
  };
};
var makeBoundComponent = function(Target, components, exposed) {
  var Component2 = function(_super) {
    __extends(Component3, _super);
    function Component3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Component3.prototype.render = function() {
      return (0, import_react.createElement)(Target, __assign({}, components, this.props));
    };
    return Component3;
  }(import_react.PureComponent);
  Component2.components = Target.components;
  Object.assign(Component2, exposed);
  return Component2;
};
var withComponents = function(components) {
  return function(Target) {
    var props = {};
    var exposed = {};
    var targetComponents = Target.components;
    Object.entries(targetComponents).forEach(function(_a2) {
      var _b = __read2(_a2, 2), fieldName = _b[0], componentName = _b[1];
      var component = components[componentName];
      if (component && component !== Target[componentName]) {
        props[fieldName] = component;
      }
      exposed[componentName] = component || Target[componentName];
    });
    return Object.keys(props).length > 0 ? makeBoundComponent(Target, props, exposed) : Target;
  };
};
var RefType = import_prop_types.default.shape({
  current: import_prop_types.default.instanceOf(typeof Element !== "undefined" ? Element : Object)
});

// node_modules/moment/dist/moment.js
var hookCallback;
function hooks() {
  return hookCallback.apply(null, arguments);
}
function setHookCallback(callback) {
  hookCallback = callback;
}
function isArray(input) {
  return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
}
function isObject(input) {
  return input != null && Object.prototype.toString.call(input) === "[object Object]";
}
function hasOwnProp(a, b) {
  return Object.prototype.hasOwnProperty.call(a, b);
}
function isObjectEmpty(obj) {
  if (Object.getOwnPropertyNames) {
    return Object.getOwnPropertyNames(obj).length === 0;
  } else {
    var k;
    for (k in obj) {
      if (hasOwnProp(obj, k)) {
        return false;
      }
    }
    return true;
  }
}
function isUndefined(input) {
  return input === void 0;
}
function isNumber(input) {
  return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
}
function isDate(input) {
  return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
}
function map(arr, fn) {
  var res = [], i, arrLen = arr.length;
  for (i = 0; i < arrLen; ++i) {
    res.push(fn(arr[i], i));
  }
  return res;
}
function extend(a, b) {
  for (var i in b) {
    if (hasOwnProp(b, i)) {
      a[i] = b[i];
    }
  }
  if (hasOwnProp(b, "toString")) {
    a.toString = b.toString;
  }
  if (hasOwnProp(b, "valueOf")) {
    a.valueOf = b.valueOf;
  }
  return a;
}
function createUTC(input, format2, locale2, strict) {
  return createLocalOrUTC(input, format2, locale2, strict, true).utc();
}
function defaultParsingFlags() {
  return {
    empty: false,
    unusedTokens: [],
    unusedInput: [],
    overflow: -2,
    charsLeftOver: 0,
    nullInput: false,
    invalidEra: null,
    invalidMonth: null,
    invalidFormat: false,
    userInvalidated: false,
    iso: false,
    parsedDateParts: [],
    era: null,
    meridiem: null,
    rfc2822: false,
    weekdayMismatch: false
  };
}
function getParsingFlags(m) {
  if (m._pf == null) {
    m._pf = defaultParsingFlags();
  }
  return m._pf;
}
var some;
if (Array.prototype.some) {
  some = Array.prototype.some;
} else {
  some = function(fun) {
    var t = Object(this), len = t.length >>> 0, i;
    for (i = 0; i < len; i++) {
      if (i in t && fun.call(this, t[i], i, t)) {
        return true;
      }
    }
    return false;
  };
}
function isValid(m) {
  if (m._isValid == null) {
    var flags = getParsingFlags(m), parsedParts = some.call(flags.parsedDateParts, function(i) {
      return i != null;
    }), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
    if (m._strict) {
      isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
    }
    if (Object.isFrozen == null || !Object.isFrozen(m)) {
      m._isValid = isNowValid;
    } else {
      return isNowValid;
    }
  }
  return m._isValid;
}
function createInvalid(flags) {
  var m = createUTC(NaN);
  if (flags != null) {
    extend(getParsingFlags(m), flags);
  } else {
    getParsingFlags(m).userInvalidated = true;
  }
  return m;
}
var momentProperties = hooks.momentProperties = [];
var updateInProgress = false;
function copyConfig(to2, from2) {
  var i, prop, val, momentPropertiesLen = momentProperties.length;
  if (!isUndefined(from2._isAMomentObject)) {
    to2._isAMomentObject = from2._isAMomentObject;
  }
  if (!isUndefined(from2._i)) {
    to2._i = from2._i;
  }
  if (!isUndefined(from2._f)) {
    to2._f = from2._f;
  }
  if (!isUndefined(from2._l)) {
    to2._l = from2._l;
  }
  if (!isUndefined(from2._strict)) {
    to2._strict = from2._strict;
  }
  if (!isUndefined(from2._tzm)) {
    to2._tzm = from2._tzm;
  }
  if (!isUndefined(from2._isUTC)) {
    to2._isUTC = from2._isUTC;
  }
  if (!isUndefined(from2._offset)) {
    to2._offset = from2._offset;
  }
  if (!isUndefined(from2._pf)) {
    to2._pf = getParsingFlags(from2);
  }
  if (!isUndefined(from2._locale)) {
    to2._locale = from2._locale;
  }
  if (momentPropertiesLen > 0) {
    for (i = 0; i < momentPropertiesLen; i++) {
      prop = momentProperties[i];
      val = from2[prop];
      if (!isUndefined(val)) {
        to2[prop] = val;
      }
    }
  }
  return to2;
}
function Moment(config) {
  copyConfig(this, config);
  this._d = new Date(config._d != null ? config._d.getTime() : NaN);
  if (!this.isValid()) {
    this._d = /* @__PURE__ */ new Date(NaN);
  }
  if (updateInProgress === false) {
    updateInProgress = true;
    hooks.updateOffset(this);
    updateInProgress = false;
  }
}
function isMoment(obj) {
  return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
}
function warn(msg) {
  if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
    console.warn("Deprecation warning: " + msg);
  }
}
function deprecate(msg, fn) {
  var firstTime = true;
  return extend(function() {
    if (hooks.deprecationHandler != null) {
      hooks.deprecationHandler(null, msg);
    }
    if (firstTime) {
      var args = [], arg, i, key, argLen = arguments.length;
      for (i = 0; i < argLen; i++) {
        arg = "";
        if (typeof arguments[i] === "object") {
          arg += "\n[" + i + "] ";
          for (key in arguments[0]) {
            if (hasOwnProp(arguments[0], key)) {
              arg += key + ": " + arguments[0][key] + ", ";
            }
          }
          arg = arg.slice(0, -2);
        } else {
          arg = arguments[i];
        }
        args.push(arg);
      }
      warn(
        msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
      );
      firstTime = false;
    }
    return fn.apply(this, arguments);
  }, fn);
}
var deprecations = {};
function deprecateSimple(name, msg) {
  if (hooks.deprecationHandler != null) {
    hooks.deprecationHandler(name, msg);
  }
  if (!deprecations[name]) {
    warn(msg);
    deprecations[name] = true;
  }
}
hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;
function isFunction(input) {
  return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
}
function set(config) {
  var prop, i;
  for (i in config) {
    if (hasOwnProp(config, i)) {
      prop = config[i];
      if (isFunction(prop)) {
        this[i] = prop;
      } else {
        this["_" + i] = prop;
      }
    }
  }
  this._config = config;
  this._dayOfMonthOrdinalParseLenient = new RegExp(
    (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
  );
}
function mergeConfigs(parentConfig, childConfig) {
  var res = extend({}, parentConfig), prop;
  for (prop in childConfig) {
    if (hasOwnProp(childConfig, prop)) {
      if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
        res[prop] = {};
        extend(res[prop], parentConfig[prop]);
        extend(res[prop], childConfig[prop]);
      } else if (childConfig[prop] != null) {
        res[prop] = childConfig[prop];
      } else {
        delete res[prop];
      }
    }
  }
  for (prop in parentConfig) {
    if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
      res[prop] = extend({}, res[prop]);
    }
  }
  return res;
}
function Locale(config) {
  if (config != null) {
    this.set(config);
  }
}
var keys;
if (Object.keys) {
  keys = Object.keys;
} else {
  keys = function(obj) {
    var i, res = [];
    for (i in obj) {
      if (hasOwnProp(obj, i)) {
        res.push(i);
      }
    }
    return res;
  };
}
var defaultCalendar = {
  sameDay: "[Today at] LT",
  nextDay: "[Tomorrow at] LT",
  nextWeek: "dddd [at] LT",
  lastDay: "[Yesterday at] LT",
  lastWeek: "[Last] dddd [at] LT",
  sameElse: "L"
};
function calendar(key, mom, now2) {
  var output = this._calendar[key] || this._calendar["sameElse"];
  return isFunction(output) ? output.call(mom, now2) : output;
}
function zeroFill(number, targetLength, forceSign) {
  var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
  return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}
var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
var formatFunctions = {};
var formatTokenFunctions = {};
function addFormatToken(token2, padded, ordinal2, callback) {
  var func = callback;
  if (typeof callback === "string") {
    func = function() {
      return this[callback]();
    };
  }
  if (token2) {
    formatTokenFunctions[token2] = func;
  }
  if (padded) {
    formatTokenFunctions[padded[0]] = function() {
      return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
    };
  }
  if (ordinal2) {
    formatTokenFunctions[ordinal2] = function() {
      return this.localeData().ordinal(
        func.apply(this, arguments),
        token2
      );
    };
  }
}
function removeFormattingTokens(input) {
  if (input.match(/\[[\s\S]/)) {
    return input.replace(/^\[|\]$/g, "");
  }
  return input.replace(/\\/g, "");
}
function makeFormatFunction(format2) {
  var array = format2.match(formattingTokens), i, length;
  for (i = 0, length = array.length; i < length; i++) {
    if (formatTokenFunctions[array[i]]) {
      array[i] = formatTokenFunctions[array[i]];
    } else {
      array[i] = removeFormattingTokens(array[i]);
    }
  }
  return function(mom) {
    var output = "", i2;
    for (i2 = 0; i2 < length; i2++) {
      output += isFunction(array[i2]) ? array[i2].call(mom, format2) : array[i2];
    }
    return output;
  };
}
function formatMoment(m, format2) {
  if (!m.isValid()) {
    return m.localeData().invalidDate();
  }
  format2 = expandFormat(format2, m.localeData());
  formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
  return formatFunctions[format2](m);
}
function expandFormat(format2, locale2) {
  var i = 5;
  function replaceLongDateFormatTokens(input) {
    return locale2.longDateFormat(input) || input;
  }
  localFormattingTokens.lastIndex = 0;
  while (i >= 0 && localFormattingTokens.test(format2)) {
    format2 = format2.replace(
      localFormattingTokens,
      replaceLongDateFormatTokens
    );
    localFormattingTokens.lastIndex = 0;
    i -= 1;
  }
  return format2;
}
var defaultLongDateFormat = {
  LTS: "h:mm:ss A",
  LT: "h:mm A",
  L: "MM/DD/YYYY",
  LL: "MMMM D, YYYY",
  LLL: "MMMM D, YYYY h:mm A",
  LLLL: "dddd, MMMM D, YYYY h:mm A"
};
function longDateFormat(key) {
  var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
  if (format2 || !formatUpper) {
    return format2;
  }
  this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
    if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
      return tok.slice(1);
    }
    return tok;
  }).join("");
  return this._longDateFormat[key];
}
var defaultInvalidDate = "Invalid date";
function invalidDate() {
  return this._invalidDate;
}
var defaultOrdinal = "%d";
var defaultDayOfMonthOrdinalParse = /\d{1,2}/;
function ordinal(number) {
  return this._ordinal.replace("%d", number);
}
var defaultRelativeTime = {
  future: "in %s",
  past: "%s ago",
  s: "a few seconds",
  ss: "%d seconds",
  m: "a minute",
  mm: "%d minutes",
  h: "an hour",
  hh: "%d hours",
  d: "a day",
  dd: "%d days",
  w: "a week",
  ww: "%d weeks",
  M: "a month",
  MM: "%d months",
  y: "a year",
  yy: "%d years"
};
function relativeTime(number, withoutSuffix, string, isFuture) {
  var output = this._relativeTime[string];
  return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
}
function pastFuture(diff2, output) {
  var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
  return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
}
var aliases = {};
function addUnitAlias(unit, shorthand) {
  var lowerCase = unit.toLowerCase();
  aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
}
function normalizeUnits(units) {
  return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
}
function normalizeObjectUnits(inputObject) {
  var normalizedInput = {}, normalizedProp, prop;
  for (prop in inputObject) {
    if (hasOwnProp(inputObject, prop)) {
      normalizedProp = normalizeUnits(prop);
      if (normalizedProp) {
        normalizedInput[normalizedProp] = inputObject[prop];
      }
    }
  }
  return normalizedInput;
}
var priorities = {};
function addUnitPriority(unit, priority) {
  priorities[unit] = priority;
}
function getPrioritizedUnits(unitsObj) {
  var units = [], u;
  for (u in unitsObj) {
    if (hasOwnProp(unitsObj, u)) {
      units.push({ unit: u, priority: priorities[u] });
    }
  }
  units.sort(function(a, b) {
    return a.priority - b.priority;
  });
  return units;
}
function isLeapYear(year) {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
}
function absFloor(number) {
  if (number < 0) {
    return Math.ceil(number) || 0;
  } else {
    return Math.floor(number);
  }
}
function toInt(argumentForCoercion) {
  var coercedNumber = +argumentForCoercion, value = 0;
  if (coercedNumber !== 0 && isFinite(coercedNumber)) {
    value = absFloor(coercedNumber);
  }
  return value;
}
function makeGetSet(unit, keepTime) {
  return function(value) {
    if (value != null) {
      set$1(this, unit, value);
      hooks.updateOffset(this, keepTime);
      return this;
    } else {
      return get(this, unit);
    }
  };
}
function get(mom, unit) {
  return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
}
function set$1(mom, unit, value) {
  if (mom.isValid() && !isNaN(value)) {
    if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
      value = toInt(value);
      mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](
        value,
        mom.month(),
        daysInMonth(value, mom.month())
      );
    } else {
      mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
    }
  }
}
function stringGet(units) {
  units = normalizeUnits(units);
  if (isFunction(this[units])) {
    return this[units]();
  }
  return this;
}
function stringSet(units, value) {
  if (typeof units === "object") {
    units = normalizeObjectUnits(units);
    var prioritized = getPrioritizedUnits(units), i, prioritizedLen = prioritized.length;
    for (i = 0; i < prioritizedLen; i++) {
      this[prioritized[i].unit](units[prioritized[i].unit]);
    }
  } else {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
      return this[units](value);
    }
  }
  return this;
}
var match1 = /\d/;
var match2 = /\d\d/;
var match3 = /\d{3}/;
var match4 = /\d{4}/;
var match6 = /[+-]?\d{6}/;
var match1to2 = /\d\d?/;
var match3to4 = /\d\d\d\d?/;
var match5to6 = /\d\d\d\d\d\d?/;
var match1to3 = /\d{1,3}/;
var match1to4 = /\d{1,4}/;
var match1to6 = /[+-]?\d{1,6}/;
var matchUnsigned = /\d+/;
var matchSigned = /[+-]?\d+/;
var matchOffset = /Z|[+-]\d\d:?\d\d/gi;
var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi;
var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/;
var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;
var regexes;
regexes = {};
function addRegexToken(token2, regex, strictRegex) {
  regexes[token2] = isFunction(regex) ? regex : function(isStrict, localeData2) {
    return isStrict && strictRegex ? strictRegex : regex;
  };
}
function getParseRegexForToken(token2, config) {
  if (!hasOwnProp(regexes, token2)) {
    return new RegExp(unescapeFormat(token2));
  }
  return regexes[token2](config._strict, config._locale);
}
function unescapeFormat(s) {
  return regexEscape(
    s.replace("\\", "").replace(
      /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
      function(matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
      }
    )
  );
}
function regexEscape(s) {
  return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}
var tokens = {};
function addParseToken(token2, callback) {
  var i, func = callback, tokenLen;
  if (typeof token2 === "string") {
    token2 = [token2];
  }
  if (isNumber(callback)) {
    func = function(input, array) {
      array[callback] = toInt(input);
    };
  }
  tokenLen = token2.length;
  for (i = 0; i < tokenLen; i++) {
    tokens[token2[i]] = func;
  }
}
function addWeekParseToken(token2, callback) {
  addParseToken(token2, function(input, array, config, token3) {
    config._w = config._w || {};
    callback(input, config._w, config, token3);
  });
}
function addTimeToArrayFromToken(token2, input, config) {
  if (input != null && hasOwnProp(tokens, token2)) {
    tokens[token2](input, config._a, config, token2);
  }
}
var YEAR = 0;
var MONTH = 1;
var DATE = 2;
var HOUR = 3;
var MINUTE = 4;
var SECOND = 5;
var MILLISECOND = 6;
var WEEK = 7;
var WEEKDAY = 8;
function mod(n, x) {
  return (n % x + x) % x;
}
var indexOf;
if (Array.prototype.indexOf) {
  indexOf = Array.prototype.indexOf;
} else {
  indexOf = function(o) {
    var i;
    for (i = 0; i < this.length; ++i) {
      if (this[i] === o) {
        return i;
      }
    }
    return -1;
  };
}
function daysInMonth(year, month) {
  if (isNaN(year) || isNaN(month)) {
    return NaN;
  }
  var modMonth = mod(month, 12);
  year += (month - modMonth) / 12;
  return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
}
addFormatToken("M", ["MM", 2], "Mo", function() {
  return this.month() + 1;
});
addFormatToken("MMM", 0, 0, function(format2) {
  return this.localeData().monthsShort(this, format2);
});
addFormatToken("MMMM", 0, 0, function(format2) {
  return this.localeData().months(this, format2);
});
addUnitAlias("month", "M");
addUnitPriority("month", 8);
addRegexToken("M", match1to2);
addRegexToken("MM", match1to2, match2);
addRegexToken("MMM", function(isStrict, locale2) {
  return locale2.monthsShortRegex(isStrict);
});
addRegexToken("MMMM", function(isStrict, locale2) {
  return locale2.monthsRegex(isStrict);
});
addParseToken(["M", "MM"], function(input, array) {
  array[MONTH] = toInt(input) - 1;
});
addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
  var month = config._locale.monthsParse(input, token2, config._strict);
  if (month != null) {
    array[MONTH] = month;
  } else {
    getParsingFlags(config).invalidMonth = input;
  }
});
var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
  "_"
);
var defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");
var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
var defaultMonthsShortRegex = matchWord;
var defaultMonthsRegex = matchWord;
function localeMonths(m, format2) {
  if (!m) {
    return isArray(this._months) ? this._months : this._months["standalone"];
  }
  return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
}
function localeMonthsShort(m, format2) {
  if (!m) {
    return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
  }
  return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
}
function handleStrictParse(monthName, format2, strict) {
  var i, ii, mom, llc = monthName.toLocaleLowerCase();
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
    for (i = 0; i < 12; ++i) {
      mom = createUTC([2e3, i]);
      this._shortMonthsParse[i] = this.monthsShort(
        mom,
        ""
      ).toLocaleLowerCase();
      this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format2 === "MMM") {
      ii = indexOf.call(this._shortMonthsParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._longMonthsParse, llc);
      return ii !== -1 ? ii : null;
    }
  } else {
    if (format2 === "MMM") {
      ii = indexOf.call(this._shortMonthsParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._longMonthsParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._longMonthsParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._shortMonthsParse, llc);
      return ii !== -1 ? ii : null;
    }
  }
}
function localeMonthsParse(monthName, format2, strict) {
  var i, mom, regex;
  if (this._monthsParseExact) {
    return handleStrictParse.call(this, monthName, format2, strict);
  }
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
  }
  for (i = 0; i < 12; i++) {
    mom = createUTC([2e3, i]);
    if (strict && !this._longMonthsParse[i]) {
      this._longMonthsParse[i] = new RegExp(
        "^" + this.months(mom, "").replace(".", "") + "$",
        "i"
      );
      this._shortMonthsParse[i] = new RegExp(
        "^" + this.monthsShort(mom, "").replace(".", "") + "$",
        "i"
      );
    }
    if (!strict && !this._monthsParse[i]) {
      regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
      this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
    }
    if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
      return i;
    } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
      return i;
    } else if (!strict && this._monthsParse[i].test(monthName)) {
      return i;
    }
  }
}
function setMonth(mom, value) {
  var dayOfMonth;
  if (!mom.isValid()) {
    return mom;
  }
  if (typeof value === "string") {
    if (/^\d+$/.test(value)) {
      value = toInt(value);
    } else {
      value = mom.localeData().monthsParse(value);
      if (!isNumber(value)) {
        return mom;
      }
    }
  }
  dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
  mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
  return mom;
}
function getSetMonth(value) {
  if (value != null) {
    setMonth(this, value);
    hooks.updateOffset(this, true);
    return this;
  } else {
    return get(this, "Month");
  }
}
function getDaysInMonth() {
  return daysInMonth(this.year(), this.month());
}
function monthsShortRegex(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp(this, "_monthsRegex")) {
      computeMonthsParse.call(this);
    }
    if (isStrict) {
      return this._monthsShortStrictRegex;
    } else {
      return this._monthsShortRegex;
    }
  } else {
    if (!hasOwnProp(this, "_monthsShortRegex")) {
      this._monthsShortRegex = defaultMonthsShortRegex;
    }
    return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
  }
}
function monthsRegex(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp(this, "_monthsRegex")) {
      computeMonthsParse.call(this);
    }
    if (isStrict) {
      return this._monthsStrictRegex;
    } else {
      return this._monthsRegex;
    }
  } else {
    if (!hasOwnProp(this, "_monthsRegex")) {
      this._monthsRegex = defaultMonthsRegex;
    }
    return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
  }
}
function computeMonthsParse() {
  function cmpLenRev(a, b) {
    return b.length - a.length;
  }
  var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;
  for (i = 0; i < 12; i++) {
    mom = createUTC([2e3, i]);
    shortPieces.push(this.monthsShort(mom, ""));
    longPieces.push(this.months(mom, ""));
    mixedPieces.push(this.months(mom, ""));
    mixedPieces.push(this.monthsShort(mom, ""));
  }
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  for (i = 0; i < 12; i++) {
    shortPieces[i] = regexEscape(shortPieces[i]);
    longPieces[i] = regexEscape(longPieces[i]);
  }
  for (i = 0; i < 24; i++) {
    mixedPieces[i] = regexEscape(mixedPieces[i]);
  }
  this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._monthsShortRegex = this._monthsRegex;
  this._monthsStrictRegex = new RegExp(
    "^(" + longPieces.join("|") + ")",
    "i"
  );
  this._monthsShortStrictRegex = new RegExp(
    "^(" + shortPieces.join("|") + ")",
    "i"
  );
}
addFormatToken("Y", 0, 0, function() {
  var y = this.year();
  return y <= 9999 ? zeroFill(y, 4) : "+" + y;
});
addFormatToken(0, ["YY", 2], 0, function() {
  return this.year() % 100;
});
addFormatToken(0, ["YYYY", 4], 0, "year");
addFormatToken(0, ["YYYYY", 5], 0, "year");
addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
addUnitAlias("year", "y");
addUnitPriority("year", 1);
addRegexToken("Y", matchSigned);
addRegexToken("YY", match1to2, match2);
addRegexToken("YYYY", match1to4, match4);
addRegexToken("YYYYY", match1to6, match6);
addRegexToken("YYYYYY", match1to6, match6);
addParseToken(["YYYYY", "YYYYYY"], YEAR);
addParseToken("YYYY", function(input, array) {
  array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
});
addParseToken("YY", function(input, array) {
  array[YEAR] = hooks.parseTwoDigitYear(input);
});
addParseToken("Y", function(input, array) {
  array[YEAR] = parseInt(input, 10);
});
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
hooks.parseTwoDigitYear = function(input) {
  return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
};
var getSetYear = makeGetSet("FullYear", true);
function getIsLeapYear() {
  return isLeapYear(this.year());
}
function createDate(y, m, d, h, M, s, ms) {
  var date;
  if (y < 100 && y >= 0) {
    date = new Date(y + 400, m, d, h, M, s, ms);
    if (isFinite(date.getFullYear())) {
      date.setFullYear(y);
    }
  } else {
    date = new Date(y, m, d, h, M, s, ms);
  }
  return date;
}
function createUTCDate(y) {
  var date, args;
  if (y < 100 && y >= 0) {
    args = Array.prototype.slice.call(arguments);
    args[0] = y + 400;
    date = new Date(Date.UTC.apply(null, args));
    if (isFinite(date.getUTCFullYear())) {
      date.setUTCFullYear(y);
    }
  } else {
    date = new Date(Date.UTC.apply(null, arguments));
  }
  return date;
}
function firstWeekOffset(year, dow, doy) {
  var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
  return -fwdlw + fwd - 1;
}
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
  var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
  if (dayOfYear <= 0) {
    resYear = year - 1;
    resDayOfYear = daysInYear(resYear) + dayOfYear;
  } else if (dayOfYear > daysInYear(year)) {
    resYear = year + 1;
    resDayOfYear = dayOfYear - daysInYear(year);
  } else {
    resYear = year;
    resDayOfYear = dayOfYear;
  }
  return {
    year: resYear,
    dayOfYear: resDayOfYear
  };
}
function weekOfYear(mom, dow, doy) {
  var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
  if (week < 1) {
    resYear = mom.year() - 1;
    resWeek = week + weeksInYear(resYear, dow, doy);
  } else if (week > weeksInYear(mom.year(), dow, doy)) {
    resWeek = week - weeksInYear(mom.year(), dow, doy);
    resYear = mom.year() + 1;
  } else {
    resYear = mom.year();
    resWeek = week;
  }
  return {
    week: resWeek,
    year: resYear
  };
}
function weeksInYear(year, dow, doy) {
  var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
  return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}
addFormatToken("w", ["ww", 2], "wo", "week");
addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
addUnitAlias("week", "w");
addUnitAlias("isoWeek", "W");
addUnitPriority("week", 5);
addUnitPriority("isoWeek", 5);
addRegexToken("w", match1to2);
addRegexToken("ww", match1to2, match2);
addRegexToken("W", match1to2);
addRegexToken("WW", match1to2, match2);
addWeekParseToken(
  ["w", "ww", "W", "WW"],
  function(input, week, config, token2) {
    week[token2.substr(0, 1)] = toInt(input);
  }
);
function localeWeek(mom) {
  return weekOfYear(mom, this._week.dow, this._week.doy).week;
}
var defaultLocaleWeek = {
  dow: 0,
  // Sunday is the first day of the week.
  doy: 6
  // The week that contains Jan 6th is the first week of the year.
};
function localeFirstDayOfWeek() {
  return this._week.dow;
}
function localeFirstDayOfYear() {
  return this._week.doy;
}
function getSetWeek(input) {
  var week = this.localeData().week(this);
  return input == null ? week : this.add((input - week) * 7, "d");
}
function getSetISOWeek(input) {
  var week = weekOfYear(this, 1, 4).week;
  return input == null ? week : this.add((input - week) * 7, "d");
}
addFormatToken("d", 0, "do", "day");
addFormatToken("dd", 0, 0, function(format2) {
  return this.localeData().weekdaysMin(this, format2);
});
addFormatToken("ddd", 0, 0, function(format2) {
  return this.localeData().weekdaysShort(this, format2);
});
addFormatToken("dddd", 0, 0, function(format2) {
  return this.localeData().weekdays(this, format2);
});
addFormatToken("e", 0, 0, "weekday");
addFormatToken("E", 0, 0, "isoWeekday");
addUnitAlias("day", "d");
addUnitAlias("weekday", "e");
addUnitAlias("isoWeekday", "E");
addUnitPriority("day", 11);
addUnitPriority("weekday", 11);
addUnitPriority("isoWeekday", 11);
addRegexToken("d", match1to2);
addRegexToken("e", match1to2);
addRegexToken("E", match1to2);
addRegexToken("dd", function(isStrict, locale2) {
  return locale2.weekdaysMinRegex(isStrict);
});
addRegexToken("ddd", function(isStrict, locale2) {
  return locale2.weekdaysShortRegex(isStrict);
});
addRegexToken("dddd", function(isStrict, locale2) {
  return locale2.weekdaysRegex(isStrict);
});
addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
  var weekday = config._locale.weekdaysParse(input, token2, config._strict);
  if (weekday != null) {
    week.d = weekday;
  } else {
    getParsingFlags(config).invalidWeekday = input;
  }
});
addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
  week[token2] = toInt(input);
});
function parseWeekday(input, locale2) {
  if (typeof input !== "string") {
    return input;
  }
  if (!isNaN(input)) {
    return parseInt(input, 10);
  }
  input = locale2.weekdaysParse(input);
  if (typeof input === "number") {
    return input;
  }
  return null;
}
function parseIsoWeekday(input, locale2) {
  if (typeof input === "string") {
    return locale2.weekdaysParse(input) % 7 || 7;
  }
  return isNaN(input) ? null : input;
}
function shiftWeekdays(ws, n) {
  return ws.slice(n, 7).concat(ws.slice(0, n));
}
var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_");
var defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_");
var defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_");
var defaultWeekdaysRegex = matchWord;
var defaultWeekdaysShortRegex = matchWord;
var defaultWeekdaysMinRegex = matchWord;
function localeWeekdays(m, format2) {
  var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
  return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
}
function localeWeekdaysShort(m) {
  return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
}
function localeWeekdaysMin(m) {
  return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
}
function handleStrictParse$1(weekdayName, format2, strict) {
  var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._minWeekdaysParse = [];
    for (i = 0; i < 7; ++i) {
      mom = createUTC([2e3, 1]).day(i);
      this._minWeekdaysParse[i] = this.weekdaysMin(
        mom,
        ""
      ).toLocaleLowerCase();
      this._shortWeekdaysParse[i] = this.weekdaysShort(
        mom,
        ""
      ).toLocaleLowerCase();
      this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format2 === "dddd") {
      ii = indexOf.call(this._weekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else if (format2 === "ddd") {
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    }
  } else {
    if (format2 === "dddd") {
      ii = indexOf.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else if (format2 === "ddd") {
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._minWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    }
  }
}
function localeWeekdaysParse(weekdayName, format2, strict) {
  var i, mom, regex;
  if (this._weekdaysParseExact) {
    return handleStrictParse$1.call(this, weekdayName, format2, strict);
  }
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._minWeekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._fullWeekdaysParse = [];
  }
  for (i = 0; i < 7; i++) {
    mom = createUTC([2e3, 1]).day(i);
    if (strict && !this._fullWeekdaysParse[i]) {
      this._fullWeekdaysParse[i] = new RegExp(
        "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
      this._shortWeekdaysParse[i] = new RegExp(
        "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
      this._minWeekdaysParse[i] = new RegExp(
        "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
    }
    if (!this._weekdaysParse[i]) {
      regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
      this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
    }
    if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
      return i;
    } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
      return i;
    } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
      return i;
    } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
      return i;
    }
  }
}
function getSetDayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
  if (input != null) {
    input = parseWeekday(input, this.localeData());
    return this.add(input - day, "d");
  } else {
    return day;
  }
}
function getSetLocaleDayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
  return input == null ? weekday : this.add(input - weekday, "d");
}
function getSetISODayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  if (input != null) {
    var weekday = parseIsoWeekday(input, this.localeData());
    return this.day(this.day() % 7 ? weekday : weekday - 7);
  } else {
    return this.day() || 7;
  }
}
function weekdaysRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysStrictRegex;
    } else {
      return this._weekdaysRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      this._weekdaysRegex = defaultWeekdaysRegex;
    }
    return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
  }
}
function weekdaysShortRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysShortStrictRegex;
    } else {
      return this._weekdaysShortRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysShortRegex")) {
      this._weekdaysShortRegex = defaultWeekdaysShortRegex;
    }
    return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
  }
}
function weekdaysMinRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysMinStrictRegex;
    } else {
      return this._weekdaysMinRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysMinRegex")) {
      this._weekdaysMinRegex = defaultWeekdaysMinRegex;
    }
    return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
  }
}
function computeWeekdaysParse() {
  function cmpLenRev(a, b) {
    return b.length - a.length;
  }
  var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
  for (i = 0; i < 7; i++) {
    mom = createUTC([2e3, 1]).day(i);
    minp = regexEscape(this.weekdaysMin(mom, ""));
    shortp = regexEscape(this.weekdaysShort(mom, ""));
    longp = regexEscape(this.weekdays(mom, ""));
    minPieces.push(minp);
    shortPieces.push(shortp);
    longPieces.push(longp);
    mixedPieces.push(minp);
    mixedPieces.push(shortp);
    mixedPieces.push(longp);
  }
  minPieces.sort(cmpLenRev);
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._weekdaysShortRegex = this._weekdaysRegex;
  this._weekdaysMinRegex = this._weekdaysRegex;
  this._weekdaysStrictRegex = new RegExp(
    "^(" + longPieces.join("|") + ")",
    "i"
  );
  this._weekdaysShortStrictRegex = new RegExp(
    "^(" + shortPieces.join("|") + ")",
    "i"
  );
  this._weekdaysMinStrictRegex = new RegExp(
    "^(" + minPieces.join("|") + ")",
    "i"
  );
}
function hFormat() {
  return this.hours() % 12 || 12;
}
function kFormat() {
  return this.hours() || 24;
}
addFormatToken("H", ["HH", 2], 0, "hour");
addFormatToken("h", ["hh", 2], 0, hFormat);
addFormatToken("k", ["kk", 2], 0, kFormat);
addFormatToken("hmm", 0, 0, function() {
  return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});
addFormatToken("hmmss", 0, 0, function() {
  return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
});
addFormatToken("Hmm", 0, 0, function() {
  return "" + this.hours() + zeroFill(this.minutes(), 2);
});
addFormatToken("Hmmss", 0, 0, function() {
  return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
});
function meridiem(token2, lowercase) {
  addFormatToken(token2, 0, 0, function() {
    return this.localeData().meridiem(
      this.hours(),
      this.minutes(),
      lowercase
    );
  });
}
meridiem("a", true);
meridiem("A", false);
addUnitAlias("hour", "h");
addUnitPriority("hour", 13);
function matchMeridiem(isStrict, locale2) {
  return locale2._meridiemParse;
}
addRegexToken("a", matchMeridiem);
addRegexToken("A", matchMeridiem);
addRegexToken("H", match1to2);
addRegexToken("h", match1to2);
addRegexToken("k", match1to2);
addRegexToken("HH", match1to2, match2);
addRegexToken("hh", match1to2, match2);
addRegexToken("kk", match1to2, match2);
addRegexToken("hmm", match3to4);
addRegexToken("hmmss", match5to6);
addRegexToken("Hmm", match3to4);
addRegexToken("Hmmss", match5to6);
addParseToken(["H", "HH"], HOUR);
addParseToken(["k", "kk"], function(input, array, config) {
  var kInput = toInt(input);
  array[HOUR] = kInput === 24 ? 0 : kInput;
});
addParseToken(["a", "A"], function(input, array, config) {
  config._isPm = config._locale.isPM(input);
  config._meridiem = input;
});
addParseToken(["h", "hh"], function(input, array, config) {
  array[HOUR] = toInt(input);
  getParsingFlags(config).bigHour = true;
});
addParseToken("hmm", function(input, array, config) {
  var pos = input.length - 2;
  array[HOUR] = toInt(input.substr(0, pos));
  array[MINUTE] = toInt(input.substr(pos));
  getParsingFlags(config).bigHour = true;
});
addParseToken("hmmss", function(input, array, config) {
  var pos1 = input.length - 4, pos2 = input.length - 2;
  array[HOUR] = toInt(input.substr(0, pos1));
  array[MINUTE] = toInt(input.substr(pos1, 2));
  array[SECOND] = toInt(input.substr(pos2));
  getParsingFlags(config).bigHour = true;
});
addParseToken("Hmm", function(input, array, config) {
  var pos = input.length - 2;
  array[HOUR] = toInt(input.substr(0, pos));
  array[MINUTE] = toInt(input.substr(pos));
});
addParseToken("Hmmss", function(input, array, config) {
  var pos1 = input.length - 4, pos2 = input.length - 2;
  array[HOUR] = toInt(input.substr(0, pos1));
  array[MINUTE] = toInt(input.substr(pos1, 2));
  array[SECOND] = toInt(input.substr(pos2));
});
function localeIsPM(input) {
  return (input + "").toLowerCase().charAt(0) === "p";
}
var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
var getSetHour = makeGetSet("Hours", true);
function localeMeridiem(hours2, minutes2, isLower) {
  if (hours2 > 11) {
    return isLower ? "pm" : "PM";
  } else {
    return isLower ? "am" : "AM";
  }
}
var baseConfig = {
  calendar: defaultCalendar,
  longDateFormat: defaultLongDateFormat,
  invalidDate: defaultInvalidDate,
  ordinal: defaultOrdinal,
  dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
  relativeTime: defaultRelativeTime,
  months: defaultLocaleMonths,
  monthsShort: defaultLocaleMonthsShort,
  week: defaultLocaleWeek,
  weekdays: defaultLocaleWeekdays,
  weekdaysMin: defaultLocaleWeekdaysMin,
  weekdaysShort: defaultLocaleWeekdaysShort,
  meridiemParse: defaultLocaleMeridiemParse
};
var locales = {};
var localeFamilies = {};
var globalLocale;
function commonPrefix(arr1, arr2) {
  var i, minl = Math.min(arr1.length, arr2.length);
  for (i = 0; i < minl; i += 1) {
    if (arr1[i] !== arr2[i]) {
      return i;
    }
  }
  return minl;
}
function normalizeLocale(key) {
  return key ? key.toLowerCase().replace("_", "-") : key;
}
function chooseLocale(names) {
  var i = 0, j, next, locale2, split2;
  while (i < names.length) {
    split2 = normalizeLocale(names[i]).split("-");
    j = split2.length;
    next = normalizeLocale(names[i + 1]);
    next = next ? next.split("-") : null;
    while (j > 0) {
      locale2 = loadLocale(split2.slice(0, j).join("-"));
      if (locale2) {
        return locale2;
      }
      if (next && next.length >= j && commonPrefix(split2, next) >= j - 1) {
        break;
      }
      j--;
    }
    i++;
  }
  return globalLocale;
}
function isLocaleNameSane(name) {
  return name.match("^[^/\\\\]*$") != null;
}
function loadLocale(name) {
  var oldLocale = null, aliasedRequire;
  if (locales[name] === void 0 && typeof module !== "undefined" && module && module.exports && isLocaleNameSane(name)) {
    try {
      oldLocale = globalLocale._abbr;
      aliasedRequire = __require;
      aliasedRequire("./locale/" + name);
      getSetGlobalLocale(oldLocale);
    } catch (e) {
      locales[name] = null;
    }
  }
  return locales[name];
}
function getSetGlobalLocale(key, values) {
  var data;
  if (key) {
    if (isUndefined(values)) {
      data = getLocale(key);
    } else {
      data = defineLocale(key, values);
    }
    if (data) {
      globalLocale = data;
    } else {
      if (typeof console !== "undefined" && console.warn) {
        console.warn(
          "Locale " + key + " not found. Did you forget to load it?"
        );
      }
    }
  }
  return globalLocale._abbr;
}
function defineLocale(name, config) {
  if (config !== null) {
    var locale2, parentConfig = baseConfig;
    config.abbr = name;
    if (locales[name] != null) {
      deprecateSimple(
        "defineLocaleOverride",
        "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
      );
      parentConfig = locales[name]._config;
    } else if (config.parentLocale != null) {
      if (locales[config.parentLocale] != null) {
        parentConfig = locales[config.parentLocale]._config;
      } else {
        locale2 = loadLocale(config.parentLocale);
        if (locale2 != null) {
          parentConfig = locale2._config;
        } else {
          if (!localeFamilies[config.parentLocale]) {
            localeFamilies[config.parentLocale] = [];
          }
          localeFamilies[config.parentLocale].push({
            name,
            config
          });
          return null;
        }
      }
    }
    locales[name] = new Locale(mergeConfigs(parentConfig, config));
    if (localeFamilies[name]) {
      localeFamilies[name].forEach(function(x) {
        defineLocale(x.name, x.config);
      });
    }
    getSetGlobalLocale(name);
    return locales[name];
  } else {
    delete locales[name];
    return null;
  }
}
function updateLocale(name, config) {
  if (config != null) {
    var locale2, tmpLocale, parentConfig = baseConfig;
    if (locales[name] != null && locales[name].parentLocale != null) {
      locales[name].set(mergeConfigs(locales[name]._config, config));
    } else {
      tmpLocale = loadLocale(name);
      if (tmpLocale != null) {
        parentConfig = tmpLocale._config;
      }
      config = mergeConfigs(parentConfig, config);
      if (tmpLocale == null) {
        config.abbr = name;
      }
      locale2 = new Locale(config);
      locale2.parentLocale = locales[name];
      locales[name] = locale2;
    }
    getSetGlobalLocale(name);
  } else {
    if (locales[name] != null) {
      if (locales[name].parentLocale != null) {
        locales[name] = locales[name].parentLocale;
        if (name === getSetGlobalLocale()) {
          getSetGlobalLocale(name);
        }
      } else if (locales[name] != null) {
        delete locales[name];
      }
    }
  }
  return locales[name];
}
function getLocale(key) {
  var locale2;
  if (key && key._locale && key._locale._abbr) {
    key = key._locale._abbr;
  }
  if (!key) {
    return globalLocale;
  }
  if (!isArray(key)) {
    locale2 = loadLocale(key);
    if (locale2) {
      return locale2;
    }
    key = [key];
  }
  return chooseLocale(key);
}
function listLocales() {
  return keys(locales);
}
function checkOverflow(m) {
  var overflow, a = m._a;
  if (a && getParsingFlags(m).overflow === -2) {
    overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
    if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
      overflow = DATE;
    }
    if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
      overflow = WEEK;
    }
    if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
      overflow = WEEKDAY;
    }
    getParsingFlags(m).overflow = overflow;
  }
  return m;
}
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
var isoDates = [
  ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
  ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
  ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
  ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
  ["YYYY-DDD", /\d{4}-\d{3}/],
  ["YYYY-MM", /\d{4}-\d\d/, false],
  ["YYYYYYMMDD", /[+-]\d{10}/],
  ["YYYYMMDD", /\d{8}/],
  ["GGGG[W]WWE", /\d{4}W\d{3}/],
  ["GGGG[W]WW", /\d{4}W\d{2}/, false],
  ["YYYYDDD", /\d{7}/],
  ["YYYYMM", /\d{6}/, false],
  ["YYYY", /\d{4}/, false]
];
var isoTimes = [
  ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
  ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
  ["HH:mm:ss", /\d\d:\d\d:\d\d/],
  ["HH:mm", /\d\d:\d\d/],
  ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
  ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
  ["HHmmss", /\d\d\d\d\d\d/],
  ["HHmm", /\d\d\d\d/],
  ["HH", /\d\d/]
];
var aspNetJsonRegex = /^\/?Date\((-?\d+)/i;
var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;
var obsOffsets = {
  UT: 0,
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function configFromISO(config) {
  var i, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
  if (match) {
    getParsingFlags(config).iso = true;
    for (i = 0, l = isoDatesLen; i < l; i++) {
      if (isoDates[i][1].exec(match[1])) {
        dateFormat = isoDates[i][0];
        allowTime = isoDates[i][2] !== false;
        break;
      }
    }
    if (dateFormat == null) {
      config._isValid = false;
      return;
    }
    if (match[3]) {
      for (i = 0, l = isoTimesLen; i < l; i++) {
        if (isoTimes[i][1].exec(match[3])) {
          timeFormat = (match[2] || " ") + isoTimes[i][0];
          break;
        }
      }
      if (timeFormat == null) {
        config._isValid = false;
        return;
      }
    }
    if (!allowTime && timeFormat != null) {
      config._isValid = false;
      return;
    }
    if (match[4]) {
      if (tzRegex.exec(match[4])) {
        tzFormat = "Z";
      } else {
        config._isValid = false;
        return;
      }
    }
    config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
    configFromStringAndFormat(config);
  } else {
    config._isValid = false;
  }
}
function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  var result = [
    untruncateYear(yearStr),
    defaultLocaleMonthsShort.indexOf(monthStr),
    parseInt(dayStr, 10),
    parseInt(hourStr, 10),
    parseInt(minuteStr, 10)
  ];
  if (secondStr) {
    result.push(parseInt(secondStr, 10));
  }
  return result;
}
function untruncateYear(yearStr) {
  var year = parseInt(yearStr, 10);
  if (year <= 49) {
    return 2e3 + year;
  } else if (year <= 999) {
    return 1900 + year;
  }
  return year;
}
function preprocessRFC2822(s) {
  return s.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function checkWeekday(weekdayStr, parsedInput, config) {
  if (weekdayStr) {
    var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
      parsedInput[0],
      parsedInput[1],
      parsedInput[2]
    ).getDay();
    if (weekdayProvided !== weekdayActual) {
      getParsingFlags(config).weekdayMismatch = true;
      config._isValid = false;
      return false;
    }
  }
  return true;
}
function calculateOffset(obsOffset, militaryOffset, numOffset) {
  if (obsOffset) {
    return obsOffsets[obsOffset];
  } else if (militaryOffset) {
    return 0;
  } else {
    var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;
    return h * 60 + m;
  }
}
function configFromRFC2822(config) {
  var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
  if (match) {
    parsedArray = extractFromRFC2822Strings(
      match[4],
      match[3],
      match[2],
      match[5],
      match[6],
      match[7]
    );
    if (!checkWeekday(match[1], parsedArray, config)) {
      return;
    }
    config._a = parsedArray;
    config._tzm = calculateOffset(match[8], match[9], match[10]);
    config._d = createUTCDate.apply(null, config._a);
    config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    getParsingFlags(config).rfc2822 = true;
  } else {
    config._isValid = false;
  }
}
function configFromString(config) {
  var matched = aspNetJsonRegex.exec(config._i);
  if (matched !== null) {
    config._d = /* @__PURE__ */ new Date(+matched[1]);
    return;
  }
  configFromISO(config);
  if (config._isValid === false) {
    delete config._isValid;
  } else {
    return;
  }
  configFromRFC2822(config);
  if (config._isValid === false) {
    delete config._isValid;
  } else {
    return;
  }
  if (config._strict) {
    config._isValid = false;
  } else {
    hooks.createFromInputFallback(config);
  }
}
hooks.createFromInputFallback = deprecate(
  "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
  function(config) {
    config._d = /* @__PURE__ */ new Date(config._i + (config._useUTC ? " UTC" : ""));
  }
);
function defaults(a, b, c) {
  if (a != null) {
    return a;
  }
  if (b != null) {
    return b;
  }
  return c;
}
function currentDateArray(config) {
  var nowValue = new Date(hooks.now());
  if (config._useUTC) {
    return [
      nowValue.getUTCFullYear(),
      nowValue.getUTCMonth(),
      nowValue.getUTCDate()
    ];
  }
  return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}
function configFromArray(config) {
  var i, date, input = [], currentDate, expectedWeekday, yearToUse;
  if (config._d) {
    return;
  }
  currentDate = currentDateArray(config);
  if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
    dayOfYearFromWeekInfo(config);
  }
  if (config._dayOfYear != null) {
    yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
    if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
      getParsingFlags(config)._overflowDayOfYear = true;
    }
    date = createUTCDate(yearToUse, 0, config._dayOfYear);
    config._a[MONTH] = date.getUTCMonth();
    config._a[DATE] = date.getUTCDate();
  }
  for (i = 0; i < 3 && config._a[i] == null; ++i) {
    config._a[i] = input[i] = currentDate[i];
  }
  for (; i < 7; i++) {
    config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
  }
  if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
    config._nextDay = true;
    config._a[HOUR] = 0;
  }
  config._d = (config._useUTC ? createUTCDate : createDate).apply(
    null,
    input
  );
  expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
  if (config._tzm != null) {
    config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
  }
  if (config._nextDay) {
    config._a[HOUR] = 24;
  }
  if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
    getParsingFlags(config).weekdayMismatch = true;
  }
}
function dayOfYearFromWeekInfo(config) {
  var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
  w = config._w;
  if (w.GG != null || w.W != null || w.E != null) {
    dow = 1;
    doy = 4;
    weekYear = defaults(
      w.GG,
      config._a[YEAR],
      weekOfYear(createLocal(), 1, 4).year
    );
    week = defaults(w.W, 1);
    weekday = defaults(w.E, 1);
    if (weekday < 1 || weekday > 7) {
      weekdayOverflow = true;
    }
  } else {
    dow = config._locale._week.dow;
    doy = config._locale._week.doy;
    curWeek = weekOfYear(createLocal(), dow, doy);
    weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
    week = defaults(w.w, curWeek.week);
    if (w.d != null) {
      weekday = w.d;
      if (weekday < 0 || weekday > 6) {
        weekdayOverflow = true;
      }
    } else if (w.e != null) {
      weekday = w.e + dow;
      if (w.e < 0 || w.e > 6) {
        weekdayOverflow = true;
      }
    } else {
      weekday = dow;
    }
  }
  if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
    getParsingFlags(config)._overflowWeeks = true;
  } else if (weekdayOverflow != null) {
    getParsingFlags(config)._overflowWeekday = true;
  } else {
    temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
    config._a[YEAR] = temp.year;
    config._dayOfYear = temp.dayOfYear;
  }
}
hooks.ISO_8601 = function() {
};
hooks.RFC_2822 = function() {
};
function configFromStringAndFormat(config) {
  if (config._f === hooks.ISO_8601) {
    configFromISO(config);
    return;
  }
  if (config._f === hooks.RFC_2822) {
    configFromRFC2822(config);
    return;
  }
  config._a = [];
  getParsingFlags(config).empty = true;
  var string = "" + config._i, i, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
  tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
  tokenLen = tokens2.length;
  for (i = 0; i < tokenLen; i++) {
    token2 = tokens2[i];
    parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
    if (parsedInput) {
      skipped = string.substr(0, string.indexOf(parsedInput));
      if (skipped.length > 0) {
        getParsingFlags(config).unusedInput.push(skipped);
      }
      string = string.slice(
        string.indexOf(parsedInput) + parsedInput.length
      );
      totalParsedInputLength += parsedInput.length;
    }
    if (formatTokenFunctions[token2]) {
      if (parsedInput) {
        getParsingFlags(config).empty = false;
      } else {
        getParsingFlags(config).unusedTokens.push(token2);
      }
      addTimeToArrayFromToken(token2, parsedInput, config);
    } else if (config._strict && !parsedInput) {
      getParsingFlags(config).unusedTokens.push(token2);
    }
  }
  getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
  if (string.length > 0) {
    getParsingFlags(config).unusedInput.push(string);
  }
  if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
    getParsingFlags(config).bigHour = void 0;
  }
  getParsingFlags(config).parsedDateParts = config._a.slice(0);
  getParsingFlags(config).meridiem = config._meridiem;
  config._a[HOUR] = meridiemFixWrap(
    config._locale,
    config._a[HOUR],
    config._meridiem
  );
  era = getParsingFlags(config).era;
  if (era !== null) {
    config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
  }
  configFromArray(config);
  checkOverflow(config);
}
function meridiemFixWrap(locale2, hour, meridiem2) {
  var isPm;
  if (meridiem2 == null) {
    return hour;
  }
  if (locale2.meridiemHour != null) {
    return locale2.meridiemHour(hour, meridiem2);
  } else if (locale2.isPM != null) {
    isPm = locale2.isPM(meridiem2);
    if (isPm && hour < 12) {
      hour += 12;
    }
    if (!isPm && hour === 12) {
      hour = 0;
    }
    return hour;
  } else {
    return hour;
  }
}
function configFromStringAndArray(config) {
  var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
  if (configfLen === 0) {
    getParsingFlags(config).invalidFormat = true;
    config._d = /* @__PURE__ */ new Date(NaN);
    return;
  }
  for (i = 0; i < configfLen; i++) {
    currentScore = 0;
    validFormatFound = false;
    tempConfig = copyConfig({}, config);
    if (config._useUTC != null) {
      tempConfig._useUTC = config._useUTC;
    }
    tempConfig._f = config._f[i];
    configFromStringAndFormat(tempConfig);
    if (isValid(tempConfig)) {
      validFormatFound = true;
    }
    currentScore += getParsingFlags(tempConfig).charsLeftOver;
    currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
    getParsingFlags(tempConfig).score = currentScore;
    if (!bestFormatIsValid) {
      if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
        if (validFormatFound) {
          bestFormatIsValid = true;
        }
      }
    } else {
      if (currentScore < scoreToBeat) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
      }
    }
  }
  extend(config, bestMoment || tempConfig);
}
function configFromObject(config) {
  if (config._d) {
    return;
  }
  var i = normalizeObjectUnits(config._i), dayOrDate = i.day === void 0 ? i.date : i.day;
  config._a = map(
    [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
    function(obj) {
      return obj && parseInt(obj, 10);
    }
  );
  configFromArray(config);
}
function createFromConfig(config) {
  var res = new Moment(checkOverflow(prepareConfig(config)));
  if (res._nextDay) {
    res.add(1, "d");
    res._nextDay = void 0;
  }
  return res;
}
function prepareConfig(config) {
  var input = config._i, format2 = config._f;
  config._locale = config._locale || getLocale(config._l);
  if (input === null || format2 === void 0 && input === "") {
    return createInvalid({ nullInput: true });
  }
  if (typeof input === "string") {
    config._i = input = config._locale.preparse(input);
  }
  if (isMoment(input)) {
    return new Moment(checkOverflow(input));
  } else if (isDate(input)) {
    config._d = input;
  } else if (isArray(format2)) {
    configFromStringAndArray(config);
  } else if (format2) {
    configFromStringAndFormat(config);
  } else {
    configFromInput(config);
  }
  if (!isValid(config)) {
    config._d = null;
  }
  return config;
}
function configFromInput(config) {
  var input = config._i;
  if (isUndefined(input)) {
    config._d = new Date(hooks.now());
  } else if (isDate(input)) {
    config._d = new Date(input.valueOf());
  } else if (typeof input === "string") {
    configFromString(config);
  } else if (isArray(input)) {
    config._a = map(input.slice(0), function(obj) {
      return parseInt(obj, 10);
    });
    configFromArray(config);
  } else if (isObject(input)) {
    configFromObject(config);
  } else if (isNumber(input)) {
    config._d = new Date(input);
  } else {
    hooks.createFromInputFallback(config);
  }
}
function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
  var c = {};
  if (format2 === true || format2 === false) {
    strict = format2;
    format2 = void 0;
  }
  if (locale2 === true || locale2 === false) {
    strict = locale2;
    locale2 = void 0;
  }
  if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
    input = void 0;
  }
  c._isAMomentObject = true;
  c._useUTC = c._isUTC = isUTC;
  c._l = locale2;
  c._i = input;
  c._f = format2;
  c._strict = strict;
  return createFromConfig(c);
}
function createLocal(input, format2, locale2, strict) {
  return createLocalOrUTC(input, format2, locale2, strict, false);
}
var prototypeMin = deprecate(
  "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var other = createLocal.apply(null, arguments);
    if (this.isValid() && other.isValid()) {
      return other < this ? this : other;
    } else {
      return createInvalid();
    }
  }
);
var prototypeMax = deprecate(
  "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var other = createLocal.apply(null, arguments);
    if (this.isValid() && other.isValid()) {
      return other > this ? this : other;
    } else {
      return createInvalid();
    }
  }
);
function pickBy(fn, moments) {
  var res, i;
  if (moments.length === 1 && isArray(moments[0])) {
    moments = moments[0];
  }
  if (!moments.length) {
    return createLocal();
  }
  res = moments[0];
  for (i = 1; i < moments.length; ++i) {
    if (!moments[i].isValid() || moments[i][fn](res)) {
      res = moments[i];
    }
  }
  return res;
}
function min() {
  var args = [].slice.call(arguments, 0);
  return pickBy("isBefore", args);
}
function max() {
  var args = [].slice.call(arguments, 0);
  return pickBy("isAfter", args);
}
var now = function() {
  return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
};
var ordering = [
  "year",
  "quarter",
  "month",
  "week",
  "day",
  "hour",
  "minute",
  "second",
  "millisecond"
];
function isDurationValid(m) {
  var key, unitHasDecimal = false, i, orderLen = ordering.length;
  for (key in m) {
    if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
      return false;
    }
  }
  for (i = 0; i < orderLen; ++i) {
    if (m[ordering[i]]) {
      if (unitHasDecimal) {
        return false;
      }
      if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
        unitHasDecimal = true;
      }
    }
  }
  return true;
}
function isValid$1() {
  return this._isValid;
}
function createInvalid$1() {
  return createDuration(NaN);
}
function Duration(duration) {
  var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
  this._isValid = isDurationValid(normalizedInput);
  this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
  minutes2 * 6e4 + // 1000 * 60
  hours2 * 1e3 * 60 * 60;
  this._days = +days2 + weeks2 * 7;
  this._months = +months2 + quarters * 3 + years2 * 12;
  this._data = {};
  this._locale = getLocale();
  this._bubble();
}
function isDuration(obj) {
  return obj instanceof Duration;
}
function absRound(number) {
  if (number < 0) {
    return Math.round(-1 * number) * -1;
  } else {
    return Math.round(number);
  }
}
function compareArrays(array1, array2, dontConvert) {
  var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
  for (i = 0; i < len; i++) {
    if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
      diffs++;
    }
  }
  return diffs + lengthDiff;
}
function offset(token2, separator) {
  addFormatToken(token2, 0, 0, function() {
    var offset2 = this.utcOffset(), sign2 = "+";
    if (offset2 < 0) {
      offset2 = -offset2;
      sign2 = "-";
    }
    return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
  });
}
offset("Z", ":");
offset("ZZ", "");
addRegexToken("Z", matchShortOffset);
addRegexToken("ZZ", matchShortOffset);
addParseToken(["Z", "ZZ"], function(input, array, config) {
  config._useUTC = true;
  config._tzm = offsetFromString(matchShortOffset, input);
});
var chunkOffset = /([\+\-]|\d\d)/gi;
function offsetFromString(matcher, string) {
  var matches = (string || "").match(matcher), chunk, parts, minutes2;
  if (matches === null) {
    return null;
  }
  chunk = matches[matches.length - 1] || [];
  parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
  minutes2 = +(parts[1] * 60) + toInt(parts[2]);
  return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
}
function cloneWithOffset(input, model) {
  var res, diff2;
  if (model._isUTC) {
    res = model.clone();
    diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
    res._d.setTime(res._d.valueOf() + diff2);
    hooks.updateOffset(res, false);
    return res;
  } else {
    return createLocal(input).local();
  }
}
function getDateOffset(m) {
  return -Math.round(m._d.getTimezoneOffset());
}
hooks.updateOffset = function() {
};
function getSetOffset(input, keepLocalTime, keepMinutes) {
  var offset2 = this._offset || 0, localAdjust;
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  if (input != null) {
    if (typeof input === "string") {
      input = offsetFromString(matchShortOffset, input);
      if (input === null) {
        return this;
      }
    } else if (Math.abs(input) < 16 && !keepMinutes) {
      input = input * 60;
    }
    if (!this._isUTC && keepLocalTime) {
      localAdjust = getDateOffset(this);
    }
    this._offset = input;
    this._isUTC = true;
    if (localAdjust != null) {
      this.add(localAdjust, "m");
    }
    if (offset2 !== input) {
      if (!keepLocalTime || this._changeInProgress) {
        addSubtract(
          this,
          createDuration(input - offset2, "m"),
          1,
          false
        );
      } else if (!this._changeInProgress) {
        this._changeInProgress = true;
        hooks.updateOffset(this, true);
        this._changeInProgress = null;
      }
    }
    return this;
  } else {
    return this._isUTC ? offset2 : getDateOffset(this);
  }
}
function getSetZone(input, keepLocalTime) {
  if (input != null) {
    if (typeof input !== "string") {
      input = -input;
    }
    this.utcOffset(input, keepLocalTime);
    return this;
  } else {
    return -this.utcOffset();
  }
}
function setOffsetToUTC(keepLocalTime) {
  return this.utcOffset(0, keepLocalTime);
}
function setOffsetToLocal(keepLocalTime) {
  if (this._isUTC) {
    this.utcOffset(0, keepLocalTime);
    this._isUTC = false;
    if (keepLocalTime) {
      this.subtract(getDateOffset(this), "m");
    }
  }
  return this;
}
function setOffsetToParsedOffset() {
  if (this._tzm != null) {
    this.utcOffset(this._tzm, false, true);
  } else if (typeof this._i === "string") {
    var tZone = offsetFromString(matchOffset, this._i);
    if (tZone != null) {
      this.utcOffset(tZone);
    } else {
      this.utcOffset(0, true);
    }
  }
  return this;
}
function hasAlignedHourOffset(input) {
  if (!this.isValid()) {
    return false;
  }
  input = input ? createLocal(input).utcOffset() : 0;
  return (this.utcOffset() - input) % 60 === 0;
}
function isDaylightSavingTime() {
  return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
}
function isDaylightSavingTimeShifted() {
  if (!isUndefined(this._isDSTShifted)) {
    return this._isDSTShifted;
  }
  var c = {}, other;
  copyConfig(c, this);
  c = prepareConfig(c);
  if (c._a) {
    other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
    this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
  } else {
    this._isDSTShifted = false;
  }
  return this._isDSTShifted;
}
function isLocal() {
  return this.isValid() ? !this._isUTC : false;
}
function isUtcOffset() {
  return this.isValid() ? this._isUTC : false;
}
function isUtc() {
  return this.isValid() ? this._isUTC && this._offset === 0 : false;
}
var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/;
var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
function createDuration(input, key) {
  var duration = input, match = null, sign2, ret, diffRes;
  if (isDuration(input)) {
    duration = {
      ms: input._milliseconds,
      d: input._days,
      M: input._months
    };
  } else if (isNumber(input) || !isNaN(+input)) {
    duration = {};
    if (key) {
      duration[key] = +input;
    } else {
      duration.milliseconds = +input;
    }
  } else if (match = aspNetRegex.exec(input)) {
    sign2 = match[1] === "-" ? -1 : 1;
    duration = {
      y: 0,
      d: toInt(match[DATE]) * sign2,
      h: toInt(match[HOUR]) * sign2,
      m: toInt(match[MINUTE]) * sign2,
      s: toInt(match[SECOND]) * sign2,
      ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
      // the millisecond decimal point is included in the match
    };
  } else if (match = isoRegex.exec(input)) {
    sign2 = match[1] === "-" ? -1 : 1;
    duration = {
      y: parseIso(match[2], sign2),
      M: parseIso(match[3], sign2),
      w: parseIso(match[4], sign2),
      d: parseIso(match[5], sign2),
      h: parseIso(match[6], sign2),
      m: parseIso(match[7], sign2),
      s: parseIso(match[8], sign2)
    };
  } else if (duration == null) {
    duration = {};
  } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
    diffRes = momentsDifference(
      createLocal(duration.from),
      createLocal(duration.to)
    );
    duration = {};
    duration.ms = diffRes.milliseconds;
    duration.M = diffRes.months;
  }
  ret = new Duration(duration);
  if (isDuration(input) && hasOwnProp(input, "_locale")) {
    ret._locale = input._locale;
  }
  if (isDuration(input) && hasOwnProp(input, "_isValid")) {
    ret._isValid = input._isValid;
  }
  return ret;
}
createDuration.fn = Duration.prototype;
createDuration.invalid = createInvalid$1;
function parseIso(inp, sign2) {
  var res = inp && parseFloat(inp.replace(",", "."));
  return (isNaN(res) ? 0 : res) * sign2;
}
function positiveMomentsDifference(base, other) {
  var res = {};
  res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
  if (base.clone().add(res.months, "M").isAfter(other)) {
    --res.months;
  }
  res.milliseconds = +other - +base.clone().add(res.months, "M");
  return res;
}
function momentsDifference(base, other) {
  var res;
  if (!(base.isValid() && other.isValid())) {
    return { milliseconds: 0, months: 0 };
  }
  other = cloneWithOffset(other, base);
  if (base.isBefore(other)) {
    res = positiveMomentsDifference(base, other);
  } else {
    res = positiveMomentsDifference(other, base);
    res.milliseconds = -res.milliseconds;
    res.months = -res.months;
  }
  return res;
}
function createAdder(direction, name) {
  return function(val, period) {
    var dur, tmp;
    if (period !== null && !isNaN(+period)) {
      deprecateSimple(
        name,
        "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
      );
      tmp = val;
      val = period;
      period = tmp;
    }
    dur = createDuration(val, period);
    addSubtract(this, dur, direction);
    return this;
  };
}
function addSubtract(mom, duration, isAdding, updateOffset) {
  var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
  if (!mom.isValid()) {
    return;
  }
  updateOffset = updateOffset == null ? true : updateOffset;
  if (months2) {
    setMonth(mom, get(mom, "Month") + months2 * isAdding);
  }
  if (days2) {
    set$1(mom, "Date", get(mom, "Date") + days2 * isAdding);
  }
  if (milliseconds2) {
    mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
  }
  if (updateOffset) {
    hooks.updateOffset(mom, days2 || months2);
  }
}
var add = createAdder(1, "add");
var subtract = createAdder(-1, "subtract");
function isString(input) {
  return typeof input === "string" || input instanceof String;
}
function isMomentInput(input) {
  return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
}
function isMomentInputObject(input) {
  var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
    "years",
    "year",
    "y",
    "months",
    "month",
    "M",
    "days",
    "day",
    "d",
    "dates",
    "date",
    "D",
    "hours",
    "hour",
    "h",
    "minutes",
    "minute",
    "m",
    "seconds",
    "second",
    "s",
    "milliseconds",
    "millisecond",
    "ms"
  ], i, property, propertyLen = properties.length;
  for (i = 0; i < propertyLen; i += 1) {
    property = properties[i];
    propertyTest = propertyTest || hasOwnProp(input, property);
  }
  return objectTest && propertyTest;
}
function isNumberOrStringArray(input) {
  var arrayTest = isArray(input), dataTypeTest = false;
  if (arrayTest) {
    dataTypeTest = input.filter(function(item) {
      return !isNumber(item) && isString(input);
    }).length === 0;
  }
  return arrayTest && dataTypeTest;
}
function isCalendarSpec(input) {
  var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
    "sameDay",
    "nextDay",
    "lastDay",
    "nextWeek",
    "lastWeek",
    "sameElse"
  ], i, property;
  for (i = 0; i < properties.length; i += 1) {
    property = properties[i];
    propertyTest = propertyTest || hasOwnProp(input, property);
  }
  return objectTest && propertyTest;
}
function getCalendarFormat(myMoment, now2) {
  var diff2 = myMoment.diff(now2, "days", true);
  return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
}
function calendar$1(time, formats) {
  if (arguments.length === 1) {
    if (!arguments[0]) {
      time = void 0;
      formats = void 0;
    } else if (isMomentInput(arguments[0])) {
      time = arguments[0];
      formats = void 0;
    } else if (isCalendarSpec(arguments[0])) {
      formats = arguments[0];
      time = void 0;
    }
  }
  var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format2]) ? formats[format2].call(this, now2) : formats[format2]);
  return this.format(
    output || this.localeData().calendar(format2, this, createLocal(now2))
  );
}
function clone() {
  return new Moment(this);
}
function isAfter(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() > localInput.valueOf();
  } else {
    return localInput.valueOf() < this.clone().startOf(units).valueOf();
  }
}
function isBefore(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() < localInput.valueOf();
  } else {
    return this.clone().endOf(units).valueOf() < localInput.valueOf();
  }
}
function isBetween(from2, to2, units, inclusivity) {
  var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
  if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
    return false;
  }
  inclusivity = inclusivity || "()";
  return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
}
function isSame(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input), inputMs;
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() === localInput.valueOf();
  } else {
    inputMs = localInput.valueOf();
    return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
  }
}
function isSameOrAfter(input, units) {
  return this.isSame(input, units) || this.isAfter(input, units);
}
function isSameOrBefore(input, units) {
  return this.isSame(input, units) || this.isBefore(input, units);
}
function diff(input, units, asFloat) {
  var that, zoneDelta, output;
  if (!this.isValid()) {
    return NaN;
  }
  that = cloneWithOffset(input, this);
  if (!that.isValid()) {
    return NaN;
  }
  zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
  units = normalizeUnits(units);
  switch (units) {
    case "year":
      output = monthDiff(this, that) / 12;
      break;
    case "month":
      output = monthDiff(this, that);
      break;
    case "quarter":
      output = monthDiff(this, that) / 3;
      break;
    case "second":
      output = (this - that) / 1e3;
      break;
    case "minute":
      output = (this - that) / 6e4;
      break;
    case "hour":
      output = (this - that) / 36e5;
      break;
    case "day":
      output = (this - that - zoneDelta) / 864e5;
      break;
    case "week":
      output = (this - that - zoneDelta) / 6048e5;
      break;
    default:
      output = this - that;
  }
  return asFloat ? output : absFloor(output);
}
function monthDiff(a, b) {
  if (a.date() < b.date()) {
    return -monthDiff(b, a);
  }
  var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
  if (b - anchor < 0) {
    anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
    adjust = (b - anchor) / (anchor - anchor2);
  } else {
    anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
    adjust = (b - anchor) / (anchor2 - anchor);
  }
  return -(wholeMonthDiff + adjust) || 0;
}
hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
function toString() {
  return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
}
function toISOString(keepOffset) {
  if (!this.isValid()) {
    return null;
  }
  var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
  if (m.year() < 0 || m.year() > 9999) {
    return formatMoment(
      m,
      utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
    );
  }
  if (isFunction(Date.prototype.toISOString)) {
    if (utc) {
      return this.toDate().toISOString();
    } else {
      return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
    }
  }
  return formatMoment(
    m,
    utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
  );
}
function inspect() {
  if (!this.isValid()) {
    return "moment.invalid(/* " + this._i + " */)";
  }
  var func = "moment", zone = "", prefix, year, datetime, suffix;
  if (!this.isLocal()) {
    func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
    zone = "Z";
  }
  prefix = "[" + func + '("]';
  year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
  datetime = "-MM-DD[T]HH:mm:ss.SSS";
  suffix = zone + '[")]';
  return this.format(prefix + year + datetime + suffix);
}
function format(inputString) {
  if (!inputString) {
    inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
  }
  var output = formatMoment(this, inputString);
  return this.localeData().postformat(output);
}
function from(time, withoutSuffix) {
  if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
    return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function fromNow(withoutSuffix) {
  return this.from(createLocal(), withoutSuffix);
}
function to(time, withoutSuffix) {
  if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
    return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function toNow(withoutSuffix) {
  return this.to(createLocal(), withoutSuffix);
}
function locale(key) {
  var newLocaleData;
  if (key === void 0) {
    return this._locale._abbr;
  } else {
    newLocaleData = getLocale(key);
    if (newLocaleData != null) {
      this._locale = newLocaleData;
    }
    return this;
  }
}
var lang = deprecate(
  "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
  function(key) {
    if (key === void 0) {
      return this.localeData();
    } else {
      return this.locale(key);
    }
  }
);
function localeData() {
  return this._locale;
}
var MS_PER_SECOND = 1e3;
var MS_PER_MINUTE = 60 * MS_PER_SECOND;
var MS_PER_HOUR = 60 * MS_PER_MINUTE;
var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
function mod$1(dividend, divisor) {
  return (dividend % divisor + divisor) % divisor;
}
function localStartOfDate(y, m, d) {
  if (y < 100 && y >= 0) {
    return new Date(y + 400, m, d) - MS_PER_400_YEARS;
  } else {
    return new Date(y, m, d).valueOf();
  }
}
function utcStartOfDate(y, m, d) {
  if (y < 100 && y >= 0) {
    return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
  } else {
    return Date.UTC(y, m, d);
  }
}
function startOf(units) {
  var time, startOfDate;
  units = normalizeUnits(units);
  if (units === void 0 || units === "millisecond" || !this.isValid()) {
    return this;
  }
  startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
  switch (units) {
    case "year":
      time = startOfDate(this.year(), 0, 1);
      break;
    case "quarter":
      time = startOfDate(
        this.year(),
        this.month() - this.month() % 3,
        1
      );
      break;
    case "month":
      time = startOfDate(this.year(), this.month(), 1);
      break;
    case "week":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - this.weekday()
      );
      break;
    case "isoWeek":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1)
      );
      break;
    case "day":
    case "date":
      time = startOfDate(this.year(), this.month(), this.date());
      break;
    case "hour":
      time = this._d.valueOf();
      time -= mod$1(
        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
        MS_PER_HOUR
      );
      break;
    case "minute":
      time = this._d.valueOf();
      time -= mod$1(time, MS_PER_MINUTE);
      break;
    case "second":
      time = this._d.valueOf();
      time -= mod$1(time, MS_PER_SECOND);
      break;
  }
  this._d.setTime(time);
  hooks.updateOffset(this, true);
  return this;
}
function endOf(units) {
  var time, startOfDate;
  units = normalizeUnits(units);
  if (units === void 0 || units === "millisecond" || !this.isValid()) {
    return this;
  }
  startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
  switch (units) {
    case "year":
      time = startOfDate(this.year() + 1, 0, 1) - 1;
      break;
    case "quarter":
      time = startOfDate(
        this.year(),
        this.month() - this.month() % 3 + 3,
        1
      ) - 1;
      break;
    case "month":
      time = startOfDate(this.year(), this.month() + 1, 1) - 1;
      break;
    case "week":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - this.weekday() + 7
      ) - 1;
      break;
    case "isoWeek":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1) + 7
      ) - 1;
      break;
    case "day":
    case "date":
      time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
      break;
    case "hour":
      time = this._d.valueOf();
      time += MS_PER_HOUR - mod$1(
        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
        MS_PER_HOUR
      ) - 1;
      break;
    case "minute":
      time = this._d.valueOf();
      time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
      break;
    case "second":
      time = this._d.valueOf();
      time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
      break;
  }
  this._d.setTime(time);
  hooks.updateOffset(this, true);
  return this;
}
function valueOf() {
  return this._d.valueOf() - (this._offset || 0) * 6e4;
}
function unix() {
  return Math.floor(this.valueOf() / 1e3);
}
function toDate() {
  return new Date(this.valueOf());
}
function toArray() {
  var m = this;
  return [
    m.year(),
    m.month(),
    m.date(),
    m.hour(),
    m.minute(),
    m.second(),
    m.millisecond()
  ];
}
function toObject() {
  var m = this;
  return {
    years: m.year(),
    months: m.month(),
    date: m.date(),
    hours: m.hours(),
    minutes: m.minutes(),
    seconds: m.seconds(),
    milliseconds: m.milliseconds()
  };
}
function toJSON() {
  return this.isValid() ? this.toISOString() : null;
}
function isValid$2() {
  return isValid(this);
}
function parsingFlags() {
  return extend({}, getParsingFlags(this));
}
function invalidAt() {
  return getParsingFlags(this).overflow;
}
function creationData() {
  return {
    input: this._i,
    format: this._f,
    locale: this._locale,
    isUTC: this._isUTC,
    strict: this._strict
  };
}
addFormatToken("N", 0, 0, "eraAbbr");
addFormatToken("NN", 0, 0, "eraAbbr");
addFormatToken("NNN", 0, 0, "eraAbbr");
addFormatToken("NNNN", 0, 0, "eraName");
addFormatToken("NNNNN", 0, 0, "eraNarrow");
addFormatToken("y", ["y", 1], "yo", "eraYear");
addFormatToken("y", ["yy", 2], 0, "eraYear");
addFormatToken("y", ["yyy", 3], 0, "eraYear");
addFormatToken("y", ["yyyy", 4], 0, "eraYear");
addRegexToken("N", matchEraAbbr);
addRegexToken("NN", matchEraAbbr);
addRegexToken("NNN", matchEraAbbr);
addRegexToken("NNNN", matchEraName);
addRegexToken("NNNNN", matchEraNarrow);
addParseToken(
  ["N", "NN", "NNN", "NNNN", "NNNNN"],
  function(input, array, config, token2) {
    var era = config._locale.erasParse(input, token2, config._strict);
    if (era) {
      getParsingFlags(config).era = era;
    } else {
      getParsingFlags(config).invalidEra = input;
    }
  }
);
addRegexToken("y", matchUnsigned);
addRegexToken("yy", matchUnsigned);
addRegexToken("yyy", matchUnsigned);
addRegexToken("yyyy", matchUnsigned);
addRegexToken("yo", matchEraYearOrdinal);
addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
addParseToken(["yo"], function(input, array, config, token2) {
  var match;
  if (config._locale._eraYearOrdinalRegex) {
    match = input.match(config._locale._eraYearOrdinalRegex);
  }
  if (config._locale.eraYearOrdinalParse) {
    array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
  } else {
    array[YEAR] = parseInt(input, 10);
  }
});
function localeEras(m, format2) {
  var i, l, date, eras = this._eras || getLocale("en")._eras;
  for (i = 0, l = eras.length; i < l; ++i) {
    switch (typeof eras[i].since) {
      case "string":
        date = hooks(eras[i].since).startOf("day");
        eras[i].since = date.valueOf();
        break;
    }
    switch (typeof eras[i].until) {
      case "undefined":
        eras[i].until = Infinity;
        break;
      case "string":
        date = hooks(eras[i].until).startOf("day").valueOf();
        eras[i].until = date.valueOf();
        break;
    }
  }
  return eras;
}
function localeErasParse(eraName, format2, strict) {
  var i, l, eras = this.eras(), name, abbr, narrow;
  eraName = eraName.toUpperCase();
  for (i = 0, l = eras.length; i < l; ++i) {
    name = eras[i].name.toUpperCase();
    abbr = eras[i].abbr.toUpperCase();
    narrow = eras[i].narrow.toUpperCase();
    if (strict) {
      switch (format2) {
        case "N":
        case "NN":
        case "NNN":
          if (abbr === eraName) {
            return eras[i];
          }
          break;
        case "NNNN":
          if (name === eraName) {
            return eras[i];
          }
          break;
        case "NNNNN":
          if (narrow === eraName) {
            return eras[i];
          }
          break;
      }
    } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
      return eras[i];
    }
  }
}
function localeErasConvertYear(era, year) {
  var dir = era.since <= era.until ? 1 : -1;
  if (year === void 0) {
    return hooks(era.since).year();
  } else {
    return hooks(era.since).year() + (year - era.offset) * dir;
  }
}
function getEraName() {
  var i, l, val, eras = this.localeData().eras();
  for (i = 0, l = eras.length; i < l; ++i) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until) {
      return eras[i].name;
    }
    if (eras[i].until <= val && val <= eras[i].since) {
      return eras[i].name;
    }
  }
  return "";
}
function getEraNarrow() {
  var i, l, val, eras = this.localeData().eras();
  for (i = 0, l = eras.length; i < l; ++i) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until) {
      return eras[i].narrow;
    }
    if (eras[i].until <= val && val <= eras[i].since) {
      return eras[i].narrow;
    }
  }
  return "";
}
function getEraAbbr() {
  var i, l, val, eras = this.localeData().eras();
  for (i = 0, l = eras.length; i < l; ++i) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until) {
      return eras[i].abbr;
    }
    if (eras[i].until <= val && val <= eras[i].since) {
      return eras[i].abbr;
    }
  }
  return "";
}
function getEraYear() {
  var i, l, dir, val, eras = this.localeData().eras();
  for (i = 0, l = eras.length; i < l; ++i) {
    dir = eras[i].since <= eras[i].until ? 1 : -1;
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
      return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
    }
  }
  return this.year();
}
function erasNameRegex(isStrict) {
  if (!hasOwnProp(this, "_erasNameRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasNameRegex : this._erasRegex;
}
function erasAbbrRegex(isStrict) {
  if (!hasOwnProp(this, "_erasAbbrRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasAbbrRegex : this._erasRegex;
}
function erasNarrowRegex(isStrict) {
  if (!hasOwnProp(this, "_erasNarrowRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasNarrowRegex : this._erasRegex;
}
function matchEraAbbr(isStrict, locale2) {
  return locale2.erasAbbrRegex(isStrict);
}
function matchEraName(isStrict, locale2) {
  return locale2.erasNameRegex(isStrict);
}
function matchEraNarrow(isStrict, locale2) {
  return locale2.erasNarrowRegex(isStrict);
}
function matchEraYearOrdinal(isStrict, locale2) {
  return locale2._eraYearOrdinalRegex || matchUnsigned;
}
function computeErasParse() {
  var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, eras = this.eras();
  for (i = 0, l = eras.length; i < l; ++i) {
    namePieces.push(regexEscape(eras[i].name));
    abbrPieces.push(regexEscape(eras[i].abbr));
    narrowPieces.push(regexEscape(eras[i].narrow));
    mixedPieces.push(regexEscape(eras[i].name));
    mixedPieces.push(regexEscape(eras[i].abbr));
    mixedPieces.push(regexEscape(eras[i].narrow));
  }
  this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
  this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
  this._erasNarrowRegex = new RegExp(
    "^(" + narrowPieces.join("|") + ")",
    "i"
  );
}
addFormatToken(0, ["gg", 2], 0, function() {
  return this.weekYear() % 100;
});
addFormatToken(0, ["GG", 2], 0, function() {
  return this.isoWeekYear() % 100;
});
function addWeekYearFormatToken(token2, getter) {
  addFormatToken(0, [token2, token2.length], 0, getter);
}
addWeekYearFormatToken("gggg", "weekYear");
addWeekYearFormatToken("ggggg", "weekYear");
addWeekYearFormatToken("GGGG", "isoWeekYear");
addWeekYearFormatToken("GGGGG", "isoWeekYear");
addUnitAlias("weekYear", "gg");
addUnitAlias("isoWeekYear", "GG");
addUnitPriority("weekYear", 1);
addUnitPriority("isoWeekYear", 1);
addRegexToken("G", matchSigned);
addRegexToken("g", matchSigned);
addRegexToken("GG", match1to2, match2);
addRegexToken("gg", match1to2, match2);
addRegexToken("GGGG", match1to4, match4);
addRegexToken("gggg", match1to4, match4);
addRegexToken("GGGGG", match1to6, match6);
addRegexToken("ggggg", match1to6, match6);
addWeekParseToken(
  ["gggg", "ggggg", "GGGG", "GGGGG"],
  function(input, week, config, token2) {
    week[token2.substr(0, 2)] = toInt(input);
  }
);
addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
  week[token2] = hooks.parseTwoDigitYear(input);
});
function getSetWeekYear(input) {
  return getSetWeekYearHelper.call(
    this,
    input,
    this.week(),
    this.weekday(),
    this.localeData()._week.dow,
    this.localeData()._week.doy
  );
}
function getSetISOWeekYear(input) {
  return getSetWeekYearHelper.call(
    this,
    input,
    this.isoWeek(),
    this.isoWeekday(),
    1,
    4
  );
}
function getISOWeeksInYear() {
  return weeksInYear(this.year(), 1, 4);
}
function getISOWeeksInISOWeekYear() {
  return weeksInYear(this.isoWeekYear(), 1, 4);
}
function getWeeksInYear() {
  var weekInfo = this.localeData()._week;
  return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}
function getWeeksInWeekYear() {
  var weekInfo = this.localeData()._week;
  return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
}
function getSetWeekYearHelper(input, week, weekday, dow, doy) {
  var weeksTarget;
  if (input == null) {
    return weekOfYear(this, dow, doy).year;
  } else {
    weeksTarget = weeksInYear(input, dow, doy);
    if (week > weeksTarget) {
      week = weeksTarget;
    }
    return setWeekAll.call(this, input, week, weekday, dow, doy);
  }
}
function setWeekAll(weekYear, week, weekday, dow, doy) {
  var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
  this.year(date.getUTCFullYear());
  this.month(date.getUTCMonth());
  this.date(date.getUTCDate());
  return this;
}
addFormatToken("Q", 0, "Qo", "quarter");
addUnitAlias("quarter", "Q");
addUnitPriority("quarter", 7);
addRegexToken("Q", match1);
addParseToken("Q", function(input, array) {
  array[MONTH] = (toInt(input) - 1) * 3;
});
function getSetQuarter(input) {
  return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}
addFormatToken("D", ["DD", 2], "Do", "date");
addUnitAlias("date", "D");
addUnitPriority("date", 9);
addRegexToken("D", match1to2);
addRegexToken("DD", match1to2, match2);
addRegexToken("Do", function(isStrict, locale2) {
  return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
});
addParseToken(["D", "DD"], DATE);
addParseToken("Do", function(input, array) {
  array[DATE] = toInt(input.match(match1to2)[0]);
});
var getSetDayOfMonth = makeGetSet("Date", true);
addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
addUnitAlias("dayOfYear", "DDD");
addUnitPriority("dayOfYear", 4);
addRegexToken("DDD", match1to3);
addRegexToken("DDDD", match3);
addParseToken(["DDD", "DDDD"], function(input, array, config) {
  config._dayOfYear = toInt(input);
});
function getSetDayOfYear(input) {
  var dayOfYear = Math.round(
    (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
  ) + 1;
  return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
}
addFormatToken("m", ["mm", 2], 0, "minute");
addUnitAlias("minute", "m");
addUnitPriority("minute", 14);
addRegexToken("m", match1to2);
addRegexToken("mm", match1to2, match2);
addParseToken(["m", "mm"], MINUTE);
var getSetMinute = makeGetSet("Minutes", false);
addFormatToken("s", ["ss", 2], 0, "second");
addUnitAlias("second", "s");
addUnitPriority("second", 15);
addRegexToken("s", match1to2);
addRegexToken("ss", match1to2, match2);
addParseToken(["s", "ss"], SECOND);
var getSetSecond = makeGetSet("Seconds", false);
addFormatToken("S", 0, 0, function() {
  return ~~(this.millisecond() / 100);
});
addFormatToken(0, ["SS", 2], 0, function() {
  return ~~(this.millisecond() / 10);
});
addFormatToken(0, ["SSS", 3], 0, "millisecond");
addFormatToken(0, ["SSSS", 4], 0, function() {
  return this.millisecond() * 10;
});
addFormatToken(0, ["SSSSS", 5], 0, function() {
  return this.millisecond() * 100;
});
addFormatToken(0, ["SSSSSS", 6], 0, function() {
  return this.millisecond() * 1e3;
});
addFormatToken(0, ["SSSSSSS", 7], 0, function() {
  return this.millisecond() * 1e4;
});
addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
  return this.millisecond() * 1e5;
});
addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
  return this.millisecond() * 1e6;
});
addUnitAlias("millisecond", "ms");
addUnitPriority("millisecond", 16);
addRegexToken("S", match1to3, match1);
addRegexToken("SS", match1to3, match2);
addRegexToken("SSS", match1to3, match3);
var token;
var getSetMillisecond;
for (token = "SSSS"; token.length <= 9; token += "S") {
  addRegexToken(token, matchUnsigned);
}
function parseMs(input, array) {
  array[MILLISECOND] = toInt(("0." + input) * 1e3);
}
for (token = "S"; token.length <= 9; token += "S") {
  addParseToken(token, parseMs);
}
getSetMillisecond = makeGetSet("Milliseconds", false);
addFormatToken("z", 0, 0, "zoneAbbr");
addFormatToken("zz", 0, 0, "zoneName");
function getZoneAbbr() {
  return this._isUTC ? "UTC" : "";
}
function getZoneName() {
  return this._isUTC ? "Coordinated Universal Time" : "";
}
var proto = Moment.prototype;
proto.add = add;
proto.calendar = calendar$1;
proto.clone = clone;
proto.diff = diff;
proto.endOf = endOf;
proto.format = format;
proto.from = from;
proto.fromNow = fromNow;
proto.to = to;
proto.toNow = toNow;
proto.get = stringGet;
proto.invalidAt = invalidAt;
proto.isAfter = isAfter;
proto.isBefore = isBefore;
proto.isBetween = isBetween;
proto.isSame = isSame;
proto.isSameOrAfter = isSameOrAfter;
proto.isSameOrBefore = isSameOrBefore;
proto.isValid = isValid$2;
proto.lang = lang;
proto.locale = locale;
proto.localeData = localeData;
proto.max = prototypeMax;
proto.min = prototypeMin;
proto.parsingFlags = parsingFlags;
proto.set = stringSet;
proto.startOf = startOf;
proto.subtract = subtract;
proto.toArray = toArray;
proto.toObject = toObject;
proto.toDate = toDate;
proto.toISOString = toISOString;
proto.inspect = inspect;
if (typeof Symbol !== "undefined" && Symbol.for != null) {
  proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
    return "Moment<" + this.format() + ">";
  };
}
proto.toJSON = toJSON;
proto.toString = toString;
proto.unix = unix;
proto.valueOf = valueOf;
proto.creationData = creationData;
proto.eraName = getEraName;
proto.eraNarrow = getEraNarrow;
proto.eraAbbr = getEraAbbr;
proto.eraYear = getEraYear;
proto.year = getSetYear;
proto.isLeapYear = getIsLeapYear;
proto.weekYear = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;
proto.quarter = proto.quarters = getSetQuarter;
proto.month = getSetMonth;
proto.daysInMonth = getDaysInMonth;
proto.week = proto.weeks = getSetWeek;
proto.isoWeek = proto.isoWeeks = getSetISOWeek;
proto.weeksInYear = getWeeksInYear;
proto.weeksInWeekYear = getWeeksInWeekYear;
proto.isoWeeksInYear = getISOWeeksInYear;
proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
proto.date = getSetDayOfMonth;
proto.day = proto.days = getSetDayOfWeek;
proto.weekday = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear = getSetDayOfYear;
proto.hour = proto.hours = getSetHour;
proto.minute = proto.minutes = getSetMinute;
proto.second = proto.seconds = getSetSecond;
proto.millisecond = proto.milliseconds = getSetMillisecond;
proto.utcOffset = getSetOffset;
proto.utc = setOffsetToUTC;
proto.local = setOffsetToLocal;
proto.parseZone = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST = isDaylightSavingTime;
proto.isLocal = isLocal;
proto.isUtcOffset = isUtcOffset;
proto.isUtc = isUtc;
proto.isUTC = isUtc;
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;
proto.dates = deprecate(
  "dates accessor is deprecated. Use date instead.",
  getSetDayOfMonth
);
proto.months = deprecate(
  "months accessor is deprecated. Use month instead",
  getSetMonth
);
proto.years = deprecate(
  "years accessor is deprecated. Use year instead",
  getSetYear
);
proto.zone = deprecate(
  "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
  getSetZone
);
proto.isDSTShifted = deprecate(
  "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
  isDaylightSavingTimeShifted
);
function createUnix(input) {
  return createLocal(input * 1e3);
}
function createInZone() {
  return createLocal.apply(null, arguments).parseZone();
}
function preParsePostFormat(string) {
  return string;
}
var proto$1 = Locale.prototype;
proto$1.calendar = calendar;
proto$1.longDateFormat = longDateFormat;
proto$1.invalidDate = invalidDate;
proto$1.ordinal = ordinal;
proto$1.preparse = preParsePostFormat;
proto$1.postformat = preParsePostFormat;
proto$1.relativeTime = relativeTime;
proto$1.pastFuture = pastFuture;
proto$1.set = set;
proto$1.eras = localeEras;
proto$1.erasParse = localeErasParse;
proto$1.erasConvertYear = localeErasConvertYear;
proto$1.erasAbbrRegex = erasAbbrRegex;
proto$1.erasNameRegex = erasNameRegex;
proto$1.erasNarrowRegex = erasNarrowRegex;
proto$1.months = localeMonths;
proto$1.monthsShort = localeMonthsShort;
proto$1.monthsParse = localeMonthsParse;
proto$1.monthsRegex = monthsRegex;
proto$1.monthsShortRegex = monthsShortRegex;
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;
proto$1.weekdays = localeWeekdays;
proto$1.weekdaysMin = localeWeekdaysMin;
proto$1.weekdaysShort = localeWeekdaysShort;
proto$1.weekdaysParse = localeWeekdaysParse;
proto$1.weekdaysRegex = weekdaysRegex;
proto$1.weekdaysShortRegex = weekdaysShortRegex;
proto$1.weekdaysMinRegex = weekdaysMinRegex;
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;
function get$1(format2, index, field, setter) {
  var locale2 = getLocale(), utc = createUTC().set(setter, index);
  return locale2[field](utc, format2);
}
function listMonthsImpl(format2, index, field) {
  if (isNumber(format2)) {
    index = format2;
    format2 = void 0;
  }
  format2 = format2 || "";
  if (index != null) {
    return get$1(format2, index, field, "month");
  }
  var i, out = [];
  for (i = 0; i < 12; i++) {
    out[i] = get$1(format2, i, field, "month");
  }
  return out;
}
function listWeekdaysImpl(localeSorted, format2, index, field) {
  if (typeof localeSorted === "boolean") {
    if (isNumber(format2)) {
      index = format2;
      format2 = void 0;
    }
    format2 = format2 || "";
  } else {
    format2 = localeSorted;
    index = format2;
    localeSorted = false;
    if (isNumber(format2)) {
      index = format2;
      format2 = void 0;
    }
    format2 = format2 || "";
  }
  var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
  if (index != null) {
    return get$1(format2, (index + shift) % 7, field, "day");
  }
  for (i = 0; i < 7; i++) {
    out[i] = get$1(format2, (i + shift) % 7, field, "day");
  }
  return out;
}
function listMonths(format2, index) {
  return listMonthsImpl(format2, index, "months");
}
function listMonthsShort(format2, index) {
  return listMonthsImpl(format2, index, "monthsShort");
}
function listWeekdays(localeSorted, format2, index) {
  return listWeekdaysImpl(localeSorted, format2, index, "weekdays");
}
function listWeekdaysShort(localeSorted, format2, index) {
  return listWeekdaysImpl(localeSorted, format2, index, "weekdaysShort");
}
function listWeekdaysMin(localeSorted, format2, index) {
  return listWeekdaysImpl(localeSorted, format2, index, "weekdaysMin");
}
getSetGlobalLocale("en", {
  eras: [
    {
      since: "0001-01-01",
      until: Infinity,
      offset: 1,
      name: "Anno Domini",
      narrow: "AD",
      abbr: "AD"
    },
    {
      since: "0000-12-31",
      until: -Infinity,
      offset: 1,
      name: "Before Christ",
      narrow: "BC",
      abbr: "BC"
    }
  ],
  dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
  ordinal: function(number) {
    var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
    return number + output;
  }
});
hooks.lang = deprecate(
  "moment.lang is deprecated. Use moment.locale instead.",
  getSetGlobalLocale
);
hooks.langData = deprecate(
  "moment.langData is deprecated. Use moment.localeData instead.",
  getLocale
);
var mathAbs = Math.abs;
function abs() {
  var data = this._data;
  this._milliseconds = mathAbs(this._milliseconds);
  this._days = mathAbs(this._days);
  this._months = mathAbs(this._months);
  data.milliseconds = mathAbs(data.milliseconds);
  data.seconds = mathAbs(data.seconds);
  data.minutes = mathAbs(data.minutes);
  data.hours = mathAbs(data.hours);
  data.months = mathAbs(data.months);
  data.years = mathAbs(data.years);
  return this;
}
function addSubtract$1(duration, input, value, direction) {
  var other = createDuration(input, value);
  duration._milliseconds += direction * other._milliseconds;
  duration._days += direction * other._days;
  duration._months += direction * other._months;
  return duration._bubble();
}
function add$1(input, value) {
  return addSubtract$1(this, input, value, 1);
}
function subtract$1(input, value) {
  return addSubtract$1(this, input, value, -1);
}
function absCeil(number) {
  if (number < 0) {
    return Math.floor(number);
  } else {
    return Math.ceil(number);
  }
}
function bubble() {
  var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
  if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
    milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
    days2 = 0;
    months2 = 0;
  }
  data.milliseconds = milliseconds2 % 1e3;
  seconds2 = absFloor(milliseconds2 / 1e3);
  data.seconds = seconds2 % 60;
  minutes2 = absFloor(seconds2 / 60);
  data.minutes = minutes2 % 60;
  hours2 = absFloor(minutes2 / 60);
  data.hours = hours2 % 24;
  days2 += absFloor(hours2 / 24);
  monthsFromDays = absFloor(daysToMonths(days2));
  months2 += monthsFromDays;
  days2 -= absCeil(monthsToDays(monthsFromDays));
  years2 = absFloor(months2 / 12);
  months2 %= 12;
  data.days = days2;
  data.months = months2;
  data.years = years2;
  return this;
}
function daysToMonths(days2) {
  return days2 * 4800 / 146097;
}
function monthsToDays(months2) {
  return months2 * 146097 / 4800;
}
function as(units) {
  if (!this.isValid()) {
    return NaN;
  }
  var days2, months2, milliseconds2 = this._milliseconds;
  units = normalizeUnits(units);
  if (units === "month" || units === "quarter" || units === "year") {
    days2 = this._days + milliseconds2 / 864e5;
    months2 = this._months + daysToMonths(days2);
    switch (units) {
      case "month":
        return months2;
      case "quarter":
        return months2 / 3;
      case "year":
        return months2 / 12;
    }
  } else {
    days2 = this._days + Math.round(monthsToDays(this._months));
    switch (units) {
      case "week":
        return days2 / 7 + milliseconds2 / 6048e5;
      case "day":
        return days2 + milliseconds2 / 864e5;
      case "hour":
        return days2 * 24 + milliseconds2 / 36e5;
      case "minute":
        return days2 * 1440 + milliseconds2 / 6e4;
      case "second":
        return days2 * 86400 + milliseconds2 / 1e3;
      case "millisecond":
        return Math.floor(days2 * 864e5) + milliseconds2;
      default:
        throw new Error("Unknown unit " + units);
    }
  }
}
function valueOf$1() {
  if (!this.isValid()) {
    return NaN;
  }
  return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
}
function makeAs(alias) {
  return function() {
    return this.as(alias);
  };
}
var asMilliseconds = makeAs("ms");
var asSeconds = makeAs("s");
var asMinutes = makeAs("m");
var asHours = makeAs("h");
var asDays = makeAs("d");
var asWeeks = makeAs("w");
var asMonths = makeAs("M");
var asQuarters = makeAs("Q");
var asYears = makeAs("y");
function clone$1() {
  return createDuration(this);
}
function get$2(units) {
  units = normalizeUnits(units);
  return this.isValid() ? this[units + "s"]() : NaN;
}
function makeGetter(name) {
  return function() {
    return this.isValid() ? this._data[name] : NaN;
  };
}
var milliseconds = makeGetter("milliseconds");
var seconds = makeGetter("seconds");
var minutes = makeGetter("minutes");
var hours = makeGetter("hours");
var days = makeGetter("days");
var months = makeGetter("months");
var years = makeGetter("years");
function weeks() {
  return absFloor(this.days() / 7);
}
var round = Math.round;
var thresholds = {
  ss: 44,
  // a few seconds to seconds
  s: 45,
  // seconds to minute
  m: 45,
  // minutes to hour
  h: 22,
  // hours to day
  d: 26,
  // days to month/week
  w: null,
  // weeks to month
  M: 11
  // months to year
};
function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
  return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
}
function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
  var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
  if (thresholds2.w != null) {
    a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
  }
  a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
  a[2] = withoutSuffix;
  a[3] = +posNegDuration > 0;
  a[4] = locale2;
  return substituteTimeAgo.apply(null, a);
}
function getSetRelativeTimeRounding(roundingFunction) {
  if (roundingFunction === void 0) {
    return round;
  }
  if (typeof roundingFunction === "function") {
    round = roundingFunction;
    return true;
  }
  return false;
}
function getSetRelativeTimeThreshold(threshold, limit) {
  if (thresholds[threshold] === void 0) {
    return false;
  }
  if (limit === void 0) {
    return thresholds[threshold];
  }
  thresholds[threshold] = limit;
  if (threshold === "s") {
    thresholds.ss = limit - 1;
  }
  return true;
}
function humanize(argWithSuffix, argThresholds) {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var withSuffix = false, th = thresholds, locale2, output;
  if (typeof argWithSuffix === "object") {
    argThresholds = argWithSuffix;
    argWithSuffix = false;
  }
  if (typeof argWithSuffix === "boolean") {
    withSuffix = argWithSuffix;
  }
  if (typeof argThresholds === "object") {
    th = Object.assign({}, thresholds, argThresholds);
    if (argThresholds.s != null && argThresholds.ss == null) {
      th.ss = argThresholds.s - 1;
    }
  }
  locale2 = this.localeData();
  output = relativeTime$1(this, !withSuffix, th, locale2);
  if (withSuffix) {
    output = locale2.pastFuture(+this, output);
  }
  return locale2.postformat(output);
}
var abs$1 = Math.abs;
function sign(x) {
  return (x > 0) - (x < 0) || +x;
}
function toISOString$1() {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
  if (!total) {
    return "P0D";
  }
  minutes2 = absFloor(seconds2 / 60);
  hours2 = absFloor(minutes2 / 60);
  seconds2 %= 60;
  minutes2 %= 60;
  years2 = absFloor(months2 / 12);
  months2 %= 12;
  s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
  totalSign = total < 0 ? "-" : "";
  ymSign = sign(this._months) !== sign(total) ? "-" : "";
  daysSign = sign(this._days) !== sign(total) ? "-" : "";
  hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
  return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
}
var proto$2 = Duration.prototype;
proto$2.isValid = isValid$1;
proto$2.abs = abs;
proto$2.add = add$1;
proto$2.subtract = subtract$1;
proto$2.as = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds = asSeconds;
proto$2.asMinutes = asMinutes;
proto$2.asHours = asHours;
proto$2.asDays = asDays;
proto$2.asWeeks = asWeeks;
proto$2.asMonths = asMonths;
proto$2.asQuarters = asQuarters;
proto$2.asYears = asYears;
proto$2.valueOf = valueOf$1;
proto$2._bubble = bubble;
proto$2.clone = clone$1;
proto$2.get = get$2;
proto$2.milliseconds = milliseconds;
proto$2.seconds = seconds;
proto$2.minutes = minutes;
proto$2.hours = hours;
proto$2.days = days;
proto$2.weeks = weeks;
proto$2.months = months;
proto$2.years = years;
proto$2.humanize = humanize;
proto$2.toISOString = toISOString$1;
proto$2.toString = toISOString$1;
proto$2.toJSON = toISOString$1;
proto$2.locale = locale;
proto$2.localeData = localeData;
proto$2.toIsoString = deprecate(
  "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
  toISOString$1
);
proto$2.lang = lang;
addFormatToken("X", 0, 0, "unix");
addFormatToken("x", 0, 0, "valueOf");
addRegexToken("x", matchSigned);
addRegexToken("X", matchTimestamp);
addParseToken("X", function(input, array, config) {
  config._d = new Date(parseFloat(input) * 1e3);
});
addParseToken("x", function(input, array, config) {
  config._d = new Date(toInt(input));
});
hooks.version = "2.29.4";
setHookCallback(createLocal);
hooks.fn = proto;
hooks.min = min;
hooks.max = max;
hooks.now = now;
hooks.utc = createUTC;
hooks.unix = createUnix;
hooks.months = listMonths;
hooks.isDate = isDate;
hooks.locale = getSetGlobalLocale;
hooks.invalid = createInvalid;
hooks.duration = createDuration;
hooks.isMoment = isMoment;
hooks.weekdays = listWeekdays;
hooks.parseZone = createInZone;
hooks.localeData = getLocale;
hooks.isDuration = isDuration;
hooks.monthsShort = listMonthsShort;
hooks.weekdaysMin = listWeekdaysMin;
hooks.defineLocale = defineLocale;
hooks.updateLocale = updateLocale;
hooks.locales = listLocales;
hooks.weekdaysShort = listWeekdaysShort;
hooks.normalizeUnits = normalizeUnits;
hooks.relativeTimeRounding = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat = getCalendarFormat;
hooks.prototype = proto;
hooks.HTML5_FMT = {
  DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
  // <input type="datetime-local" />
  DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
  // <input type="datetime-local" step="1" />
  DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
  // <input type="datetime-local" step="0.001" />
  DATE: "YYYY-MM-DD",
  // <input type="date" />
  TIME: "HH:mm",
  // <input type="time" />
  TIME_SECONDS: "HH:mm:ss",
  // <input type="time" step="1" />
  TIME_MS: "HH:mm:ss.SSS",
  // <input type="time" step="0.001" />
  WEEK: "GGGG-[W]WW",
  // <input type="week" />
  MONTH: "YYYY-MM"
  // <input type="month" />
};
var moment_default = hooks;

// node_modules/rrule/dist/esm/weekday.js
var ALL_WEEKDAYS = [
  "MO",
  "TU",
  "WE",
  "TH",
  "FR",
  "SA",
  "SU"
];
var Weekday = (
  /** @class */
  function() {
    function Weekday2(weekday, n) {
      if (n === 0)
        throw new Error("Can't create weekday with n == 0");
      this.weekday = weekday;
      this.n = n;
    }
    Weekday2.fromStr = function(str) {
      return new Weekday2(ALL_WEEKDAYS.indexOf(str));
    };
    Weekday2.prototype.nth = function(n) {
      return this.n === n ? this : new Weekday2(this.weekday, n);
    };
    Weekday2.prototype.equals = function(other) {
      return this.weekday === other.weekday && this.n === other.n;
    };
    Weekday2.prototype.toString = function() {
      var s = ALL_WEEKDAYS[this.weekday];
      if (this.n)
        s = (this.n > 0 ? "+" : "") + String(this.n) + s;
      return s;
    };
    Weekday2.prototype.getJsWeekday = function() {
      return this.weekday === 6 ? 0 : this.weekday + 1;
    };
    return Weekday2;
  }()
);

// node_modules/rrule/dist/esm/helpers.js
var isPresent = function(value) {
  return value !== null && value !== void 0;
};
var isNumber2 = function(value) {
  return typeof value === "number";
};
var isWeekdayStr = function(value) {
  return typeof value === "string" && ALL_WEEKDAYS.includes(value);
};
var isArray2 = Array.isArray;
var range = function(start, end) {
  if (end === void 0) {
    end = start;
  }
  if (arguments.length === 1) {
    end = start;
    start = 0;
  }
  var rang = [];
  for (var i = start; i < end; i++)
    rang.push(i);
  return rang;
};
var repeat = function(value, times) {
  var i = 0;
  var array = [];
  if (isArray2(value)) {
    for (; i < times; i++)
      array[i] = [].concat(value);
  } else {
    for (; i < times; i++)
      array[i] = value;
  }
  return array;
};
var toArray2 = function(item) {
  if (isArray2(item)) {
    return item;
  }
  return [item];
};
function padStart(item, targetLength, padString) {
  if (padString === void 0) {
    padString = " ";
  }
  var str = String(item);
  targetLength = targetLength >> 0;
  if (str.length > targetLength) {
    return String(str);
  }
  targetLength = targetLength - str.length;
  if (targetLength > padString.length) {
    padString += repeat(padString, targetLength / padString.length);
  }
  return padString.slice(0, targetLength) + String(str);
}
var split = function(str, sep, num) {
  var splits = str.split(sep);
  return num ? splits.slice(0, num).concat([splits.slice(num).join(sep)]) : splits;
};
var pymod = function(a, b) {
  var r = a % b;
  return r * b < 0 ? r + b : r;
};
var divmod = function(a, b) {
  return { div: Math.floor(a / b), mod: pymod(a, b) };
};
var empty = function(obj) {
  return !isPresent(obj) || obj.length === 0;
};
var notEmpty = function(obj) {
  return !empty(obj);
};
var includes = function(arr, val) {
  return notEmpty(arr) && arr.indexOf(val) !== -1;
};

// node_modules/rrule/dist/esm/dateutil.js
var dateutil;
(function(dateutil2) {
  dateutil2.MONTH_DAYS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  dateutil2.ONE_DAY = 1e3 * 60 * 60 * 24;
  dateutil2.MAXYEAR = 9999;
  dateutil2.ORDINAL_BASE = new Date(Date.UTC(1970, 0, 1));
  dateutil2.PY_WEEKDAYS = [6, 0, 1, 2, 3, 4, 5];
  dateutil2.getYearDay = function(date) {
    var dateNoTime = new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
    return Math.ceil((dateNoTime.valueOf() - new Date(date.getUTCFullYear(), 0, 1).valueOf()) / dateutil2.ONE_DAY) + 1;
  };
  dateutil2.isLeapYear = function(year) {
    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
  };
  dateutil2.isDate = function(value) {
    return value instanceof Date;
  };
  dateutil2.isValidDate = function(value) {
    return dateutil2.isDate(value) && !isNaN(value.getTime());
  };
  dateutil2.tzOffset = function(date) {
    return date.getTimezoneOffset() * 60 * 1e3;
  };
  dateutil2.daysBetween = function(date1, date2) {
    var date1ms = date1.getTime() - dateutil2.tzOffset(date1);
    var date2ms = date2.getTime() - dateutil2.tzOffset(date2);
    var differencems = date1ms - date2ms;
    return Math.round(differencems / dateutil2.ONE_DAY);
  };
  dateutil2.toOrdinal = function(date) {
    return dateutil2.daysBetween(date, dateutil2.ORDINAL_BASE);
  };
  dateutil2.fromOrdinal = function(ordinal2) {
    return new Date(dateutil2.ORDINAL_BASE.getTime() + ordinal2 * dateutil2.ONE_DAY);
  };
  dateutil2.getMonthDays = function(date) {
    var month = date.getUTCMonth();
    return month === 1 && dateutil2.isLeapYear(date.getUTCFullYear()) ? 29 : dateutil2.MONTH_DAYS[month];
  };
  dateutil2.getWeekday = function(date) {
    return dateutil2.PY_WEEKDAYS[date.getUTCDay()];
  };
  dateutil2.monthRange = function(year, month) {
    var date = new Date(Date.UTC(year, month, 1));
    return [dateutil2.getWeekday(date), dateutil2.getMonthDays(date)];
  };
  dateutil2.combine = function(date, time) {
    time = time || date;
    return new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds()));
  };
  dateutil2.clone = function(date) {
    var dolly = new Date(date.getTime());
    return dolly;
  };
  dateutil2.cloneDates = function(dates) {
    var clones = [];
    for (var i = 0; i < dates.length; i++) {
      clones.push(dateutil2.clone(dates[i]));
    }
    return clones;
  };
  dateutil2.sort = function(dates) {
    dates.sort(function(a, b) {
      return a.getTime() - b.getTime();
    });
  };
  dateutil2.timeToUntilString = function(time, utc) {
    if (utc === void 0) {
      utc = true;
    }
    var date = new Date(time);
    return [
      padStart(date.getUTCFullYear().toString(), 4, "0"),
      padStart(date.getUTCMonth() + 1, 2, "0"),
      padStart(date.getUTCDate(), 2, "0"),
      "T",
      padStart(date.getUTCHours(), 2, "0"),
      padStart(date.getUTCMinutes(), 2, "0"),
      padStart(date.getUTCSeconds(), 2, "0"),
      utc ? "Z" : ""
    ].join("");
  };
  dateutil2.untilStringToDate = function(until) {
    var re = /^(\d{4})(\d{2})(\d{2})(T(\d{2})(\d{2})(\d{2})Z?)?$/;
    var bits = re.exec(until);
    if (!bits)
      throw new Error("Invalid UNTIL value: ".concat(until));
    return new Date(Date.UTC(parseInt(bits[1], 10), parseInt(bits[2], 10) - 1, parseInt(bits[3], 10), parseInt(bits[5], 10) || 0, parseInt(bits[6], 10) || 0, parseInt(bits[7], 10) || 0));
  };
})(dateutil || (dateutil = {}));
var dateutil_default = dateutil;

// node_modules/rrule/dist/esm/iterresult.js
var IterResult = (
  /** @class */
  function() {
    function IterResult2(method, args) {
      this.minDate = null;
      this.maxDate = null;
      this._result = [];
      this.total = 0;
      this.method = method;
      this.args = args;
      if (method === "between") {
        this.maxDate = args.inc ? args.before : new Date(args.before.getTime() - 1);
        this.minDate = args.inc ? args.after : new Date(args.after.getTime() + 1);
      } else if (method === "before") {
        this.maxDate = args.inc ? args.dt : new Date(args.dt.getTime() - 1);
      } else if (method === "after") {
        this.minDate = args.inc ? args.dt : new Date(args.dt.getTime() + 1);
      }
    }
    IterResult2.prototype.accept = function(date) {
      ++this.total;
      var tooEarly = this.minDate && date < this.minDate;
      var tooLate = this.maxDate && date > this.maxDate;
      if (this.method === "between") {
        if (tooEarly)
          return true;
        if (tooLate)
          return false;
      } else if (this.method === "before") {
        if (tooLate)
          return false;
      } else if (this.method === "after") {
        if (tooEarly)
          return true;
        this.add(date);
        return false;
      }
      return this.add(date);
    };
    IterResult2.prototype.add = function(date) {
      this._result.push(date);
      return true;
    };
    IterResult2.prototype.getValue = function() {
      var res = this._result;
      switch (this.method) {
        case "all":
        case "between":
          return res;
        case "before":
        case "after":
        default:
          return res.length ? res[res.length - 1] : null;
      }
    };
    IterResult2.prototype.clone = function() {
      return new IterResult2(this.method, this.args);
    };
    return IterResult2;
  }()
);
var iterresult_default = IterResult;

// node_modules/tslib/tslib.es6.mjs
var extendStatics2 = function(d, b) {
  extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics2(d, b);
};
function __extends2(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics2(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign2 = function() {
  __assign2 = Object.assign || function __assign5(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
function __spreadArray3(to2, from2, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from2.length, ar; i < l; i++) {
      if (ar || !(i in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i);
        ar[i] = from2[i];
      }
    }
  return to2.concat(ar || Array.prototype.slice.call(from2));
}

// node_modules/rrule/dist/esm/callbackiterresult.js
var CallbackIterResult = (
  /** @class */
  function(_super) {
    __extends2(CallbackIterResult2, _super);
    function CallbackIterResult2(method, args, iterator) {
      var _this = _super.call(this, method, args) || this;
      _this.iterator = iterator;
      return _this;
    }
    CallbackIterResult2.prototype.add = function(date) {
      if (this.iterator(date, this._result.length)) {
        this._result.push(date);
        return true;
      }
      return false;
    };
    return CallbackIterResult2;
  }(iterresult_default)
);
var callbackiterresult_default = CallbackIterResult;

// node_modules/rrule/dist/esm/nlp/i18n.js
var ENGLISH = {
  dayNames: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ],
  monthNames: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ],
  tokens: {
    SKIP: /^[ \r\n\t]+|^\.$/,
    number: /^[1-9][0-9]*/,
    numberAsText: /^(one|two|three)/i,
    every: /^every/i,
    "day(s)": /^days?/i,
    "weekday(s)": /^weekdays?/i,
    "week(s)": /^weeks?/i,
    "hour(s)": /^hours?/i,
    "minute(s)": /^minutes?/i,
    "month(s)": /^months?/i,
    "year(s)": /^years?/i,
    on: /^(on|in)/i,
    at: /^(at)/i,
    the: /^the/i,
    first: /^first/i,
    second: /^second/i,
    third: /^third/i,
    nth: /^([1-9][0-9]*)(\.|th|nd|rd|st)/i,
    last: /^last/i,
    for: /^for/i,
    "time(s)": /^times?/i,
    until: /^(un)?til/i,
    monday: /^mo(n(day)?)?/i,
    tuesday: /^tu(e(s(day)?)?)?/i,
    wednesday: /^we(d(n(esday)?)?)?/i,
    thursday: /^th(u(r(sday)?)?)?/i,
    friday: /^fr(i(day)?)?/i,
    saturday: /^sa(t(urday)?)?/i,
    sunday: /^su(n(day)?)?/i,
    january: /^jan(uary)?/i,
    february: /^feb(ruary)?/i,
    march: /^mar(ch)?/i,
    april: /^apr(il)?/i,
    may: /^may/i,
    june: /^june?/i,
    july: /^july?/i,
    august: /^aug(ust)?/i,
    september: /^sep(t(ember)?)?/i,
    october: /^oct(ober)?/i,
    november: /^nov(ember)?/i,
    december: /^dec(ember)?/i,
    comma: /^(,\s*|(and|or)\s*)+/i
  }
};
var i18n_default = ENGLISH;

// node_modules/rrule/dist/esm/nlp/totext.js
var contains = function(arr, val) {
  return arr.indexOf(val) !== -1;
};
var defaultGetText = function(id) {
  return id.toString();
};
var defaultDateFormatter = function(year, month, day) {
  return "".concat(month, " ").concat(day, ", ").concat(year);
};
var ToText = (
  /** @class */
  function() {
    function ToText2(rrule, gettext, language, dateFormatter) {
      if (gettext === void 0) {
        gettext = defaultGetText;
      }
      if (language === void 0) {
        language = i18n_default;
      }
      if (dateFormatter === void 0) {
        dateFormatter = defaultDateFormatter;
      }
      this.text = [];
      this.language = language || i18n_default;
      this.gettext = gettext;
      this.dateFormatter = dateFormatter;
      this.rrule = rrule;
      this.options = rrule.options;
      this.origOptions = rrule.origOptions;
      if (this.origOptions.bymonthday) {
        var bymonthday = [].concat(this.options.bymonthday);
        var bynmonthday = [].concat(this.options.bynmonthday);
        bymonthday.sort(function(a, b) {
          return a - b;
        });
        bynmonthday.sort(function(a, b) {
          return b - a;
        });
        this.bymonthday = bymonthday.concat(bynmonthday);
        if (!this.bymonthday.length)
          this.bymonthday = null;
      }
      if (isPresent(this.origOptions.byweekday)) {
        var byweekday = !isArray2(this.origOptions.byweekday) ? [this.origOptions.byweekday] : this.origOptions.byweekday;
        var days2 = String(byweekday);
        this.byweekday = {
          allWeeks: byweekday.filter(function(weekday) {
            return !weekday.n;
          }),
          someWeeks: byweekday.filter(function(weekday) {
            return Boolean(weekday.n);
          }),
          isWeekdays: days2.indexOf("MO") !== -1 && days2.indexOf("TU") !== -1 && days2.indexOf("WE") !== -1 && days2.indexOf("TH") !== -1 && days2.indexOf("FR") !== -1 && days2.indexOf("SA") === -1 && days2.indexOf("SU") === -1,
          isEveryDay: days2.indexOf("MO") !== -1 && days2.indexOf("TU") !== -1 && days2.indexOf("WE") !== -1 && days2.indexOf("TH") !== -1 && days2.indexOf("FR") !== -1 && days2.indexOf("SA") !== -1 && days2.indexOf("SU") !== -1
        };
        var sortWeekDays = function(a, b) {
          return a.weekday - b.weekday;
        };
        this.byweekday.allWeeks.sort(sortWeekDays);
        this.byweekday.someWeeks.sort(sortWeekDays);
        if (!this.byweekday.allWeeks.length)
          this.byweekday.allWeeks = null;
        if (!this.byweekday.someWeeks.length)
          this.byweekday.someWeeks = null;
      } else {
        this.byweekday = null;
      }
    }
    ToText2.isFullyConvertible = function(rrule) {
      var canConvert = true;
      if (!(rrule.options.freq in ToText2.IMPLEMENTED))
        return false;
      if (rrule.origOptions.until && rrule.origOptions.count)
        return false;
      for (var key in rrule.origOptions) {
        if (contains(["dtstart", "wkst", "freq"], key))
          return true;
        if (!contains(ToText2.IMPLEMENTED[rrule.options.freq], key))
          return false;
      }
      return canConvert;
    };
    ToText2.prototype.isFullyConvertible = function() {
      return ToText2.isFullyConvertible(this.rrule);
    };
    ToText2.prototype.toString = function() {
      var gettext = this.gettext;
      if (!(this.options.freq in ToText2.IMPLEMENTED)) {
        return gettext("RRule error: Unable to fully convert this rrule to text");
      }
      this.text = [gettext("every")];
      this[RRule.FREQUENCIES[this.options.freq]]();
      if (this.options.until) {
        this.add(gettext("until"));
        var until = this.options.until;
        this.add(this.dateFormatter(until.getUTCFullYear(), this.language.monthNames[until.getUTCMonth()], until.getUTCDate()));
      } else if (this.options.count) {
        this.add(gettext("for")).add(this.options.count.toString()).add(this.plural(this.options.count) ? gettext("times") : gettext("time"));
      }
      if (!this.isFullyConvertible())
        this.add(gettext("(~ approximate)"));
      return this.text.join("");
    };
    ToText2.prototype.HOURLY = function() {
      var gettext = this.gettext;
      if (this.options.interval !== 1)
        this.add(this.options.interval.toString());
      this.add(this.plural(this.options.interval) ? gettext("hours") : gettext("hour"));
    };
    ToText2.prototype.MINUTELY = function() {
      var gettext = this.gettext;
      if (this.options.interval !== 1)
        this.add(this.options.interval.toString());
      this.add(this.plural(this.options.interval) ? gettext("minutes") : gettext("minute"));
    };
    ToText2.prototype.DAILY = function() {
      var gettext = this.gettext;
      if (this.options.interval !== 1)
        this.add(this.options.interval.toString());
      if (this.byweekday && this.byweekday.isWeekdays) {
        this.add(this.plural(this.options.interval) ? gettext("weekdays") : gettext("weekday"));
      } else {
        this.add(this.plural(this.options.interval) ? gettext("days") : gettext("day"));
      }
      if (this.origOptions.bymonth) {
        this.add(gettext("in"));
        this._bymonth();
      }
      if (this.bymonthday) {
        this._bymonthday();
      } else if (this.byweekday) {
        this._byweekday();
      } else if (this.origOptions.byhour) {
        this._byhour();
      }
    };
    ToText2.prototype.WEEKLY = function() {
      var gettext = this.gettext;
      if (this.options.interval !== 1) {
        this.add(this.options.interval.toString()).add(this.plural(this.options.interval) ? gettext("weeks") : gettext("week"));
      }
      if (this.byweekday && this.byweekday.isWeekdays) {
        if (this.options.interval === 1) {
          this.add(this.plural(this.options.interval) ? gettext("weekdays") : gettext("weekday"));
        } else {
          this.add(gettext("on")).add(gettext("weekdays"));
        }
      } else if (this.byweekday && this.byweekday.isEveryDay) {
        this.add(this.plural(this.options.interval) ? gettext("days") : gettext("day"));
      } else {
        if (this.options.interval === 1)
          this.add(gettext("week"));
        if (this.origOptions.bymonth) {
          this.add(gettext("in"));
          this._bymonth();
        }
        if (this.bymonthday) {
          this._bymonthday();
        } else if (this.byweekday) {
          this._byweekday();
        }
      }
    };
    ToText2.prototype.MONTHLY = function() {
      var gettext = this.gettext;
      if (this.origOptions.bymonth) {
        if (this.options.interval !== 1) {
          this.add(this.options.interval.toString()).add(gettext("months"));
          if (this.plural(this.options.interval))
            this.add(gettext("in"));
        } else {
        }
        this._bymonth();
      } else {
        if (this.options.interval !== 1) {
          this.add(this.options.interval.toString());
        }
        this.add(this.plural(this.options.interval) ? gettext("months") : gettext("month"));
      }
      if (this.bymonthday) {
        this._bymonthday();
      } else if (this.byweekday && this.byweekday.isWeekdays) {
        this.add(gettext("on")).add(gettext("weekdays"));
      } else if (this.byweekday) {
        this._byweekday();
      }
    };
    ToText2.prototype.YEARLY = function() {
      var gettext = this.gettext;
      if (this.origOptions.bymonth) {
        if (this.options.interval !== 1) {
          this.add(this.options.interval.toString());
          this.add(gettext("years"));
        } else {
        }
        this._bymonth();
      } else {
        if (this.options.interval !== 1) {
          this.add(this.options.interval.toString());
        }
        this.add(this.plural(this.options.interval) ? gettext("years") : gettext("year"));
      }
      if (this.bymonthday) {
        this._bymonthday();
      } else if (this.byweekday) {
        this._byweekday();
      }
      if (this.options.byyearday) {
        this.add(gettext("on the")).add(this.list(this.options.byyearday, this.nth, gettext("and"))).add(gettext("day"));
      }
      if (this.options.byweekno) {
        this.add(gettext("in")).add(this.plural(this.options.byweekno.length) ? gettext("weeks") : gettext("week")).add(this.list(this.options.byweekno, void 0, gettext("and")));
      }
    };
    ToText2.prototype._bymonthday = function() {
      var gettext = this.gettext;
      if (this.byweekday && this.byweekday.allWeeks) {
        this.add(gettext("on")).add(this.list(this.byweekday.allWeeks, this.weekdaytext, gettext("or"))).add(gettext("the")).add(this.list(this.bymonthday, this.nth, gettext("or")));
      } else {
        this.add(gettext("on the")).add(this.list(this.bymonthday, this.nth, gettext("and")));
      }
    };
    ToText2.prototype._byweekday = function() {
      var gettext = this.gettext;
      if (this.byweekday.allWeeks && !this.byweekday.isWeekdays) {
        this.add(gettext("on")).add(this.list(this.byweekday.allWeeks, this.weekdaytext));
      }
      if (this.byweekday.someWeeks) {
        if (this.byweekday.allWeeks)
          this.add(gettext("and"));
        this.add(gettext("on the")).add(this.list(this.byweekday.someWeeks, this.weekdaytext, gettext("and")));
      }
    };
    ToText2.prototype._byhour = function() {
      var gettext = this.gettext;
      this.add(gettext("at")).add(this.list(this.origOptions.byhour, void 0, gettext("and")));
    };
    ToText2.prototype._bymonth = function() {
      this.add(this.list(this.options.bymonth, this.monthtext, this.gettext("and")));
    };
    ToText2.prototype.nth = function(n) {
      n = parseInt(n.toString(), 10);
      var nth;
      var gettext = this.gettext;
      if (n === -1)
        return gettext("last");
      var npos = Math.abs(n);
      switch (npos) {
        case 1:
        case 21:
        case 31:
          nth = npos + gettext("st");
          break;
        case 2:
        case 22:
          nth = npos + gettext("nd");
          break;
        case 3:
        case 23:
          nth = npos + gettext("rd");
          break;
        default:
          nth = npos + gettext("th");
      }
      return n < 0 ? nth + " " + gettext("last") : nth;
    };
    ToText2.prototype.monthtext = function(m) {
      return this.language.monthNames[m - 1];
    };
    ToText2.prototype.weekdaytext = function(wday) {
      var weekday = isNumber2(wday) ? (wday + 1) % 7 : wday.getJsWeekday();
      return (wday.n ? this.nth(wday.n) + " " : "") + this.language.dayNames[weekday];
    };
    ToText2.prototype.plural = function(n) {
      return n % 100 !== 1;
    };
    ToText2.prototype.add = function(s) {
      this.text.push(" ");
      this.text.push(s);
      return this;
    };
    ToText2.prototype.list = function(arr, callback, finalDelim, delim) {
      var _this = this;
      if (delim === void 0) {
        delim = ",";
      }
      if (!isArray2(arr)) {
        arr = [arr];
      }
      var delimJoin = function(array, delimiter, finalDelimiter) {
        var list = "";
        for (var i = 0; i < array.length; i++) {
          if (i !== 0) {
            if (i === array.length - 1) {
              list += " " + finalDelimiter + " ";
            } else {
              list += delimiter + " ";
            }
          }
          list += array[i];
        }
        return list;
      };
      callback = callback || function(o) {
        return o.toString();
      };
      var realCallback = function(arg) {
        return callback && callback.call(_this, arg);
      };
      if (finalDelim) {
        return delimJoin(arr.map(realCallback), delim, finalDelim);
      } else {
        return arr.map(realCallback).join(delim + " ");
      }
    };
    return ToText2;
  }()
);
var totext_default = ToText;

// node_modules/rrule/dist/esm/nlp/parsetext.js
var Parser = (
  /** @class */
  function() {
    function Parser2(rules) {
      this.done = true;
      this.rules = rules;
    }
    Parser2.prototype.start = function(text) {
      this.text = text;
      this.done = false;
      return this.nextSymbol();
    };
    Parser2.prototype.isDone = function() {
      return this.done && this.symbol === null;
    };
    Parser2.prototype.nextSymbol = function() {
      var best;
      var bestSymbol;
      this.symbol = null;
      this.value = null;
      do {
        if (this.done)
          return false;
        var rule = void 0;
        best = null;
        for (var name_1 in this.rules) {
          rule = this.rules[name_1];
          var match = rule.exec(this.text);
          if (match) {
            if (best === null || match[0].length > best[0].length) {
              best = match;
              bestSymbol = name_1;
            }
          }
        }
        if (best != null) {
          this.text = this.text.substr(best[0].length);
          if (this.text === "")
            this.done = true;
        }
        if (best == null) {
          this.done = true;
          this.symbol = null;
          this.value = null;
          return;
        }
      } while (bestSymbol === "SKIP");
      this.symbol = bestSymbol;
      this.value = best;
      return true;
    };
    Parser2.prototype.accept = function(name) {
      if (this.symbol === name) {
        if (this.value) {
          var v = this.value;
          this.nextSymbol();
          return v;
        }
        this.nextSymbol();
        return true;
      }
      return false;
    };
    Parser2.prototype.acceptNumber = function() {
      return this.accept("number");
    };
    Parser2.prototype.expect = function(name) {
      if (this.accept(name))
        return true;
      throw new Error("expected " + name + " but found " + this.symbol);
    };
    return Parser2;
  }()
);
function parseText(text, language) {
  if (language === void 0) {
    language = i18n_default;
  }
  var options = {};
  var ttr = new Parser(language.tokens);
  if (!ttr.start(text))
    return null;
  S();
  return options;
  function S() {
    ttr.expect("every");
    var n = ttr.acceptNumber();
    if (n)
      options.interval = parseInt(n[0], 10);
    if (ttr.isDone())
      throw new Error("Unexpected end");
    switch (ttr.symbol) {
      case "day(s)":
        options.freq = RRule.DAILY;
        if (ttr.nextSymbol()) {
          AT();
          F();
        }
        break;
      case "weekday(s)":
        options.freq = RRule.WEEKLY;
        options.byweekday = [RRule.MO, RRule.TU, RRule.WE, RRule.TH, RRule.FR];
        ttr.nextSymbol();
        F();
        break;
      case "week(s)":
        options.freq = RRule.WEEKLY;
        if (ttr.nextSymbol()) {
          ON();
          F();
        }
        break;
      case "hour(s)":
        options.freq = RRule.HOURLY;
        if (ttr.nextSymbol()) {
          ON();
          F();
        }
        break;
      case "minute(s)":
        options.freq = RRule.MINUTELY;
        if (ttr.nextSymbol()) {
          ON();
          F();
        }
        break;
      case "month(s)":
        options.freq = RRule.MONTHLY;
        if (ttr.nextSymbol()) {
          ON();
          F();
        }
        break;
      case "year(s)":
        options.freq = RRule.YEARLY;
        if (ttr.nextSymbol()) {
          ON();
          F();
        }
        break;
      case "monday":
      case "tuesday":
      case "wednesday":
      case "thursday":
      case "friday":
      case "saturday":
      case "sunday":
        options.freq = RRule.WEEKLY;
        var key = ttr.symbol.substr(0, 2).toUpperCase();
        options.byweekday = [RRule[key]];
        if (!ttr.nextSymbol())
          return;
        while (ttr.accept("comma")) {
          if (ttr.isDone())
            throw new Error("Unexpected end");
          var wkd = decodeWKD();
          if (!wkd) {
            throw new Error("Unexpected symbol " + ttr.symbol + ", expected weekday");
          }
          options.byweekday.push(RRule[wkd]);
          ttr.nextSymbol();
        }
        MDAYs();
        F();
        break;
      case "january":
      case "february":
      case "march":
      case "april":
      case "may":
      case "june":
      case "july":
      case "august":
      case "september":
      case "october":
      case "november":
      case "december":
        options.freq = RRule.YEARLY;
        options.bymonth = [decodeM()];
        if (!ttr.nextSymbol())
          return;
        while (ttr.accept("comma")) {
          if (ttr.isDone())
            throw new Error("Unexpected end");
          var m = decodeM();
          if (!m) {
            throw new Error("Unexpected symbol " + ttr.symbol + ", expected month");
          }
          options.bymonth.push(m);
          ttr.nextSymbol();
        }
        ON();
        F();
        break;
      default:
        throw new Error("Unknown symbol");
    }
  }
  function ON() {
    var on = ttr.accept("on");
    var the = ttr.accept("the");
    if (!(on || the))
      return;
    do {
      var nth = decodeNTH();
      var wkd = decodeWKD();
      var m = decodeM();
      if (nth) {
        if (wkd) {
          ttr.nextSymbol();
          if (!options.byweekday)
            options.byweekday = [];
          options.byweekday.push(RRule[wkd].nth(nth));
        } else {
          if (!options.bymonthday)
            options.bymonthday = [];
          options.bymonthday.push(nth);
          ttr.accept("day(s)");
        }
      } else if (wkd) {
        ttr.nextSymbol();
        if (!options.byweekday)
          options.byweekday = [];
        options.byweekday.push(RRule[wkd]);
      } else if (ttr.symbol === "weekday(s)") {
        ttr.nextSymbol();
        if (!options.byweekday) {
          options.byweekday = [RRule.MO, RRule.TU, RRule.WE, RRule.TH, RRule.FR];
        }
      } else if (ttr.symbol === "week(s)") {
        ttr.nextSymbol();
        var n = ttr.acceptNumber();
        if (!n) {
          throw new Error("Unexpected symbol " + ttr.symbol + ", expected week number");
        }
        options.byweekno = [parseInt(n[0], 10)];
        while (ttr.accept("comma")) {
          n = ttr.acceptNumber();
          if (!n) {
            throw new Error("Unexpected symbol " + ttr.symbol + "; expected monthday");
          }
          options.byweekno.push(parseInt(n[0], 10));
        }
      } else if (m) {
        ttr.nextSymbol();
        if (!options.bymonth)
          options.bymonth = [];
        options.bymonth.push(m);
      } else {
        return;
      }
    } while (ttr.accept("comma") || ttr.accept("the") || ttr.accept("on"));
  }
  function AT() {
    var at = ttr.accept("at");
    if (!at)
      return;
    do {
      var n = ttr.acceptNumber();
      if (!n) {
        throw new Error("Unexpected symbol " + ttr.symbol + ", expected hour");
      }
      options.byhour = [parseInt(n[0], 10)];
      while (ttr.accept("comma")) {
        n = ttr.acceptNumber();
        if (!n) {
          throw new Error("Unexpected symbol " + ttr.symbol + "; expected hour");
        }
        options.byhour.push(parseInt(n[0], 10));
      }
    } while (ttr.accept("comma") || ttr.accept("at"));
  }
  function decodeM() {
    switch (ttr.symbol) {
      case "january":
        return 1;
      case "february":
        return 2;
      case "march":
        return 3;
      case "april":
        return 4;
      case "may":
        return 5;
      case "june":
        return 6;
      case "july":
        return 7;
      case "august":
        return 8;
      case "september":
        return 9;
      case "october":
        return 10;
      case "november":
        return 11;
      case "december":
        return 12;
      default:
        return false;
    }
  }
  function decodeWKD() {
    switch (ttr.symbol) {
      case "monday":
      case "tuesday":
      case "wednesday":
      case "thursday":
      case "friday":
      case "saturday":
      case "sunday":
        return ttr.symbol.substr(0, 2).toUpperCase();
      default:
        return false;
    }
  }
  function decodeNTH() {
    switch (ttr.symbol) {
      case "last":
        ttr.nextSymbol();
        return -1;
      case "first":
        ttr.nextSymbol();
        return 1;
      case "second":
        ttr.nextSymbol();
        return ttr.accept("last") ? -2 : 2;
      case "third":
        ttr.nextSymbol();
        return ttr.accept("last") ? -3 : 3;
      case "nth":
        var v = parseInt(ttr.value[1], 10);
        if (v < -366 || v > 366)
          throw new Error("Nth out of range: " + v);
        ttr.nextSymbol();
        return ttr.accept("last") ? -v : v;
      default:
        return false;
    }
  }
  function MDAYs() {
    ttr.accept("on");
    ttr.accept("the");
    var nth = decodeNTH();
    if (!nth)
      return;
    options.bymonthday = [nth];
    ttr.nextSymbol();
    while (ttr.accept("comma")) {
      nth = decodeNTH();
      if (!nth) {
        throw new Error("Unexpected symbol " + ttr.symbol + "; expected monthday");
      }
      options.bymonthday.push(nth);
      ttr.nextSymbol();
    }
  }
  function F() {
    if (ttr.symbol === "until") {
      var date = Date.parse(ttr.text);
      if (!date)
        throw new Error("Cannot parse until date:" + ttr.text);
      options.until = new Date(date);
    } else if (ttr.accept("for")) {
      options.count = parseInt(ttr.value[0], 10);
      ttr.expect("number");
    }
  }
}

// node_modules/rrule/dist/esm/types.js
var Frequency;
(function(Frequency2) {
  Frequency2[Frequency2["YEARLY"] = 0] = "YEARLY";
  Frequency2[Frequency2["MONTHLY"] = 1] = "MONTHLY";
  Frequency2[Frequency2["WEEKLY"] = 2] = "WEEKLY";
  Frequency2[Frequency2["DAILY"] = 3] = "DAILY";
  Frequency2[Frequency2["HOURLY"] = 4] = "HOURLY";
  Frequency2[Frequency2["MINUTELY"] = 5] = "MINUTELY";
  Frequency2[Frequency2["SECONDLY"] = 6] = "SECONDLY";
})(Frequency || (Frequency = {}));
function freqIsDailyOrGreater(freq) {
  return freq < Frequency.HOURLY;
}

// node_modules/rrule/dist/esm/nlp/index.js
var fromText = function(text, language) {
  if (language === void 0) {
    language = i18n_default;
  }
  return new RRule(parseText(text, language) || void 0);
};
var common = [
  "count",
  "until",
  "interval",
  "byweekday",
  "bymonthday",
  "bymonth"
];
totext_default.IMPLEMENTED = [];
totext_default.IMPLEMENTED[Frequency.HOURLY] = common;
totext_default.IMPLEMENTED[Frequency.MINUTELY] = common;
totext_default.IMPLEMENTED[Frequency.DAILY] = ["byhour"].concat(common);
totext_default.IMPLEMENTED[Frequency.WEEKLY] = common;
totext_default.IMPLEMENTED[Frequency.MONTHLY] = common;
totext_default.IMPLEMENTED[Frequency.YEARLY] = ["byweekno", "byyearday"].concat(common);
var toText = function(rrule, gettext, language, dateFormatter) {
  return new totext_default(rrule, gettext, language, dateFormatter).toString();
};
var isFullyConvertible = totext_default.isFullyConvertible;

// node_modules/rrule/dist/esm/datetime.js
var Time = (
  /** @class */
  function() {
    function Time2(hour, minute, second, millisecond) {
      this.hour = hour;
      this.minute = minute;
      this.second = second;
      this.millisecond = millisecond || 0;
    }
    Time2.prototype.getHours = function() {
      return this.hour;
    };
    Time2.prototype.getMinutes = function() {
      return this.minute;
    };
    Time2.prototype.getSeconds = function() {
      return this.second;
    };
    Time2.prototype.getMilliseconds = function() {
      return this.millisecond;
    };
    Time2.prototype.getTime = function() {
      return (this.hour * 60 * 60 + this.minute * 60 + this.second) * 1e3 + this.millisecond;
    };
    return Time2;
  }()
);
var DateTime = (
  /** @class */
  function(_super) {
    __extends2(DateTime2, _super);
    function DateTime2(year, month, day, hour, minute, second, millisecond) {
      var _this = _super.call(this, hour, minute, second, millisecond) || this;
      _this.year = year;
      _this.month = month;
      _this.day = day;
      return _this;
    }
    DateTime2.fromDate = function(date) {
      return new this(date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.valueOf() % 1e3);
    };
    DateTime2.prototype.getWeekday = function() {
      return dateutil.getWeekday(new Date(this.getTime()));
    };
    DateTime2.prototype.getTime = function() {
      return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond)).getTime();
    };
    DateTime2.prototype.getDay = function() {
      return this.day;
    };
    DateTime2.prototype.getMonth = function() {
      return this.month;
    };
    DateTime2.prototype.getYear = function() {
      return this.year;
    };
    DateTime2.prototype.addYears = function(years2) {
      this.year += years2;
    };
    DateTime2.prototype.addMonths = function(months2) {
      this.month += months2;
      if (this.month > 12) {
        var yearDiv = Math.floor(this.month / 12);
        var monthMod = pymod(this.month, 12);
        this.month = monthMod;
        this.year += yearDiv;
        if (this.month === 0) {
          this.month = 12;
          --this.year;
        }
      }
    };
    DateTime2.prototype.addWeekly = function(days2, wkst) {
      if (wkst > this.getWeekday()) {
        this.day += -(this.getWeekday() + 1 + (6 - wkst)) + days2 * 7;
      } else {
        this.day += -(this.getWeekday() - wkst) + days2 * 7;
      }
      this.fixDay();
    };
    DateTime2.prototype.addDaily = function(days2) {
      this.day += days2;
      this.fixDay();
    };
    DateTime2.prototype.addHours = function(hours2, filtered, byhour) {
      if (filtered) {
        this.hour += Math.floor((23 - this.hour) / hours2) * hours2;
      }
      for (; ; ) {
        this.hour += hours2;
        var _a2 = divmod(this.hour, 24), dayDiv = _a2.div, hourMod = _a2.mod;
        if (dayDiv) {
          this.hour = hourMod;
          this.addDaily(dayDiv);
        }
        if (empty(byhour) || includes(byhour, this.hour))
          break;
      }
    };
    DateTime2.prototype.addMinutes = function(minutes2, filtered, byhour, byminute) {
      if (filtered) {
        this.minute += Math.floor((1439 - (this.hour * 60 + this.minute)) / minutes2) * minutes2;
      }
      for (; ; ) {
        this.minute += minutes2;
        var _a2 = divmod(this.minute, 60), hourDiv = _a2.div, minuteMod = _a2.mod;
        if (hourDiv) {
          this.minute = minuteMod;
          this.addHours(hourDiv, false, byhour);
        }
        if ((empty(byhour) || includes(byhour, this.hour)) && (empty(byminute) || includes(byminute, this.minute))) {
          break;
        }
      }
    };
    DateTime2.prototype.addSeconds = function(seconds2, filtered, byhour, byminute, bysecond) {
      if (filtered) {
        this.second += Math.floor((86399 - (this.hour * 3600 + this.minute * 60 + this.second)) / seconds2) * seconds2;
      }
      for (; ; ) {
        this.second += seconds2;
        var _a2 = divmod(this.second, 60), minuteDiv = _a2.div, secondMod = _a2.mod;
        if (minuteDiv) {
          this.second = secondMod;
          this.addMinutes(minuteDiv, false, byhour, byminute);
        }
        if ((empty(byhour) || includes(byhour, this.hour)) && (empty(byminute) || includes(byminute, this.minute)) && (empty(bysecond) || includes(bysecond, this.second))) {
          break;
        }
      }
    };
    DateTime2.prototype.fixDay = function() {
      if (this.day <= 28) {
        return;
      }
      var daysinmonth = dateutil.monthRange(this.year, this.month - 1)[1];
      if (this.day <= daysinmonth) {
        return;
      }
      while (this.day > daysinmonth) {
        this.day -= daysinmonth;
        ++this.month;
        if (this.month === 13) {
          this.month = 1;
          ++this.year;
          if (this.year > dateutil.MAXYEAR) {
            return;
          }
        }
        daysinmonth = dateutil.monthRange(this.year, this.month - 1)[1];
      }
    };
    DateTime2.prototype.add = function(options, filtered) {
      var freq = options.freq, interval = options.interval, wkst = options.wkst, byhour = options.byhour, byminute = options.byminute, bysecond = options.bysecond;
      switch (freq) {
        case Frequency.YEARLY:
          return this.addYears(interval);
        case Frequency.MONTHLY:
          return this.addMonths(interval);
        case Frequency.WEEKLY:
          return this.addWeekly(interval, wkst);
        case Frequency.DAILY:
          return this.addDaily(interval);
        case Frequency.HOURLY:
          return this.addHours(interval, filtered, byhour);
        case Frequency.MINUTELY:
          return this.addMinutes(interval, filtered, byhour, byminute);
        case Frequency.SECONDLY:
          return this.addSeconds(interval, filtered, byhour, byminute, bysecond);
      }
    };
    return DateTime2;
  }(Time)
);

// node_modules/rrule/dist/esm/parseoptions.js
function initializeOptions(options) {
  var invalid = [];
  var keys2 = Object.keys(options);
  for (var _i = 0, keys_1 = keys2; _i < keys_1.length; _i++) {
    var key = keys_1[_i];
    if (!includes(defaultKeys, key))
      invalid.push(key);
    if (dateutil_default.isDate(options[key]) && !dateutil_default.isValidDate(options[key])) {
      invalid.push(key);
    }
  }
  if (invalid.length) {
    throw new Error("Invalid options: " + invalid.join(", "));
  }
  return __assign2({}, options);
}
function parseOptions(options) {
  var opts = __assign2(__assign2({}, DEFAULT_OPTIONS), initializeOptions(options));
  if (isPresent(opts.byeaster))
    opts.freq = RRule.YEARLY;
  if (!(isPresent(opts.freq) && RRule.FREQUENCIES[opts.freq])) {
    throw new Error("Invalid frequency: ".concat(opts.freq, " ").concat(options.freq));
  }
  if (!opts.dtstart)
    opts.dtstart = new Date((/* @__PURE__ */ new Date()).setMilliseconds(0));
  if (!isPresent(opts.wkst)) {
    opts.wkst = RRule.MO.weekday;
  } else if (isNumber2(opts.wkst)) {
  } else {
    opts.wkst = opts.wkst.weekday;
  }
  if (isPresent(opts.bysetpos)) {
    if (isNumber2(opts.bysetpos))
      opts.bysetpos = [opts.bysetpos];
    for (var i = 0; i < opts.bysetpos.length; i++) {
      var v = opts.bysetpos[i];
      if (v === 0 || !(v >= -366 && v <= 366)) {
        throw new Error("bysetpos must be between 1 and 366, or between -366 and -1");
      }
    }
  }
  if (!(Boolean(opts.byweekno) || notEmpty(opts.byweekno) || notEmpty(opts.byyearday) || Boolean(opts.bymonthday) || notEmpty(opts.bymonthday) || isPresent(opts.byweekday) || isPresent(opts.byeaster))) {
    switch (opts.freq) {
      case RRule.YEARLY:
        if (!opts.bymonth)
          opts.bymonth = opts.dtstart.getUTCMonth() + 1;
        opts.bymonthday = opts.dtstart.getUTCDate();
        break;
      case RRule.MONTHLY:
        opts.bymonthday = opts.dtstart.getUTCDate();
        break;
      case RRule.WEEKLY:
        opts.byweekday = [dateutil_default.getWeekday(opts.dtstart)];
        break;
    }
  }
  if (isPresent(opts.bymonth) && !isArray2(opts.bymonth)) {
    opts.bymonth = [opts.bymonth];
  }
  if (isPresent(opts.byyearday) && !isArray2(opts.byyearday) && isNumber2(opts.byyearday)) {
    opts.byyearday = [opts.byyearday];
  }
  if (!isPresent(opts.bymonthday)) {
    opts.bymonthday = [];
    opts.bynmonthday = [];
  } else if (isArray2(opts.bymonthday)) {
    var bymonthday = [];
    var bynmonthday = [];
    for (var i = 0; i < opts.bymonthday.length; i++) {
      var v = opts.bymonthday[i];
      if (v > 0) {
        bymonthday.push(v);
      } else if (v < 0) {
        bynmonthday.push(v);
      }
    }
    opts.bymonthday = bymonthday;
    opts.bynmonthday = bynmonthday;
  } else if (opts.bymonthday < 0) {
    opts.bynmonthday = [opts.bymonthday];
    opts.bymonthday = [];
  } else {
    opts.bynmonthday = [];
    opts.bymonthday = [opts.bymonthday];
  }
  if (isPresent(opts.byweekno) && !isArray2(opts.byweekno)) {
    opts.byweekno = [opts.byweekno];
  }
  if (!isPresent(opts.byweekday)) {
    opts.bynweekday = null;
  } else if (isNumber2(opts.byweekday)) {
    opts.byweekday = [opts.byweekday];
    opts.bynweekday = null;
  } else if (isWeekdayStr(opts.byweekday)) {
    opts.byweekday = [Weekday.fromStr(opts.byweekday).weekday];
    opts.bynweekday = null;
  } else if (opts.byweekday instanceof Weekday) {
    if (!opts.byweekday.n || opts.freq > RRule.MONTHLY) {
      opts.byweekday = [opts.byweekday.weekday];
      opts.bynweekday = null;
    } else {
      opts.bynweekday = [[opts.byweekday.weekday, opts.byweekday.n]];
      opts.byweekday = null;
    }
  } else {
    var byweekday = [];
    var bynweekday = [];
    for (var i = 0; i < opts.byweekday.length; i++) {
      var wday = opts.byweekday[i];
      if (isNumber2(wday)) {
        byweekday.push(wday);
        continue;
      } else if (isWeekdayStr(wday)) {
        byweekday.push(Weekday.fromStr(wday).weekday);
        continue;
      }
      if (!wday.n || opts.freq > RRule.MONTHLY) {
        byweekday.push(wday.weekday);
      } else {
        bynweekday.push([wday.weekday, wday.n]);
      }
    }
    opts.byweekday = notEmpty(byweekday) ? byweekday : null;
    opts.bynweekday = notEmpty(bynweekday) ? bynweekday : null;
  }
  if (!isPresent(opts.byhour)) {
    opts.byhour = opts.freq < RRule.HOURLY ? [opts.dtstart.getUTCHours()] : null;
  } else if (isNumber2(opts.byhour)) {
    opts.byhour = [opts.byhour];
  }
  if (!isPresent(opts.byminute)) {
    opts.byminute = opts.freq < RRule.MINUTELY ? [opts.dtstart.getUTCMinutes()] : null;
  } else if (isNumber2(opts.byminute)) {
    opts.byminute = [opts.byminute];
  }
  if (!isPresent(opts.bysecond)) {
    opts.bysecond = opts.freq < RRule.SECONDLY ? [opts.dtstart.getUTCSeconds()] : null;
  } else if (isNumber2(opts.bysecond)) {
    opts.bysecond = [opts.bysecond];
  }
  return { parsedOptions: opts };
}
function buildTimeset(opts) {
  var millisecondModulo = opts.dtstart.getTime() % 1e3;
  if (!freqIsDailyOrGreater(opts.freq)) {
    return [];
  }
  var timeset = [];
  opts.byhour.forEach(function(hour) {
    opts.byminute.forEach(function(minute) {
      opts.bysecond.forEach(function(second) {
        timeset.push(new Time(hour, minute, second, millisecondModulo));
      });
    });
  });
  return timeset;
}

// node_modules/rrule/dist/esm/parsestring.js
function parseString(rfcString) {
  var options = rfcString.split("\n").map(parseLine).filter(function(x) {
    return x !== null;
  });
  return __assign2(__assign2({}, options[0]), options[1]);
}
function parseDtstart(line) {
  var options = {};
  var dtstartWithZone = /DTSTART(?:;TZID=([^:=]+?))?(?::|=)([^;\s]+)/i.exec(line);
  if (!dtstartWithZone) {
    return options;
  }
  var tzid = dtstartWithZone[1], dtstart = dtstartWithZone[2];
  if (tzid) {
    options.tzid = tzid;
  }
  options.dtstart = dateutil_default.untilStringToDate(dtstart);
  return options;
}
function parseLine(rfcString) {
  rfcString = rfcString.replace(/^\s+|\s+$/, "");
  if (!rfcString.length)
    return null;
  var header = /^([A-Z]+?)[:;]/.exec(rfcString.toUpperCase());
  if (!header) {
    return parseRrule(rfcString);
  }
  var key = header[1];
  switch (key.toUpperCase()) {
    case "RRULE":
    case "EXRULE":
      return parseRrule(rfcString);
    case "DTSTART":
      return parseDtstart(rfcString);
    default:
      throw new Error("Unsupported RFC prop ".concat(key, " in ").concat(rfcString));
  }
}
function parseRrule(line) {
  var strippedLine = line.replace(/^RRULE:/i, "");
  var options = parseDtstart(strippedLine);
  var attrs = line.replace(/^(?:RRULE|EXRULE):/i, "").split(";");
  attrs.forEach(function(attr) {
    var _a2 = attr.split("="), key = _a2[0], value = _a2[1];
    switch (key.toUpperCase()) {
      case "FREQ":
        options.freq = Frequency[value.toUpperCase()];
        break;
      case "WKST":
        options.wkst = Days[value.toUpperCase()];
        break;
      case "COUNT":
      case "INTERVAL":
      case "BYSETPOS":
      case "BYMONTH":
      case "BYMONTHDAY":
      case "BYYEARDAY":
      case "BYWEEKNO":
      case "BYHOUR":
      case "BYMINUTE":
      case "BYSECOND":
        var num = parseNumber(value);
        var optionKey = key.toLowerCase();
        options[optionKey] = num;
        break;
      case "BYWEEKDAY":
      case "BYDAY":
        options.byweekday = parseWeekday2(value);
        break;
      case "DTSTART":
      case "TZID":
        var dtstart = parseDtstart(line);
        options.tzid = dtstart.tzid;
        options.dtstart = dtstart.dtstart;
        break;
      case "UNTIL":
        options.until = dateutil_default.untilStringToDate(value);
        break;
      case "BYEASTER":
        options.byeaster = Number(value);
        break;
      default:
        throw new Error("Unknown RRULE property '" + key + "'");
    }
  });
  return options;
}
function parseNumber(value) {
  if (value.indexOf(",") !== -1) {
    var values = value.split(",");
    return values.map(parseIndividualNumber);
  }
  return parseIndividualNumber(value);
}
function parseIndividualNumber(value) {
  if (/^[+-]?\d+$/.test(value)) {
    return Number(value);
  }
  return value;
}
function parseWeekday2(value) {
  var days2 = value.split(",");
  return days2.map(function(day) {
    if (day.length === 2) {
      return Days[day];
    }
    var parts = day.match(/^([+-]?\d{1,2})([A-Z]{2})$/);
    if (!parts || parts.length < 3) {
      throw new SyntaxError("Invalid weekday string: ".concat(day));
    }
    var n = Number(parts[1]);
    var wdaypart = parts[2];
    var wday = Days[wdaypart].weekday;
    return new Weekday(wday, n);
  });
}

// node_modules/rrule/dist/esm/datewithzone.js
var DateWithZone = (
  /** @class */
  function() {
    function DateWithZone2(date, tzid) {
      if (isNaN(date.getTime())) {
        throw new RangeError("Invalid date passed to DateWithZone");
      }
      this.date = date;
      this.tzid = tzid;
    }
    Object.defineProperty(DateWithZone2.prototype, "isUTC", {
      get: function() {
        return !this.tzid || this.tzid.toUpperCase() === "UTC";
      },
      enumerable: false,
      configurable: true
    });
    DateWithZone2.prototype.toString = function() {
      var datestr = dateutil_default.timeToUntilString(this.date.getTime(), this.isUTC);
      if (!this.isUTC) {
        return ";TZID=".concat(this.tzid, ":").concat(datestr);
      }
      return ":".concat(datestr);
    };
    DateWithZone2.prototype.getTime = function() {
      return this.date.getTime();
    };
    DateWithZone2.prototype.rezonedDate = function() {
      var _a2;
      if (this.isUTC) {
        return this.date;
      }
      var localTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
      var dateInLocalTZ = new Date(this.date.toLocaleString(void 0, { timeZone: localTimeZone }));
      var dateInTargetTZ = new Date(this.date.toLocaleString(void 0, { timeZone: (_a2 = this.tzid) !== null && _a2 !== void 0 ? _a2 : "UTC" }));
      var tzOffset = dateInTargetTZ.getTime() - dateInLocalTZ.getTime();
      return new Date(this.date.getTime() - tzOffset);
    };
    return DateWithZone2;
  }()
);

// node_modules/rrule/dist/esm/optionstostring.js
function optionsToString(options) {
  var rrule = [];
  var dtstart = "";
  var keys2 = Object.keys(options);
  var defaultKeys2 = Object.keys(DEFAULT_OPTIONS);
  for (var i = 0; i < keys2.length; i++) {
    if (keys2[i] === "tzid")
      continue;
    if (!includes(defaultKeys2, keys2[i]))
      continue;
    var key = keys2[i].toUpperCase();
    var value = options[keys2[i]];
    var outValue = "";
    if (!isPresent(value) || isArray2(value) && !value.length)
      continue;
    switch (key) {
      case "FREQ":
        outValue = RRule.FREQUENCIES[options.freq];
        break;
      case "WKST":
        if (isNumber2(value)) {
          outValue = new Weekday(value).toString();
        } else {
          outValue = value.toString();
        }
        break;
      case "BYWEEKDAY":
        key = "BYDAY";
        outValue = toArray2(value).map(function(wday) {
          if (wday instanceof Weekday) {
            return wday;
          }
          if (isArray2(wday)) {
            return new Weekday(wday[0], wday[1]);
          }
          return new Weekday(wday);
        }).toString();
        break;
      case "DTSTART":
        dtstart = buildDtstart(value, options.tzid);
        break;
      case "UNTIL":
        outValue = dateutil_default.timeToUntilString(value, !options.tzid);
        break;
      default:
        if (isArray2(value)) {
          var strValues = [];
          for (var j = 0; j < value.length; j++) {
            strValues[j] = String(value[j]);
          }
          outValue = strValues.toString();
        } else {
          outValue = String(value);
        }
    }
    if (outValue) {
      rrule.push([key, outValue]);
    }
  }
  var rules = rrule.map(function(_a2) {
    var key2 = _a2[0], value2 = _a2[1];
    return "".concat(key2, "=").concat(value2.toString());
  }).join(";");
  var ruleString = "";
  if (rules !== "") {
    ruleString = "RRULE:".concat(rules);
  }
  return [dtstart, ruleString].filter(function(x) {
    return !!x;
  }).join("\n");
}
function buildDtstart(dtstart, tzid) {
  if (!dtstart) {
    return "";
  }
  return "DTSTART" + new DateWithZone(new Date(dtstart), tzid).toString();
}

// node_modules/rrule/dist/esm/cache.js
function argsMatch(left, right) {
  if (Array.isArray(left)) {
    if (!Array.isArray(right))
      return false;
    if (left.length !== right.length)
      return false;
    return left.every(function(date, i) {
      return date.getTime() === right[i].getTime();
    });
  }
  if (left instanceof Date) {
    return right instanceof Date && left.getTime() === right.getTime();
  }
  return left === right;
}
var Cache = (
  /** @class */
  function() {
    function Cache2() {
      this.all = false;
      this.before = [];
      this.after = [];
      this.between = [];
    }
    Cache2.prototype._cacheAdd = function(what, value, args) {
      if (value) {
        value = value instanceof Date ? dateutil_default.clone(value) : dateutil_default.cloneDates(value);
      }
      if (what === "all") {
        this.all = value;
      } else {
        args._value = value;
        this[what].push(args);
      }
    };
    Cache2.prototype._cacheGet = function(what, args) {
      var cached = false;
      var argsKeys = args ? Object.keys(args) : [];
      var findCacheDiff = function(item2) {
        for (var i2 = 0; i2 < argsKeys.length; i2++) {
          var key = argsKeys[i2];
          if (!argsMatch(args[key], item2[key])) {
            return true;
          }
        }
        return false;
      };
      var cachedObject = this[what];
      if (what === "all") {
        cached = this.all;
      } else if (isArray2(cachedObject)) {
        for (var i = 0; i < cachedObject.length; i++) {
          var item = cachedObject[i];
          if (argsKeys.length && findCacheDiff(item))
            continue;
          cached = item._value;
          break;
        }
      }
      if (!cached && this.all) {
        var iterResult = new iterresult_default(what, args);
        for (var i = 0; i < this.all.length; i++) {
          if (!iterResult.accept(this.all[i]))
            break;
        }
        cached = iterResult.getValue();
        this._cacheAdd(what, cached, args);
      }
      return isArray2(cached) ? dateutil_default.cloneDates(cached) : cached instanceof Date ? dateutil_default.clone(cached) : cached;
    };
    return Cache2;
  }()
);

// node_modules/rrule/dist/esm/masks.js
var M365MASK = __spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3([], repeat(1, 31), true), repeat(2, 28), true), repeat(3, 31), true), repeat(4, 30), true), repeat(5, 31), true), repeat(6, 30), true), repeat(7, 31), true), repeat(8, 31), true), repeat(9, 30), true), repeat(10, 31), true), repeat(11, 30), true), repeat(12, 31), true), repeat(1, 7), true);
var M366MASK = __spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3([], repeat(1, 31), true), repeat(2, 29), true), repeat(3, 31), true), repeat(4, 30), true), repeat(5, 31), true), repeat(6, 30), true), repeat(7, 31), true), repeat(8, 31), true), repeat(9, 30), true), repeat(10, 31), true), repeat(11, 30), true), repeat(12, 31), true), repeat(1, 7), true);
var M28 = range(1, 29);
var M29 = range(1, 30);
var M30 = range(1, 31);
var M31 = range(1, 32);
var MDAY366MASK = __spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3([], M31, true), M29, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31.slice(0, 7), true);
var MDAY365MASK = __spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3([], M31, true), M28, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31.slice(0, 7), true);
var NM28 = range(-28, 0);
var NM29 = range(-29, 0);
var NM30 = range(-30, 0);
var NM31 = range(-31, 0);
var NMDAY366MASK = __spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3([], NM31, true), NM29, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31.slice(0, 7), true);
var NMDAY365MASK = __spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3(__spreadArray3([], NM31, true), NM28, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31.slice(0, 7), true);
var M366RANGE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366];
var M365RANGE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365];
var WDAYMASK = function() {
  var wdaymask = [];
  for (var i = 0; i < 55; i++)
    wdaymask = wdaymask.concat(range(7));
  return wdaymask;
}();

// node_modules/rrule/dist/esm/iterinfo/yearinfo.js
function rebuildYear(year, options) {
  var firstyday = new Date(Date.UTC(year, 0, 1));
  var yearlen = dateutil_default.isLeapYear(year) ? 366 : 365;
  var nextyearlen = dateutil_default.isLeapYear(year + 1) ? 366 : 365;
  var yearordinal = dateutil_default.toOrdinal(firstyday);
  var yearweekday = dateutil_default.getWeekday(firstyday);
  var result = __assign2(__assign2({ yearlen, nextyearlen, yearordinal, yearweekday }, baseYearMasks(year)), { wnomask: null });
  if (empty(options.byweekno)) {
    return result;
  }
  result.wnomask = repeat(0, yearlen + 7);
  var firstwkst;
  var wyearlen;
  var no1wkst = firstwkst = pymod(7 - yearweekday + options.wkst, 7);
  if (no1wkst >= 4) {
    no1wkst = 0;
    wyearlen = result.yearlen + pymod(yearweekday - options.wkst, 7);
  } else {
    wyearlen = yearlen - no1wkst;
  }
  var div = Math.floor(wyearlen / 7);
  var mod2 = pymod(wyearlen, 7);
  var numweeks = Math.floor(div + mod2 / 4);
  for (var j = 0; j < options.byweekno.length; j++) {
    var n = options.byweekno[j];
    if (n < 0) {
      n += numweeks + 1;
    }
    if (!(n > 0 && n <= numweeks)) {
      continue;
    }
    var i = void 0;
    if (n > 1) {
      i = no1wkst + (n - 1) * 7;
      if (no1wkst !== firstwkst) {
        i -= 7 - firstwkst;
      }
    } else {
      i = no1wkst;
    }
    for (var k = 0; k < 7; k++) {
      result.wnomask[i] = 1;
      i++;
      if (result.wdaymask[i] === options.wkst)
        break;
    }
  }
  if (includes(options.byweekno, 1)) {
    var i = no1wkst + numweeks * 7;
    if (no1wkst !== firstwkst)
      i -= 7 - firstwkst;
    if (i < yearlen) {
      for (var j = 0; j < 7; j++) {
        result.wnomask[i] = 1;
        i += 1;
        if (result.wdaymask[i] === options.wkst)
          break;
      }
    }
  }
  if (no1wkst) {
    var lnumweeks = void 0;
    if (!includes(options.byweekno, -1)) {
      var lyearweekday = dateutil_default.getWeekday(new Date(Date.UTC(year - 1, 0, 1)));
      var lno1wkst = pymod(7 - lyearweekday.valueOf() + options.wkst, 7);
      var lyearlen = dateutil_default.isLeapYear(year - 1) ? 366 : 365;
      var weekst = void 0;
      if (lno1wkst >= 4) {
        lno1wkst = 0;
        weekst = lyearlen + pymod(lyearweekday - options.wkst, 7);
      } else {
        weekst = yearlen - no1wkst;
      }
      lnumweeks = Math.floor(52 + pymod(weekst, 7) / 4);
    } else {
      lnumweeks = -1;
    }
    if (includes(options.byweekno, lnumweeks)) {
      for (var i = 0; i < no1wkst; i++)
        result.wnomask[i] = 1;
    }
  }
  return result;
}
function baseYearMasks(year) {
  var yearlen = dateutil_default.isLeapYear(year) ? 366 : 365;
  var firstyday = new Date(Date.UTC(year, 0, 1));
  var wday = dateutil_default.getWeekday(firstyday);
  if (yearlen === 365) {
    return {
      mmask: M365MASK,
      mdaymask: MDAY365MASK,
      nmdaymask: NMDAY365MASK,
      wdaymask: WDAYMASK.slice(wday),
      mrange: M365RANGE
    };
  }
  return {
    mmask: M366MASK,
    mdaymask: MDAY366MASK,
    nmdaymask: NMDAY366MASK,
    wdaymask: WDAYMASK.slice(wday),
    mrange: M366RANGE
  };
}

// node_modules/rrule/dist/esm/iterinfo/monthinfo.js
function rebuildMonth(year, month, yearlen, mrange, wdaymask, options) {
  var result = {
    lastyear: year,
    lastmonth: month,
    nwdaymask: []
  };
  var ranges = [];
  if (options.freq === RRule.YEARLY) {
    if (empty(options.bymonth)) {
      ranges = [[0, yearlen]];
    } else {
      for (var j = 0; j < options.bymonth.length; j++) {
        month = options.bymonth[j];
        ranges.push(mrange.slice(month - 1, month + 1));
      }
    }
  } else if (options.freq === RRule.MONTHLY) {
    ranges = [mrange.slice(month - 1, month + 1)];
  }
  if (empty(ranges)) {
    return result;
  }
  result.nwdaymask = repeat(0, yearlen);
  for (var j = 0; j < ranges.length; j++) {
    var rang = ranges[j];
    var first = rang[0];
    var last = rang[1] - 1;
    for (var k = 0; k < options.bynweekday.length; k++) {
      var i = void 0;
      var _a2 = options.bynweekday[k], wday = _a2[0], n = _a2[1];
      if (n < 0) {
        i = last + (n + 1) * 7;
        i -= pymod(wdaymask[i] - wday, 7);
      } else {
        i = first + (n - 1) * 7;
        i += pymod(7 - wdaymask[i] + wday, 7);
      }
      if (first <= i && i <= last)
        result.nwdaymask[i] = 1;
    }
  }
  return result;
}

// node_modules/rrule/dist/esm/iterinfo/easter.js
function easter(y, offset2) {
  if (offset2 === void 0) {
    offset2 = 0;
  }
  var a = y % 19;
  var b = Math.floor(y / 100);
  var c = y % 100;
  var d = Math.floor(b / 4);
  var e = b % 4;
  var f = Math.floor((b + 8) / 25);
  var g = Math.floor((b - f + 1) / 3);
  var h = Math.floor(19 * a + b - d - g + 15) % 30;
  var i = Math.floor(c / 4);
  var k = c % 4;
  var l = Math.floor(32 + 2 * e + 2 * i - h - k) % 7;
  var m = Math.floor((a + 11 * h + 22 * l) / 451);
  var month = Math.floor((h + l - 7 * m + 114) / 31);
  var day = (h + l - 7 * m + 114) % 31 + 1;
  var date = Date.UTC(y, month - 1, day + offset2);
  var yearStart = Date.UTC(y, 0, 1);
  return [Math.ceil((date - yearStart) / (1e3 * 60 * 60 * 24))];
}

// node_modules/rrule/dist/esm/iterinfo/index.js
var Iterinfo = (
  /** @class */
  function() {
    function Iterinfo2(options) {
      this.options = options;
    }
    Iterinfo2.prototype.rebuild = function(year, month) {
      var options = this.options;
      if (year !== this.lastyear) {
        this.yearinfo = rebuildYear(year, options);
      }
      if (notEmpty(options.bynweekday) && (month !== this.lastmonth || year !== this.lastyear)) {
        var _a2 = this.yearinfo, yearlen = _a2.yearlen, mrange = _a2.mrange, wdaymask = _a2.wdaymask;
        this.monthinfo = rebuildMonth(year, month, yearlen, mrange, wdaymask, options);
      }
      if (isPresent(options.byeaster)) {
        this.eastermask = easter(year, options.byeaster);
      }
    };
    Object.defineProperty(Iterinfo2.prototype, "lastyear", {
      get: function() {
        return this.monthinfo ? this.monthinfo.lastyear : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "lastmonth", {
      get: function() {
        return this.monthinfo ? this.monthinfo.lastmonth : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "yearlen", {
      get: function() {
        return this.yearinfo.yearlen;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "yearordinal", {
      get: function() {
        return this.yearinfo.yearordinal;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "mrange", {
      get: function() {
        return this.yearinfo.mrange;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "wdaymask", {
      get: function() {
        return this.yearinfo.wdaymask;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "mmask", {
      get: function() {
        return this.yearinfo.mmask;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "wnomask", {
      get: function() {
        return this.yearinfo.wnomask;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "nwdaymask", {
      get: function() {
        return this.monthinfo ? this.monthinfo.nwdaymask : [];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "nextyearlen", {
      get: function() {
        return this.yearinfo.nextyearlen;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "mdaymask", {
      get: function() {
        return this.yearinfo.mdaymask;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "nmdaymask", {
      get: function() {
        return this.yearinfo.nmdaymask;
      },
      enumerable: false,
      configurable: true
    });
    Iterinfo2.prototype.ydayset = function() {
      return [range(this.yearlen), 0, this.yearlen];
    };
    Iterinfo2.prototype.mdayset = function(_, month) {
      var start = this.mrange[month - 1];
      var end = this.mrange[month];
      var set2 = repeat(null, this.yearlen);
      for (var i = start; i < end; i++)
        set2[i] = i;
      return [set2, start, end];
    };
    Iterinfo2.prototype.wdayset = function(year, month, day) {
      var set2 = repeat(null, this.yearlen + 7);
      var i = dateutil_default.toOrdinal(new Date(Date.UTC(year, month - 1, day))) - this.yearordinal;
      var start = i;
      for (var j = 0; j < 7; j++) {
        set2[i] = i;
        ++i;
        if (this.wdaymask[i] === this.options.wkst)
          break;
      }
      return [set2, start, i];
    };
    Iterinfo2.prototype.ddayset = function(year, month, day) {
      var set2 = repeat(null, this.yearlen);
      var i = dateutil_default.toOrdinal(new Date(Date.UTC(year, month - 1, day))) - this.yearordinal;
      set2[i] = i;
      return [set2, i, i + 1];
    };
    Iterinfo2.prototype.htimeset = function(hour, _, second, millisecond) {
      var _this = this;
      var set2 = [];
      this.options.byminute.forEach(function(minute) {
        set2 = set2.concat(_this.mtimeset(hour, minute, second, millisecond));
      });
      dateutil_default.sort(set2);
      return set2;
    };
    Iterinfo2.prototype.mtimeset = function(hour, minute, _, millisecond) {
      var set2 = this.options.bysecond.map(function(second) {
        return new Time(hour, minute, second, millisecond);
      });
      dateutil_default.sort(set2);
      return set2;
    };
    Iterinfo2.prototype.stimeset = function(hour, minute, second, millisecond) {
      return [new Time(hour, minute, second, millisecond)];
    };
    Iterinfo2.prototype.getdayset = function(freq) {
      switch (freq) {
        case Frequency.YEARLY:
          return this.ydayset.bind(this);
        case Frequency.MONTHLY:
          return this.mdayset.bind(this);
        case Frequency.WEEKLY:
          return this.wdayset.bind(this);
        case Frequency.DAILY:
          return this.ddayset.bind(this);
        default:
          return this.ddayset.bind(this);
      }
    };
    Iterinfo2.prototype.gettimeset = function(freq) {
      switch (freq) {
        case Frequency.HOURLY:
          return this.htimeset.bind(this);
        case Frequency.MINUTELY:
          return this.mtimeset.bind(this);
        case Frequency.SECONDLY:
          return this.stimeset.bind(this);
      }
    };
    return Iterinfo2;
  }()
);
var iterinfo_default = Iterinfo;

// node_modules/rrule/dist/esm/iter/poslist.js
function buildPoslist(bysetpos, timeset, start, end, ii, dayset) {
  var poslist = [];
  for (var j = 0; j < bysetpos.length; j++) {
    var daypos = void 0;
    var timepos = void 0;
    var pos = bysetpos[j];
    if (pos < 0) {
      daypos = Math.floor(pos / timeset.length);
      timepos = pymod(pos, timeset.length);
    } else {
      daypos = Math.floor((pos - 1) / timeset.length);
      timepos = pymod(pos - 1, timeset.length);
    }
    var tmp = [];
    for (var k = start; k < end; k++) {
      var val = dayset[k];
      if (!isPresent(val))
        continue;
      tmp.push(val);
    }
    var i = void 0;
    if (daypos < 0) {
      i = tmp.slice(daypos)[0];
    } else {
      i = tmp[daypos];
    }
    var time = timeset[timepos];
    var date = dateutil_default.fromOrdinal(ii.yearordinal + i);
    var res = dateutil_default.combine(date, time);
    if (!includes(poslist, res))
      poslist.push(res);
  }
  dateutil_default.sort(poslist);
  return poslist;
}

// node_modules/rrule/dist/esm/iter/index.js
function iter(iterResult, options) {
  var dtstart = options.dtstart, freq = options.freq, interval = options.interval, until = options.until, bysetpos = options.bysetpos;
  var count = options.count;
  if (count === 0 || interval === 0) {
    return emitResult(iterResult);
  }
  var counterDate = DateTime.fromDate(dtstart);
  var ii = new iterinfo_default(options);
  ii.rebuild(counterDate.year, counterDate.month);
  var timeset = makeTimeset(ii, counterDate, options);
  for (; ; ) {
    var _a2 = ii.getdayset(freq)(counterDate.year, counterDate.month, counterDate.day), dayset = _a2[0], start = _a2[1], end = _a2[2];
    var filtered = removeFilteredDays(dayset, start, end, ii, options);
    if (notEmpty(bysetpos)) {
      var poslist = buildPoslist(bysetpos, timeset, start, end, ii, dayset);
      for (var j = 0; j < poslist.length; j++) {
        var res = poslist[j];
        if (until && res > until) {
          return emitResult(iterResult);
        }
        if (res >= dtstart) {
          var rezonedDate = rezoneIfNeeded(res, options);
          if (!iterResult.accept(rezonedDate)) {
            return emitResult(iterResult);
          }
          if (count) {
            --count;
            if (!count) {
              return emitResult(iterResult);
            }
          }
        }
      }
    } else {
      for (var j = start; j < end; j++) {
        var currentDay = dayset[j];
        if (!isPresent(currentDay)) {
          continue;
        }
        var date = dateutil_default.fromOrdinal(ii.yearordinal + currentDay);
        for (var k = 0; k < timeset.length; k++) {
          var time = timeset[k];
          var res = dateutil_default.combine(date, time);
          if (until && res > until) {
            return emitResult(iterResult);
          }
          if (res >= dtstart) {
            var rezonedDate = rezoneIfNeeded(res, options);
            if (!iterResult.accept(rezonedDate)) {
              return emitResult(iterResult);
            }
            if (count) {
              --count;
              if (!count) {
                return emitResult(iterResult);
              }
            }
          }
        }
      }
    }
    if (options.interval === 0) {
      return emitResult(iterResult);
    }
    counterDate.add(options, filtered);
    if (counterDate.year > dateutil_default.MAXYEAR) {
      return emitResult(iterResult);
    }
    if (!freqIsDailyOrGreater(freq)) {
      timeset = ii.gettimeset(freq)(counterDate.hour, counterDate.minute, counterDate.second, 0);
    }
    ii.rebuild(counterDate.year, counterDate.month);
  }
}
function isFiltered(ii, currentDay, options) {
  var bymonth = options.bymonth, byweekno = options.byweekno, byweekday = options.byweekday, byeaster = options.byeaster, bymonthday = options.bymonthday, bynmonthday = options.bynmonthday, byyearday = options.byyearday;
  return notEmpty(bymonth) && !includes(bymonth, ii.mmask[currentDay]) || notEmpty(byweekno) && !ii.wnomask[currentDay] || notEmpty(byweekday) && !includes(byweekday, ii.wdaymask[currentDay]) || notEmpty(ii.nwdaymask) && !ii.nwdaymask[currentDay] || byeaster !== null && !includes(ii.eastermask, currentDay) || (notEmpty(bymonthday) || notEmpty(bynmonthday)) && !includes(bymonthday, ii.mdaymask[currentDay]) && !includes(bynmonthday, ii.nmdaymask[currentDay]) || notEmpty(byyearday) && (currentDay < ii.yearlen && !includes(byyearday, currentDay + 1) && !includes(byyearday, -ii.yearlen + currentDay) || currentDay >= ii.yearlen && !includes(byyearday, currentDay + 1 - ii.yearlen) && !includes(byyearday, -ii.nextyearlen + currentDay - ii.yearlen));
}
function rezoneIfNeeded(date, options) {
  return new DateWithZone(date, options.tzid).rezonedDate();
}
function emitResult(iterResult) {
  return iterResult.getValue();
}
function removeFilteredDays(dayset, start, end, ii, options) {
  var filtered = false;
  for (var dayCounter = start; dayCounter < end; dayCounter++) {
    var currentDay = dayset[dayCounter];
    filtered = isFiltered(ii, currentDay, options);
    if (filtered)
      dayset[currentDay] = null;
  }
  return filtered;
}
function makeTimeset(ii, counterDate, options) {
  var freq = options.freq, byhour = options.byhour, byminute = options.byminute, bysecond = options.bysecond;
  if (freqIsDailyOrGreater(freq)) {
    return buildTimeset(options);
  }
  if (freq >= RRule.HOURLY && notEmpty(byhour) && !includes(byhour, counterDate.hour) || freq >= RRule.MINUTELY && notEmpty(byminute) && !includes(byminute, counterDate.minute) || freq >= RRule.SECONDLY && notEmpty(bysecond) && !includes(bysecond, counterDate.second)) {
    return [];
  }
  return ii.gettimeset(freq)(counterDate.hour, counterDate.minute, counterDate.second, counterDate.millisecond);
}

// node_modules/rrule/dist/esm/rrule.js
var Days = {
  MO: new Weekday(0),
  TU: new Weekday(1),
  WE: new Weekday(2),
  TH: new Weekday(3),
  FR: new Weekday(4),
  SA: new Weekday(5),
  SU: new Weekday(6)
};
var DEFAULT_OPTIONS = {
  freq: Frequency.YEARLY,
  dtstart: null,
  interval: 1,
  wkst: Days.MO,
  count: null,
  until: null,
  tzid: null,
  bysetpos: null,
  bymonth: null,
  bymonthday: null,
  bynmonthday: null,
  byyearday: null,
  byweekno: null,
  byweekday: null,
  bynweekday: null,
  byhour: null,
  byminute: null,
  bysecond: null,
  byeaster: null
};
var defaultKeys = Object.keys(DEFAULT_OPTIONS);
var RRule = (
  /** @class */
  function() {
    function RRule2(options, noCache) {
      if (options === void 0) {
        options = {};
      }
      if (noCache === void 0) {
        noCache = false;
      }
      this._cache = noCache ? null : new Cache();
      this.origOptions = initializeOptions(options);
      var parsedOptions = parseOptions(options).parsedOptions;
      this.options = parsedOptions;
    }
    RRule2.parseText = function(text, language) {
      return parseText(text, language);
    };
    RRule2.fromText = function(text, language) {
      return fromText(text, language);
    };
    RRule2.fromString = function(str) {
      return new RRule2(RRule2.parseString(str) || void 0);
    };
    RRule2.prototype._iter = function(iterResult) {
      return iter(iterResult, this.options);
    };
    RRule2.prototype._cacheGet = function(what, args) {
      if (!this._cache)
        return false;
      return this._cache._cacheGet(what, args);
    };
    RRule2.prototype._cacheAdd = function(what, value, args) {
      if (!this._cache)
        return;
      return this._cache._cacheAdd(what, value, args);
    };
    RRule2.prototype.all = function(iterator) {
      if (iterator) {
        return this._iter(new callbackiterresult_default("all", {}, iterator));
      }
      var result = this._cacheGet("all");
      if (result === false) {
        result = this._iter(new iterresult_default("all", {}));
        this._cacheAdd("all", result);
      }
      return result;
    };
    RRule2.prototype.between = function(after, before, inc, iterator) {
      if (inc === void 0) {
        inc = false;
      }
      if (!dateutil_default.isValidDate(after) || !dateutil_default.isValidDate(before)) {
        throw new Error("Invalid date passed in to RRule.between");
      }
      var args = {
        before,
        after,
        inc
      };
      if (iterator) {
        return this._iter(new callbackiterresult_default("between", args, iterator));
      }
      var result = this._cacheGet("between", args);
      if (result === false) {
        result = this._iter(new iterresult_default("between", args));
        this._cacheAdd("between", result, args);
      }
      return result;
    };
    RRule2.prototype.before = function(dt, inc) {
      if (inc === void 0) {
        inc = false;
      }
      if (!dateutil_default.isValidDate(dt)) {
        throw new Error("Invalid date passed in to RRule.before");
      }
      var args = { dt, inc };
      var result = this._cacheGet("before", args);
      if (result === false) {
        result = this._iter(new iterresult_default("before", args));
        this._cacheAdd("before", result, args);
      }
      return result;
    };
    RRule2.prototype.after = function(dt, inc) {
      if (inc === void 0) {
        inc = false;
      }
      if (!dateutil_default.isValidDate(dt)) {
        throw new Error("Invalid date passed in to RRule.after");
      }
      var args = { dt, inc };
      var result = this._cacheGet("after", args);
      if (result === false) {
        result = this._iter(new iterresult_default("after", args));
        this._cacheAdd("after", result, args);
      }
      return result;
    };
    RRule2.prototype.count = function() {
      return this.all().length;
    };
    RRule2.prototype.toString = function() {
      return optionsToString(this.origOptions);
    };
    RRule2.prototype.toText = function(gettext, language, dateFormatter) {
      return toText(this, gettext, language, dateFormatter);
    };
    RRule2.prototype.isFullyConvertibleToText = function() {
      return isFullyConvertible(this);
    };
    RRule2.prototype.clone = function() {
      return new RRule2(this.origOptions);
    };
    RRule2.FREQUENCIES = [
      "YEARLY",
      "MONTHLY",
      "WEEKLY",
      "DAILY",
      "HOURLY",
      "MINUTELY",
      "SECONDLY"
    ];
    RRule2.YEARLY = Frequency.YEARLY;
    RRule2.MONTHLY = Frequency.MONTHLY;
    RRule2.WEEKLY = Frequency.WEEKLY;
    RRule2.DAILY = Frequency.DAILY;
    RRule2.HOURLY = Frequency.HOURLY;
    RRule2.MINUTELY = Frequency.MINUTELY;
    RRule2.SECONDLY = Frequency.SECONDLY;
    RRule2.MO = Days.MO;
    RRule2.TU = Days.TU;
    RRule2.WE = Days.WE;
    RRule2.TH = Days.TH;
    RRule2.FR = Days.FR;
    RRule2.SA = Days.SA;
    RRule2.SU = Days.SU;
    RRule2.parseString = parseString;
    RRule2.optionsToString = optionsToString;
    return RRule2;
  }()
);

// node_modules/rrule/dist/esm/iterset.js
function iterSet(iterResult, _rrule, _exrule, _rdate, _exdate, tzid) {
  var _exdateHash = {};
  var _accept = iterResult.accept;
  function evalExdate(after, before) {
    _exrule.forEach(function(rrule) {
      rrule.between(after, before, true).forEach(function(date) {
        _exdateHash[Number(date)] = true;
      });
    });
  }
  _exdate.forEach(function(date) {
    var zonedDate2 = new DateWithZone(date, tzid).rezonedDate();
    _exdateHash[Number(zonedDate2)] = true;
  });
  iterResult.accept = function(date) {
    var dt = Number(date);
    if (isNaN(dt))
      return _accept.call(this, date);
    if (!_exdateHash[dt]) {
      evalExdate(new Date(dt - 1), new Date(dt + 1));
      if (!_exdateHash[dt]) {
        _exdateHash[dt] = true;
        return _accept.call(this, date);
      }
    }
    return true;
  };
  if (iterResult.method === "between") {
    evalExdate(iterResult.args.after, iterResult.args.before);
    iterResult.accept = function(date) {
      var dt = Number(date);
      if (!_exdateHash[dt]) {
        _exdateHash[dt] = true;
        return _accept.call(this, date);
      }
      return true;
    };
  }
  for (var i = 0; i < _rdate.length; i++) {
    var zonedDate = new DateWithZone(_rdate[i], tzid).rezonedDate();
    if (!iterResult.accept(new Date(zonedDate.getTime())))
      break;
  }
  _rrule.forEach(function(rrule) {
    iter(iterResult, rrule.options);
  });
  var res = iterResult._result;
  dateutil_default.sort(res);
  switch (iterResult.method) {
    case "all":
    case "between":
      return res;
    case "before":
      return res.length && res[res.length - 1] || null;
    case "after":
    default:
      return res.length && res[0] || null;
  }
}

// node_modules/rrule/dist/esm/rrulestr.js
var DEFAULT_OPTIONS2 = {
  dtstart: null,
  cache: false,
  unfold: false,
  forceset: false,
  compatible: false,
  tzid: null
};
function parseInput(s, options) {
  var rrulevals = [];
  var rdatevals = [];
  var exrulevals = [];
  var exdatevals = [];
  var parsedDtstart = parseDtstart(s);
  var dtstart = parsedDtstart.dtstart;
  var tzid = parsedDtstart.tzid;
  var lines = splitIntoLines(s, options.unfold);
  lines.forEach(function(line) {
    var _a2;
    if (!line)
      return;
    var _b = breakDownLine(line), name = _b.name, parms = _b.parms, value = _b.value;
    switch (name.toUpperCase()) {
      case "RRULE":
        if (parms.length) {
          throw new Error("unsupported RRULE parm: ".concat(parms.join(",")));
        }
        rrulevals.push(parseString(line));
        break;
      case "RDATE":
        var _c = (_a2 = /RDATE(?:;TZID=([^:=]+))?/i.exec(line)) !== null && _a2 !== void 0 ? _a2 : [], rdateTzid = _c[1];
        if (rdateTzid && !tzid) {
          tzid = rdateTzid;
        }
        rdatevals = rdatevals.concat(parseRDate(value, parms));
        break;
      case "EXRULE":
        if (parms.length) {
          throw new Error("unsupported EXRULE parm: ".concat(parms.join(",")));
        }
        exrulevals.push(parseString(value));
        break;
      case "EXDATE":
        exdatevals = exdatevals.concat(parseRDate(value, parms));
        break;
      case "DTSTART":
        break;
      default:
        throw new Error("unsupported property: " + name);
    }
  });
  return {
    dtstart,
    tzid,
    rrulevals,
    rdatevals,
    exrulevals,
    exdatevals
  };
}
function buildRule(s, options) {
  var _a2 = parseInput(s, options), rrulevals = _a2.rrulevals, rdatevals = _a2.rdatevals, exrulevals = _a2.exrulevals, exdatevals = _a2.exdatevals, dtstart = _a2.dtstart, tzid = _a2.tzid;
  var noCache = options.cache === false;
  if (options.compatible) {
    options.forceset = true;
    options.unfold = true;
  }
  if (options.forceset || rrulevals.length > 1 || rdatevals.length || exrulevals.length || exdatevals.length) {
    var rset_1 = new RRuleSet(noCache);
    rset_1.dtstart(dtstart);
    rset_1.tzid(tzid || void 0);
    rrulevals.forEach(function(val2) {
      rset_1.rrule(new RRule(groomRruleOptions(val2, dtstart, tzid), noCache));
    });
    rdatevals.forEach(function(date) {
      rset_1.rdate(date);
    });
    exrulevals.forEach(function(val2) {
      rset_1.exrule(new RRule(groomRruleOptions(val2, dtstart, tzid), noCache));
    });
    exdatevals.forEach(function(date) {
      rset_1.exdate(date);
    });
    if (options.compatible && options.dtstart)
      rset_1.rdate(dtstart);
    return rset_1;
  }
  var val = rrulevals[0] || {};
  return new RRule(groomRruleOptions(val, val.dtstart || options.dtstart || dtstart, val.tzid || options.tzid || tzid), noCache);
}
function rrulestr(s, options) {
  if (options === void 0) {
    options = {};
  }
  return buildRule(s, initializeOptions2(options));
}
function groomRruleOptions(val, dtstart, tzid) {
  return __assign2(__assign2({}, val), { dtstart, tzid });
}
function initializeOptions2(options) {
  var invalid = [];
  var keys2 = Object.keys(options);
  var defaultKeys2 = Object.keys(DEFAULT_OPTIONS2);
  keys2.forEach(function(key) {
    if (!includes(defaultKeys2, key))
      invalid.push(key);
  });
  if (invalid.length) {
    throw new Error("Invalid options: " + invalid.join(", "));
  }
  return __assign2(__assign2({}, DEFAULT_OPTIONS2), options);
}
function extractName(line) {
  if (line.indexOf(":") === -1) {
    return {
      name: "RRULE",
      value: line
    };
  }
  var _a2 = split(line, ":", 1), name = _a2[0], value = _a2[1];
  return {
    name,
    value
  };
}
function breakDownLine(line) {
  var _a2 = extractName(line), name = _a2.name, value = _a2.value;
  var parms = name.split(";");
  if (!parms)
    throw new Error("empty property name");
  return {
    name: parms[0].toUpperCase(),
    parms: parms.slice(1),
    value
  };
}
function splitIntoLines(s, unfold) {
  if (unfold === void 0) {
    unfold = false;
  }
  s = s && s.trim();
  if (!s)
    throw new Error("Invalid empty string");
  if (!unfold) {
    return s.split(/\s/);
  }
  var lines = s.split("\n");
  var i = 0;
  while (i < lines.length) {
    var line = lines[i] = lines[i].replace(/\s+$/g, "");
    if (!line) {
      lines.splice(i, 1);
    } else if (i > 0 && line[0] === " ") {
      lines[i - 1] += line.slice(1);
      lines.splice(i, 1);
    } else {
      i += 1;
    }
  }
  return lines;
}
function validateDateParm(parms) {
  parms.forEach(function(parm) {
    if (!/(VALUE=DATE(-TIME)?)|(TZID=)/.test(parm)) {
      throw new Error("unsupported RDATE/EXDATE parm: " + parm);
    }
  });
}
function parseRDate(rdateval, parms) {
  validateDateParm(parms);
  return rdateval.split(",").map(function(datestr) {
    return dateutil_default.untilStringToDate(datestr);
  });
}

// node_modules/rrule/dist/esm/rruleset.js
function createGetterSetter(fieldName) {
  var _this = this;
  return function(field) {
    if (field !== void 0) {
      _this["_".concat(fieldName)] = field;
    }
    if (_this["_".concat(fieldName)] !== void 0) {
      return _this["_".concat(fieldName)];
    }
    for (var i = 0; i < _this._rrule.length; i++) {
      var field_1 = _this._rrule[i].origOptions[fieldName];
      if (field_1) {
        return field_1;
      }
    }
  };
}
var RRuleSet = (
  /** @class */
  function(_super) {
    __extends2(RRuleSet2, _super);
    function RRuleSet2(noCache) {
      if (noCache === void 0) {
        noCache = false;
      }
      var _this = _super.call(this, {}, noCache) || this;
      _this.dtstart = createGetterSetter.apply(_this, ["dtstart"]);
      _this.tzid = createGetterSetter.apply(_this, ["tzid"]);
      _this._rrule = [];
      _this._rdate = [];
      _this._exrule = [];
      _this._exdate = [];
      return _this;
    }
    RRuleSet2.prototype._iter = function(iterResult) {
      return iterSet(iterResult, this._rrule, this._exrule, this._rdate, this._exdate, this.tzid());
    };
    RRuleSet2.prototype.rrule = function(rrule) {
      _addRule(rrule, this._rrule);
    };
    RRuleSet2.prototype.exrule = function(rrule) {
      _addRule(rrule, this._exrule);
    };
    RRuleSet2.prototype.rdate = function(date) {
      _addDate(date, this._rdate);
    };
    RRuleSet2.prototype.exdate = function(date) {
      _addDate(date, this._exdate);
    };
    RRuleSet2.prototype.rrules = function() {
      return this._rrule.map(function(e) {
        return rrulestr(e.toString());
      });
    };
    RRuleSet2.prototype.exrules = function() {
      return this._exrule.map(function(e) {
        return rrulestr(e.toString());
      });
    };
    RRuleSet2.prototype.rdates = function() {
      return this._rdate.map(function(e) {
        return new Date(e.getTime());
      });
    };
    RRuleSet2.prototype.exdates = function() {
      return this._exdate.map(function(e) {
        return new Date(e.getTime());
      });
    };
    RRuleSet2.prototype.valueOf = function() {
      var result = [];
      if (!this._rrule.length && this._dtstart) {
        result = result.concat(optionsToString({ dtstart: this._dtstart }));
      }
      this._rrule.forEach(function(rrule) {
        result = result.concat(rrule.toString().split("\n"));
      });
      this._exrule.forEach(function(exrule) {
        result = result.concat(exrule.toString().split("\n").map(function(line) {
          return line.replace(/^RRULE:/, "EXRULE:");
        }).filter(function(line) {
          return !/^DTSTART/.test(line);
        }));
      });
      if (this._rdate.length) {
        result.push(rdatesToString("RDATE", this._rdate, this.tzid()));
      }
      if (this._exdate.length) {
        result.push(rdatesToString("EXDATE", this._exdate, this.tzid()));
      }
      return result;
    };
    RRuleSet2.prototype.toString = function() {
      return this.valueOf().join("\n");
    };
    RRuleSet2.prototype.clone = function() {
      var rrs = new RRuleSet2(!!this._cache);
      this._rrule.forEach(function(rule) {
        return rrs.rrule(rule.clone());
      });
      this._exrule.forEach(function(rule) {
        return rrs.exrule(rule.clone());
      });
      this._rdate.forEach(function(date) {
        return rrs.rdate(new Date(date.getTime()));
      });
      this._exdate.forEach(function(date) {
        return rrs.exdate(new Date(date.getTime()));
      });
      return rrs;
    };
    return RRuleSet2;
  }(RRule)
);
function _addRule(rrule, collection) {
  if (!(rrule instanceof RRule)) {
    throw new TypeError(String(rrule) + " is not RRule instance");
  }
  if (!includes(collection.map(String), String(rrule))) {
    collection.push(rrule);
  }
}
function _addDate(date, collection) {
  if (!(date instanceof Date)) {
    throw new TypeError(String(date) + " is not Date instance");
  }
  if (!includes(collection.map(Number), Number(date))) {
    collection.push(date);
    dateutil_default.sort(collection);
  }
}
function rdatesToString(param, rdates, tzid) {
  var isUTC = !tzid || tzid.toUpperCase() === "UTC";
  var header = isUTC ? "".concat(param, ":") : "".concat(param, ";TZID=").concat(tzid, ":");
  var dateString = rdates.map(function(rdate) {
    return dateutil_default.timeToUntilString(rdate.valueOf(), isUTC);
  }).join(",");
  return "".concat(header).concat(dateString);
}

// node_modules/@devexpress/dx-scheduler-core/dist/dx-scheduler-core.es.js
var __assign3 = function() {
  __assign3 = Object.assign || function __assign5(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign3.apply(this, arguments);
};
function __rest2(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __read3(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spreadArray4(to2, from2, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from2.length, ar; i < l; i++) {
      if (ar || !(i in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i);
        ar[i] = from2[i];
      }
    }
  return to2.concat(ar || from2);
}
var computed = function(getters, viewName, baseComputed, defaultValue) {
  if (getters.currentView.name !== viewName && !!defaultValue) {
    return defaultValue;
  }
  return baseComputed(getters, viewName);
};
var toPercentage = function(value, total) {
  return value * 100 / total;
};
var createExcludedInterval = function(day, start) {
  var leftBound = moment_default(start.day(day));
  return [
    leftBound,
    moment_default(leftBound).hour(start.hour()).endOf("day")
  ];
};
var excludedIntervals = function(excludedDays, start) {
  return excludedDays.map(function(day) {
    return day === 0 ? 7 : day;
  }).sort(function(a, b) {
    return a - b;
  }).reduce(function(acc, day, i, allDays) {
    if (i && day === allDays[i - 1] + 1) {
      acc[acc.length - 1][1].day(day);
    } else {
      acc.push(createExcludedInterval(day, start));
    }
    return acc;
  }, []);
};
var inInterval = function(date, interval) {
  return date.isBetween(interval[0], interval[1], void 0, "[]");
};
var viewPredicate = function(appointment, left, right, excludedDays, removeAllDayAppointments) {
  if (excludedDays === void 0) {
    excludedDays = [];
  }
  if (removeAllDayAppointments === void 0) {
    removeAllDayAppointments = false;
  }
  var start = appointment.start, end = appointment.end;
  var isAppointmentInBoundary = end.isAfter(left) && start.isBefore(right);
  var isAppointmentInExcludedDays = !!excludedIntervals(excludedDays, moment_default(left)).find(function(interval) {
    return inInterval(start, interval) && inInterval(end, interval);
  });
  var considerAllDayAppointment = removeAllDayAppointments ? moment_default(end).diff(start, "hours") < 24 && !appointment.allDay : true;
  return isAppointmentInBoundary && !isAppointmentInExcludedDays && considerAllDayAppointment;
};
var calculateFirstDateOfWeek = function(currentDate, firstDayOfWeek, excludedDays) {
  if (excludedDays === void 0) {
    excludedDays = [];
  }
  var currentLocale = moment_default.locale();
  moment_default.updateLocale("tmp-locale", {
    week: { dow: firstDayOfWeek, doy: 1 }
    // `doy` is required for TS using
  });
  var firstDateOfWeek = moment_default(currentDate).startOf("week");
  if (excludedDays.indexOf(firstDayOfWeek) !== -1) {
    excludedDays.slice().sort().forEach(function(day) {
      if (day === firstDateOfWeek.day()) {
        firstDateOfWeek.add(1, "days");
      }
    });
  }
  moment_default.locale(currentLocale);
  return firstDateOfWeek.toDate();
};
var getAppointmentStyle = function(_a2) {
  var top = _a2.top, left = _a2.left, width = _a2.width, height = _a2.height;
  return {
    height,
    width: "".concat(width, "%"),
    transform: "translateY(".concat(top, "px)"),
    msTransform: "translateY(".concat(top, "px)"),
    left: "".concat(left, "%"),
    position: "absolute"
  };
};
var expandRecurrenceAppointment = function(appointment, leftBound, rightBound) {
  var rightBoundUTC = moment_default(getUTCDate(rightBound)).toDate();
  var leftBoundUTC = moment_default(getUTCDate(leftBound)).toDate();
  var appointmentStartDate = moment_default(appointment.start).toDate();
  var options = __assign3(__assign3({}, RRule.parseString(appointment.rRule)), { dtstart: moment_default(getUTCDate(appointmentStartDate)).toDate() });
  var correctedOptions = options.until ? __assign3(__assign3({}, options), { until: moment_default(getUTCDate(options.until)).toDate() }) : options;
  var rruleSet = getRRuleSetWithExDates(appointment.exDate);
  rruleSet.rrule(new RRule(correctedOptions));
  var datesInBoundaries = rruleSet.between(leftBoundUTC, rightBoundUTC, true).map(formatDateToString);
  if (datesInBoundaries.length === 0)
    return [];
  var appointmentDuration = moment_default(appointment.end).diff(appointment.start, "minutes");
  return datesInBoundaries.map(function(startDate, index) {
    return __assign3(__assign3({}, appointment), { dataItem: __assign3(__assign3({}, appointment.dataItem), { startDate: moment_default(startDate).toDate(), endDate: moment_default(startDate).add(appointmentDuration, "minutes").toDate(), parentData: appointment.dataItem }), start: moment_default(startDate), end: moment_default(startDate).add(appointmentDuration, "minutes"), key: "".concat(appointment.key, "_rec_").concat(index) });
  });
};
var filterByViewBoundaries = function(appointment, leftBound, rightBound, excludedDays, removeAllDay) {
  var appointments2 = [appointment];
  if (appointment.rRule) {
    appointments2 = expandRecurrenceAppointment(appointment, leftBound, rightBound);
  }
  return appointments2.filter(function(appt) {
    return viewPredicate(appt, leftBound, rightBound, excludedDays, removeAllDay);
  });
};
var getUTCDate = function(date) {
  return Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes());
};
var getRRuleSetWithExDates = function(exDate) {
  var rruleSet = new RRuleSet();
  if (exDate) {
    exDate.split(",").map(function(date) {
      var currentExDate = moment_default(date).toDate();
      rruleSet.exdate(moment_default(getUTCDate(currentExDate)).toDate());
    });
  }
  return rruleSet;
};
var formatDateToString = function(date) {
  return moment_default.utc(date).format("YYYY-MM-DDTHH:mm");
};
var addDateToKey = function(prevKey, momentDate) {
  return "".concat(prevKey, "_").concat(momentDate.toDate().toString());
};
var VERTICAL_TYPE = "vertical";
var HORIZONTAL_TYPE = "horizontal";
var SCROLL_OFFSET2 = 50;
var SCROLL_SPEED_PX = 15;
var SECONDS = "seconds";
var MINUTES = "minutes";
var HOURS = "hours";
var RESIZE_TOP = "resize-start";
var RESIZE_BOTTOM = "resize-end";
var POSITION_START = "start";
var POSITION_END = "end";
var AUTO_HEIGHT = "auto";
var DAY_OPTIONS = { day: "numeric" };
var WEEK_DAY_OPTIONS = { weekday: "short" };
var SHORT_MONTH_OPTIONS = { month: "short" };
var HOUR_MINUTE_OPTIONS = { hour: "numeric", minute: "numeric" };
var MONTH_YEAR_OPTIONS = { month: "long", year: "numeric" };
var DAY_SHORT_MONTH_OPTIONS = { day: "numeric", month: "short" };
var SHORT_MONTH_LONG_YEAR_OPTIONS = { month: "short", year: "numeric" };
var SHORT_MONTH_SHORT_YEAR_OPTIONS = { month: "short", year: "2-digit" };
var DAY_LONG_MONTH_LONG_YEAR_OPTIONS = {
  day: "numeric",
  month: "long",
  year: "numeric"
};
var DAY_SHORT_MONTH_LONG_YEAR_OPTIONS = {
  day: "numeric",
  month: "short",
  year: "numeric"
};
var DAY_SHORT_MONTH_SHORT_YEAR_OPTIONS = {
  day: "numeric",
  month: "short",
  year: "2-digit"
};
var LONG_WEEK_DAY_OPTIONS = { weekday: "long" };
var LONG_MONTH_OPTIONS = { month: "long" };
var DAY_LONG_MONTH_OPTIONS = { day: "numeric", month: "long" };
var EMPTY_OPTIONS = {};
var RECURRENCE_EDIT_SCOPE = {
  ALL: "all",
  CURRENT_AND_FOLLOWING: "currentAndFollowing",
  CURRENT: "current"
};
var TOGGLE_APPOINTMENT_FORM_VISIBILITY = "toggleAppointmentFormVisibility";
var TOGGLE_APPOINTMENT_TOOLTIP_VISIBILITY = "toggleAppointmentTooltipVisibility";
var WEEKDAY_INTERVAL = "weekdayInterval";
var VERTICAL_VIEW_LEFT_OFFSET = 80;
var HORIZONTAL_VIEW_LEFT_OFFSET = 0;
var VERTICAL_GROUP_ORIENTATION = "Vertical";
var HORIZONTAL_GROUP_ORIENTATION = "Horizontal";
var VIEW_TYPES = {
  MONTH: "month",
  WEEK: "week",
  DAY: "day",
  ALL_DAY_PANEL: "allDayPanel"
};
var isMidnight = function(date) {
  var momentDate = moment_default(date);
  return momentDate.hours() === 0 && momentDate.minutes() === 0 && momentDate.seconds() === 0;
};
var calculateTextByDays = function(startViewDate2, endViewDate2, formatDate, additionalOptions) {
  var momentStartViewDate = moment_default(startViewDate2);
  var momentEndViewDate = moment_default(endViewDate2);
  if (momentStartViewDate.isSame(momentEndViewDate, "day")) {
    return formatDate(momentStartViewDate.toDate(), __assign3(__assign3({}, DAY_LONG_MONTH_LONG_YEAR_OPTIONS), additionalOptions));
  }
  if (momentStartViewDate.isSame(momentEndViewDate, "year")) {
    if (momentStartViewDate.isSame(momentEndViewDate, "month")) {
      return "".concat(formatDate(momentStartViewDate.toDate(), DAY_OPTIONS), "-").concat(formatDate(momentEndViewDate.toDate(), DAY_OPTIONS), " ").concat(formatDate(momentEndViewDate.toDate(), MONTH_YEAR_OPTIONS));
    }
    return "".concat(formatDate(momentStartViewDate.toDate(), DAY_SHORT_MONTH_OPTIONS), " - ").concat(formatDate(momentEndViewDate.toDate(), DAY_SHORT_MONTH_LONG_YEAR_OPTIONS));
  }
  return "".concat(formatDate(momentStartViewDate.toDate(), DAY_SHORT_MONTH_SHORT_YEAR_OPTIONS), " - ").concat(formatDate(momentEndViewDate.toDate(), DAY_SHORT_MONTH_SHORT_YEAR_OPTIONS));
};
var calculateTextByMonths = function(currentDate, intervalCount, formatDate) {
  var momentCurrentDate = moment_default(currentDate);
  if (intervalCount === 1) {
    return formatDate(momentCurrentDate.toDate(), MONTH_YEAR_OPTIONS);
  }
  var lastMonth = momentCurrentDate.clone().add(intervalCount - 1, "month");
  if (momentCurrentDate.isSame(lastMonth, "year")) {
    return "".concat(formatDate(momentCurrentDate.toDate(), SHORT_MONTH_OPTIONS), "-").concat(formatDate(lastMonth.toDate(), SHORT_MONTH_LONG_YEAR_OPTIONS));
  }
  return "".concat(formatDate(momentCurrentDate.toDate(), SHORT_MONTH_SHORT_YEAR_OPTIONS), " - ").concat(formatDate(lastMonth.toDate(), SHORT_MONTH_SHORT_YEAR_OPTIONS));
};
var viewBoundText = function(startViewDate2, endViewDate2, type, currentDate, intervalCount, formatDate) {
  return type !== "month" ? calculateTextByDays(startViewDate2, endViewDate2, formatDate, type === WEEKDAY_INTERVAL ? LONG_WEEK_DAY_OPTIONS : EMPTY_OPTIONS) : calculateTextByMonths(currentDate, intervalCount, formatDate);
};
var checkCellGroupingInfo = function(cell, appointment) {
  return cell.groupingInfo ? cell.groupingInfo.every(function(group) {
    return group.id === appointment[group.fieldName];
  }) : true;
};
var isDateValid = function(date) {
  return moment_default(date).isValid();
};
var convertToMoment = function(date) {
  return moment_default(date);
};
var areDatesSame = function(firstDate, secondDate) {
  return moment_default(firstDate).isSame(secondDate, "date");
};
var getTimeTableHeight = function(timeTableElementsMeta) {
  var _a2;
  return (_a2 = timeTableElementsMeta.parentRect) === null || _a2 === void 0 ? void 0 : _a2.call(timeTableElementsMeta).height;
};
var containsDSTChange = function(date) {
  var momentDate = moment_default(date);
  momentDate.startOf("day");
  var isStartDST = momentDate.isDST();
  momentDate.endOf("day");
  var isEndDst = momentDate.isDST();
  return isStartDST && !isEndDst || !isStartDST && isEndDst;
};
var subtractSecond = function(date) {
  return moment_default(date).subtract(1, "second").toDate();
};
var dayScale = function(currentDate, firstDayOfWeek, dayCount, excluded) {
  if (excluded === void 0) {
    excluded = [];
  }
  var result = [];
  var date = firstDayOfWeek !== void 0 ? moment_default(calculateFirstDateOfWeek(currentDate, firstDayOfWeek, excluded)) : moment_default(currentDate);
  for (var index = 0; index < dayCount; index += 1) {
    if (excluded.findIndex(function(item) {
      return item === date.day();
    }) === -1) {
      result.push(date.toDate());
    }
    date.add(1, "days");
  }
  return result;
};
var timeScale = function(currentDate, firstDayOfWeek, startDayHour, endDayHour, cellDuration, excludedDays) {
  var result = [];
  var startDateOfView = firstDayOfWeek !== void 0 ? calculateFirstDateOfWeek(currentDate, firstDayOfWeek, excludedDays) : currentDate;
  var isDSTChange = containsDSTChange(startDateOfView);
  var validDate = moment_default(startDateOfView);
  if (isDSTChange) {
    validDate.subtract(1, "day");
  }
  var left = moment_default(validDate).startOf("day").add(startDayHour, "hour");
  var right = moment_default(validDate).startOf("day").add(endDayHour, "hour");
  while (left.isBefore(right)) {
    var startDate = left.toDate();
    left.add(cellDuration, "minutes");
    result.push({ start: startDate, end: left.toDate() });
  }
  var timeScaleLastIndex = result.length - 1;
  if (isMidnight(result[timeScaleLastIndex].end)) {
    result[timeScaleLastIndex].end = subtractSecond(result[timeScaleLastIndex].end);
  }
  return result;
};
var availableViews = function(views, viewName, viewDisplayName) {
  if (!views)
    return [{ name: viewName, displayName: viewDisplayName }];
  if (views.findIndex(function(view) {
    return viewName === view.name;
  }) === -1) {
    var nextViews = views.slice();
    nextViews.push({ name: viewName, displayName: viewDisplayName });
    return nextViews;
  }
  return views;
};
var viewCellsData = function(currentDate, firstDayOfWeek, dayCount, excludedDays, startDayHour, endDayHour, cellDuration, currTime) {
  var days2 = dayScale(currentDate, firstDayOfWeek, dayCount, excludedDays);
  var times = timeScale(currentDate, firstDayOfWeek, startDayHour, endDayHour, cellDuration, excludedDays);
  var currentTime = moment_default(currTime);
  return times.reduce(function(cellsAcc, time) {
    var start = moment_default(time.start);
    var end = moment_default(time.end);
    var rowCells = days2.reduce(function(rowAcc, day) {
      var startDate = moment_default(day).hours(start.hours()).minutes(start.minutes()).toDate();
      var endDate = moment_default(day).hours(end.hours()).minutes(end.minutes()).toDate();
      var today = currentTime.isSame(startDate, "day");
      rowAcc.push({ startDate, endDate, today });
      return rowAcc;
    }, []);
    cellsAcc.push(rowCells);
    return cellsAcc;
  }, []);
};
var timeCellsData = function(cellsData, startDayHour, endDayHour, cellDuration, currentTime) {
  var firstViewDate = cellsData[0][0].startDate;
  if (!containsDSTChange(firstViewDate)) {
    return cellsData;
  }
  var nextDay = moment_default(firstViewDate).add(1, "day").toDate();
  var validCellsData = viewCellsData(nextDay, void 0, 1, [], startDayHour, endDayHour, cellDuration, currentTime);
  return validCellsData;
};
var allDayCells = function(viewCells) {
  return [viewCells[0].map(function(cell) {
    return {
      startDate: moment_default(cell.startDate).startOf("day").toDate(),
      endDate: moment_default(cell.startDate).add(1, "day").startOf("day").toDate(),
      groupingInfo: cell.groupingInfo,
      endOfGroup: cell.endOfGroup
    };
  })];
};
var startViewDate = function(viewCells) {
  return moment_default(viewCells[0][0].startDate).toDate();
};
var endViewDate = function(viewCells) {
  var lastRowIndex = viewCells.length - 1;
  var lastCellIndex = viewCells[lastRowIndex].length - 1;
  return subtractSecond(viewCells[lastRowIndex][lastCellIndex].endDate);
};
var MAX_WIDTH = 1;
var INDIRECT_CHILD_LEFT_OFFSET = 0.05;
var isAllDayElementsMetaActual = function(viewCellsData2, allDayElementsMeta, groupOrientation, groupCount) {
  var numberOfRows = groupOrientation === HORIZONTAL_GROUP_ORIENTATION ? 1 : groupCount;
  return isElementsMetaActual(viewCellsData2, allDayElementsMeta, numberOfRows);
};
var isTimeTableElementsMetaActual = function(viewCellsData2, timeTableElementsMeta) {
  return isElementsMetaActual(viewCellsData2, timeTableElementsMeta, viewCellsData2.length);
};
var isElementsMetaActual = function(viewCellsData2, elementsMeta, numberOfRows) {
  if (!(elementsMeta === null || elementsMeta === void 0 ? void 0 : elementsMeta.getCellRects)) {
    return false;
  }
  var tableSize = numberOfRows * viewCellsData2[0].length;
  return tableSize === elementsMeta.getCellRects.length;
};
var appointmentHeightType = function(appointment, cellDuration) {
  var durationRatio = appointment.end.clone().diff(appointment.start, "minutes") / cellDuration;
  if (durationRatio === 1)
    return "middle";
  if (durationRatio > 1)
    return "long";
  return "short";
};
var horizontalRectCalculator = function(appointment, viewMetaData, _a2) {
  var getRectByAppointment = _a2.rectByDates, multiline = _a2.multiline, _b = _a2.rectByDatesMeta, cellElementsMeta = _b.cellElementsMeta, viewCellsData2 = _b.viewCellsData;
  var _c = getRectByAppointment(appointment, viewMetaData, {
    multiline,
    cellElementsMeta,
    viewCellsData: viewCellsData2
  }), top = _c.top, left = _c.left, width = _c.width, height = _c.height, parentWidth = _c.parentWidth;
  return {
    resources: appointment.resources,
    top: top + height / appointment.reduceValue * appointment.offset,
    height: height / appointment.reduceValue,
    left: toPercentage(left, parentWidth),
    width: toPercentage(width, parentWidth),
    dataItem: appointment.dataItem,
    fromPrev: appointment.fromPrev,
    toNext: appointment.toNext,
    type: HORIZONTAL_TYPE,
    key: appointment.key
  };
};
var verticalRectCalculator = function(appointment, viewMetaData, _a2) {
  var getRectByAppointment = _a2.rectByDates, multiline = _a2.multiline, _b = _a2.rectByDatesMeta, viewCellsData2 = _b.viewCellsData, cellDuration = _b.cellDuration, cellElementsMeta = _b.cellElementsMeta, excludedDays = _b.excludedDays;
  var _c = getRectByAppointment(appointment, viewMetaData, {
    multiline,
    viewCellsData: viewCellsData2,
    cellDuration,
    excludedDays,
    cellElementsMeta
  }), top = _c.top, left = _c.left, width = _c.width, height = _c.height, parentWidth = _c.parentWidth;
  var offset2 = appointment.offset, relativeWidth = appointment.width, relativeLeft = appointment.left;
  var widthMultiplier = relativeWidth * 5 / 3 + relativeLeft <= 1 ? 5 / 3 : 1;
  var validWidth = widthMultiplier === 5 / 3 ? widthMultiplier * relativeWidth : relativeWidth + 0.02;
  if (validWidth + relativeLeft > 1) {
    validWidth = 1 - relativeLeft;
  }
  return {
    resources: appointment.resources,
    top,
    height,
    left: toPercentage(left + relativeLeft * width, parentWidth),
    width: toPercentage(validWidth * width, parentWidth),
    dataItem: appointment.dataItem,
    fromPrev: appointment.fromPrev,
    toNext: appointment.toNext,
    durationType: appointmentHeightType(appointment, cellDuration),
    type: VERTICAL_TYPE,
    offset: offset2,
    key: appointment.key
  };
};
var oldVerticalRectCalculator = function(appointment, viewMetaData, _a2) {
  var getRectByAppointment = _a2.rectByDates, multiline = _a2.multiline, _b = _a2.rectByDatesMeta, viewCellsData2 = _b.viewCellsData, cellDuration = _b.cellDuration, cellElementsMeta = _b.cellElementsMeta, excludedDays = _b.excludedDays, placeAppointmentsNextToEachOther = _b.placeAppointmentsNextToEachOther;
  var _c = getRectByAppointment(appointment, viewMetaData, {
    multiline,
    viewCellsData: viewCellsData2,
    cellDuration,
    excludedDays,
    cellElementsMeta,
    placeAppointmentsNextToEachOther
  }), top = _c.top, left = _c.left, width = _c.width, height = _c.height, parentWidth = _c.parentWidth;
  var widthInPx = width / appointment.reduceValue;
  return {
    resources: appointment.resources,
    top,
    height,
    left: toPercentage(left + widthInPx * appointment.offset, parentWidth),
    width: toPercentage(widthInPx, parentWidth),
    dataItem: appointment.dataItem,
    fromPrev: appointment.fromPrev,
    toNext: appointment.toNext,
    durationType: appointmentHeightType(appointment, cellDuration),
    type: VERTICAL_TYPE,
    key: appointment.key
  };
};
var compareByDay = function(first, second) {
  if (first.start.isBefore(second.start, "day"))
    return -1;
  if (first.start.isAfter(second.start, "day"))
    return 1;
  return 0;
};
var compareByAllDay = function(first, second) {
  if (first.allDay && !second.allDay)
    return -1;
  if (!first.allDay && second.allDay)
    return 1;
  return 0;
};
var compareByTime = function(first, second) {
  if (first.start.isBefore(second.start))
    return -1;
  if (first.start.isAfter(second.start))
    return 1;
  if (first.end.isBefore(second.end))
    return 1;
  if (first.end.isAfter(second.end))
    return -1;
  return 0;
};
var sortAppointments = function(appointments2) {
  return appointments2.slice().sort(function(a, b) {
    return compareByDay(a, b) || compareByAllDay(a, b) || compareByTime(a, b);
  });
};
var byDayPredicate = function(boundary, date) {
  return boundary.isSameOrAfter(date, "day") && !boundary.isSame(boundary.clone().startOf("day"));
};
var findOverlappedAppointments = function(sortedAppointments, byDay) {
  if (byDay === void 0) {
    byDay = false;
  }
  var appointments2 = sortedAppointments.slice();
  var groups = [];
  var totalIndex = 0;
  while (totalIndex < appointments2.length) {
    groups.push([]);
    var current = appointments2[totalIndex];
    var currentGroup = groups[groups.length - 1];
    var next = appointments2[totalIndex + 1];
    var maxBoundary = current.end;
    currentGroup.push(current);
    totalIndex += 1;
    while (next && (maxBoundary.isAfter(next.start) || byDay && byDayPredicate(maxBoundary, next.start))) {
      currentGroup.push(next);
      if (maxBoundary.isBefore(next.end))
        maxBoundary = next.end;
      totalIndex += 1;
      next = appointments2[totalIndex];
    }
  }
  return groups;
};
var isMidnight$1 = function(date) {
  return date.isSame(date.clone().startOf("day"));
};
var maxBoundaryPredicate = function(maxBoundary, startDate) {
  return maxBoundary.isBefore(startDate, "day") || isMidnight$1(maxBoundary) && maxBoundary.isSame(startDate, "day");
};
var calculateAppointmentOffsets = function(groups, byDay) {
  if (byDay === void 0) {
    byDay = false;
  }
  return groups.map(function(items) {
    var offset2 = 0;
    var reduceValue = 1;
    var appointments2 = items.map(function(appointment2) {
      return __assign3({}, appointment2);
    });
    var groupLength = appointments2.length;
    for (var startIndex = 0; startIndex < groupLength; startIndex += 1) {
      var appointment = appointments2[startIndex];
      if (appointment.offset === void 0) {
        var maxBoundary = appointment.end;
        appointment.offset = offset2;
        for (var index = startIndex + 1; index < groupLength; index += 1) {
          if (appointments2[index].offset === void 0) {
            if (!byDay && maxBoundary.isSameOrBefore(appointments2[index].start) || byDay && maxBoundaryPredicate(maxBoundary, appointments2[index].start)) {
              maxBoundary = appointments2[index].end;
              appointments2[index].offset = offset2;
            }
          }
        }
        offset2 += 1;
        if (reduceValue < offset2)
          reduceValue = offset2;
      }
    }
    return { items: appointments2, reduceValue };
  });
};
var unwrapAppointmentForest = function(appointmentForests) {
  var forestUnwrapped = appointmentForests.map(function(_a2) {
    var items = _a2.items, reduceValue = _a2.reduceValue;
    return {
      reduceValue,
      items: items.map(function(_a3) {
        var data = _a3.data;
        return __assign3({}, data);
      })
    };
  });
  return unwrapGroups(forestUnwrapped);
};
var unwrapGroups = function(groups) {
  return groups.reduce(function(acc, _a2) {
    var items = _a2.items, reduceValue = _a2.reduceValue;
    acc.push.apply(acc, __spreadArray4([], __read3(items.map(function(_a3) {
      var start = _a3.start, end = _a3.end, dataItem = _a3.dataItem, offset2 = _a3.offset, resources = _a3.resources, key = _a3.key, restProps = __rest2(_a3, ["start", "end", "dataItem", "offset", "resources", "key"]);
      return __assign3({ start, end, dataItem, offset: offset2, reduceValue, resources, fromPrev: moment_default(start).diff(dataItem.startDate, "minutes") > 1, toNext: moment_default(dataItem.endDate).diff(end, "minutes") > 1, key }, restProps);
    })), false));
    return acc;
  }, []);
};
var intervalIncludes = function(intervalStart, intervalEnd, date) {
  return date.isBetween(intervalStart, intervalEnd, void 0, "[)");
};
var createAppointmentForest = function(appointmentGroups, cellDuration) {
  return appointmentGroups.map(function(appointmentGroup) {
    var items = appointmentGroup.items;
    var nextItems;
    var roots;
    if (items.length === 1) {
      nextItems = [{
        data: items[0],
        children: [],
        treeDepth: 0,
        isDirectChild: false,
        hasDirectChild: false
      }];
      roots = [0];
    } else {
      var _a2 = visitRoots(items, cellDuration), appointments2 = _a2.appointments, appointmentTreeRoots = _a2.roots;
      nextItems = appointments2;
      roots = appointmentTreeRoots;
    }
    return __assign3(__assign3({}, appointmentGroup), { items: nextItems, roots });
  });
};
var visitRoots = function(appointmentItems, cellDuration) {
  var appointmentNodes = appointmentItems.map(function(props) {
    return {
      data: props
    };
  });
  var roots = appointmentNodes.reduce(function(acc, appointment, appointmentIndex) {
    var appointmentOffset = appointment.data.offset;
    if (appointmentOffset === 0) {
      if (appointmentIndex + 1 === appointmentNodes.length) {
        appointment.children = [];
        appointment.hasDirectChild = false;
        appointment.treeDepth = 0;
      } else {
        appointment.treeDepth = visitAllChildren(appointmentNodes, appointmentIndex, cellDuration, 0);
      }
      appointment.parent = void 0;
      appointment.isDirectChild = false;
      return __spreadArray4(__spreadArray4([], __read3(acc), false), [appointmentIndex], false);
    }
    return acc;
  }, []);
  return { appointments: appointmentNodes, roots };
};
var visitChild = function(appointmentNodes, index, parentAppointmentIndex, cellDuration, isDirectChild, treeDepth) {
  var appointmentNode = appointmentNodes[index];
  appointmentNode.isDirectChild = isDirectChild;
  appointmentNode.parent = parentAppointmentIndex;
  var nextTreeDepth = treeDepth + 1;
  var end = appointmentNode.data.end;
  if (index === appointmentNodes.length - 1 || end.isSameOrBefore(appointmentNodes[index + 1].data.start)) {
    appointmentNode.children = [];
    appointmentNode.treeDepth = 0;
    appointmentNode.hasDirectChild = false;
    return nextTreeDepth;
  }
  var calculatedTreeDepth = visitAllChildren(appointmentNodes, index, cellDuration, treeDepth);
  appointmentNode.treeDepth = calculatedTreeDepth;
  return calculatedTreeDepth + 1;
};
var visitAllChildren = function(appointmentNodes, appointmentIndex, cellDuration, treeDepth) {
  var appointment = appointmentNodes[appointmentIndex];
  var _a2 = appointment.data, end = _a2.end, appointmentOffset = _a2.offset, start = _a2.start;
  var directChildTimeLimit = moment_default(start).add(cellDuration, "minutes");
  var maxAppointmentTreeDepth = 0;
  var children = [];
  var nextChildIndex = appointmentIndex + 1;
  while (isPossibleChild(appointmentNodes, nextChildIndex, end, appointmentOffset)) {
    var nextAppointment = appointmentNodes[nextChildIndex];
    var _b = nextAppointment.data, nextOffset = _b.offset, nextStart = _b.start;
    if (nextOffset === appointmentOffset + 1) {
      var isDirectChild = intervalIncludes(start, directChildTimeLimit, nextStart);
      var nextTreeDepth = visitChild(appointmentNodes, nextChildIndex, appointmentIndex, cellDuration, isDirectChild, treeDepth);
      if (maxAppointmentTreeDepth < nextTreeDepth) {
        maxAppointmentTreeDepth = nextTreeDepth;
      }
      children.push(nextChildIndex);
    }
    nextChildIndex += 1;
  }
  appointment.hasDirectChild = children.length !== 0 && appointmentNodes[children[0]].isDirectChild;
  appointment.children = children;
  return maxAppointmentTreeDepth;
};
var isPossibleChild = function(appointments2, possibleChildIndex, parentEnd, parentOffset) {
  var possibleChild = appointments2[possibleChildIndex];
  return possibleChildIndex < appointments2.length && possibleChild.data.offset !== parentOffset && possibleChild.data.start.isBefore(parentEnd);
};
var findMaxReduceValue = function(appointmentGroups) {
  return appointmentGroups.reduce(function(maxReduceValue, group) {
    var currentReduceValue = group.reduceValue;
    return maxReduceValue > currentReduceValue ? maxReduceValue : currentReduceValue;
  }, 1);
};
var calculateAppointmentsMetaData = function(appointmentGroups, indirectChildLeftOffset) {
  return appointmentGroups.map(function(appointmentForest) {
    var items = appointmentForest.items, roots = appointmentForest.roots;
    var firstNode = items[0];
    return __assign3(__assign3({}, appointmentForest), { items: items.length === 1 ? [__assign3(__assign3({}, firstNode), { data: __assign3(__assign3({}, firstNode.data), { left: 0, width: 1 }) })] : calculateRootsMetaData(items, roots, indirectChildLeftOffset) });
  });
};
var calculateRootsMetaData = function(appointmentNodes, roots, indirectChildLeftOffset) {
  var appointments2 = appointmentNodes.map(function(props) {
    return __assign3({}, props);
  });
  roots.forEach(function(appointmentIndex) {
    var appointment = appointments2[appointmentIndex];
    var _a2 = calculateAppointmentLeftAndWidth(appointments2, void 0, appointment, MAX_WIDTH, indirectChildLeftOffset, void 0), left = _a2.left, width = _a2.width;
    appointment.data.left = left;
    appointment.data.width = width;
    calculateChildrenMetaData(appointments2, appointment, MAX_WIDTH, indirectChildLeftOffset);
  });
  return appointments2;
};
var calculateChildMetaData = function(appointmentNodes, appointmentIndex, maxWidth, indirectChildLeftOffset) {
  var appointment = appointmentNodes[appointmentIndex];
  var _a2 = calculateAppointmentLeftAndWidth(appointmentNodes, void 0, appointment, maxWidth, indirectChildLeftOffset, void 0), left = _a2.left, width = _a2.width;
  appointment.data.left = left;
  appointment.data.width = width;
  calculateChildrenMetaData(appointmentNodes, appointment, maxWidth, indirectChildLeftOffset);
};
var calculateChildrenMetaData = function(appointmentNodes, appointmentNode, maxWidth, indirectChildLeftOffset) {
  appointmentNode.children.forEach(function(childIndex) {
    calculateChildMetaData(appointmentNodes, childIndex, maxWidth, indirectChildLeftOffset);
  });
};
var calculateAppointmentLeftAndWidth = function(appointmentNodes, blocks, appointmentNode, maxRight, indirectChildLeftOffset, defaultLeft) {
  var _a2 = appointmentNode, hasDirectChild = _a2.hasDirectChild, treeDepth = _a2.treeDepth, isDirectChild = _a2.isDirectChild, parentIndex = _a2.parent, children = _a2.children, blockIndex = _a2.blockIndex;
  var firstChild = appointmentNodes[children[0]];
  var firstChildBlockIndex = firstChild === null || firstChild === void 0 ? void 0 : firstChild.blockIndex;
  var hasDirectChildAndInSameBlock = hasDirectChild && (firstChildBlockIndex === void 0 || (blockIndex === firstChildBlockIndex || blocks[firstChildBlockIndex].includedInto === blockIndex || maxRight === 1));
  if (parentIndex === void 0) {
    return {
      width: hasDirectChildAndInSameBlock ? maxRight / (treeDepth + 1) : maxRight,
      left: 0
    };
  }
  var parent = appointmentNodes[parentIndex];
  var _b = parent.data, parentWidth = _b.width, parentLeft = _b.left;
  var calculatedLeft = isDirectChild ? parentLeft + parentWidth : parentLeft + indirectChildLeftOffset;
  var left = defaultLeft !== void 0 ? Math.max(defaultLeft, calculatedLeft) : calculatedLeft;
  var unoccupiedSpace = maxRight - left;
  return {
    width: hasDirectChildAndInSameBlock ? unoccupiedSpace / (treeDepth + 1) : unoccupiedSpace,
    left
  };
};
var prepareToGroupIntoBlocks = function(appointments2) {
  return appointments2.map(function(appointmentForest) {
    var nodes = appointmentForest.items;
    var appointmentNodes = nodes.map(function(props) {
      return __assign3({}, props);
    });
    appointmentNodes.forEach(function(appointmentNode, index) {
      if (index === 0) {
        appointmentNode.overlappingSubTreeRoots = [];
        return;
      }
      var overlappingSubTreeRoots = [];
      var _a2 = appointmentNode.data, appointmentOffset = _a2.offset, end = _a2.end;
      var nextChildIndex = index + 1;
      var currentBlockEnd;
      while (isPossibleChild(appointmentNodes, nextChildIndex, end, appointmentOffset)) {
        var nextAppointment = appointmentNodes[nextChildIndex];
        if (nextAppointment.data.offset < appointmentOffset && nextAppointment.maxOffset === void 0) {
          nextAppointment.maxOffset = appointmentOffset;
        }
        var previousSubTreeRoot = overlappingSubTreeRoots.length > 0 ? appointmentNodes[overlappingSubTreeRoots[overlappingSubTreeRoots.length - 1]] : void 0;
        if (isOverlappingSubTreeRoot(appointmentNode, nextAppointment, previousSubTreeRoot, currentBlockEnd)) {
          overlappingSubTreeRoots.push(nextChildIndex);
          nextAppointment.overlappingSubTreeRoot = true;
          var maxChildDate = findChildrenMaxEndDate(appointmentNodes, nextAppointment);
          if (!currentBlockEnd || currentBlockEnd.isBefore(maxChildDate)) {
            currentBlockEnd = maxChildDate;
          }
        }
        nextChildIndex += 1;
      }
      appointmentNode.overlappingSubTreeRoots = overlappingSubTreeRoots;
    });
    return __assign3(__assign3({}, appointmentForest), { items: appointmentNodes });
  });
};
var isOverlappingSubTreeRoot = function(appointmentNode, nextAppointment, previousSubTreeRoot, previousEndDate) {
  var overlappingSubTreeRoot = nextAppointment.overlappingSubTreeRoot, maxOffset = nextAppointment.maxOffset, nextData = nextAppointment.data;
  var nextOffset = nextData.offset, nextStart = nextData.start;
  var offset2 = appointmentNode.data.offset;
  return nextOffset < offset2 && !overlappingSubTreeRoot && (maxOffset === void 0 || maxOffset >= offset2) && (!previousSubTreeRoot || previousSubTreeRoot.data.offset >= nextOffset && nextStart.isSameOrAfter(previousEndDate));
};
var findChildrenMaxEndDate = function(appointmentNodes, appointmentNode) {
  var children = appointmentNode.children, data = appointmentNode.data;
  var end = data.end;
  var maxDate = children.reduce(function(currentMaxDate, childIndex) {
    var child = appointmentNodes[childIndex];
    var maxChildrenDate = findChildrenMaxEndDate(appointmentNodes, child);
    if (maxChildrenDate.isAfter(currentMaxDate)) {
      return maxChildrenDate;
    }
    return currentMaxDate;
  }, end);
  return maxDate;
};
var groupAppointmentsIntoBlocks = function(appointmentForests) {
  return appointmentForests.map(function(appointmentForest) {
    var items = appointmentForest.items, reduceValue = appointmentForest.reduceValue;
    var _a2 = items.reduce(function(acc, appointment, index) {
      var blocks = acc.blocks.slice();
      var treeDepth = appointment.treeDepth, data = appointment.data, overlappingSubTreeRoots = appointment.overlappingSubTreeRoots;
      var offset2 = data.offset, start = data.start, end = data.end;
      var blockIndex = findBlockIndexByAppointment(blocks, appointment);
      if (blockIndex < 0) {
        blocks.push({
          start,
          end,
          minOffset: offset2,
          maxOffset: offset2 + treeDepth,
          size: treeDepth + 1,
          items: [],
          endForChildren: end
        });
        blockIndex = blocks.length - 1;
      }
      blocks[blockIndex].items.push(index);
      overlappingSubTreeRoots.forEach(function(subTreeRootIndex) {
        var subTreeRoot = items[subTreeRootIndex];
        var subTreeRootData = subTreeRoot.data;
        blocks.push({
          start: subTreeRootData.start,
          end,
          minOffset: subTreeRootData.offset,
          maxOffset: offset2 - 1,
          size: calculateBlockSizeByEndDate(items, subTreeRoot, end),
          items: [],
          endForChildren: subTreeRootData.end
        });
      });
      var appointmentInBlock = __assign3(__assign3({}, appointment), { blockIndex });
      return {
        blocks,
        appointments: __spreadArray4(__spreadArray4([], __read3(acc.appointments), false), [appointmentInBlock], false)
      };
    }, {
      blocks: [{
        start: items[0].data.start,
        end: items[0].data.end,
        minOffset: 0,
        maxOffset: reduceValue - 1,
        size: reduceValue,
        items: [],
        endForChildren: items[0].data.end
      }],
      appointments: []
    }), nextBlocks = _a2.blocks, appointments2 = _a2.appointments;
    return {
      blocks: nextBlocks,
      appointmentForest: __assign3(__assign3({}, appointmentForest), { items: appointments2 })
    };
  });
};
var calculateBlockSizeByEndDate = function(appointmentNodes, subTreeRoot, blockEndDate) {
  var children = subTreeRoot.children, data = subTreeRoot.data;
  var start = data.start;
  if (children.length === 0) {
    if (blockEndDate.isAfter(start)) {
      return 1;
    }
    return 0;
  }
  var maxSize = Math.max.apply(Math, __spreadArray4([], __read3(children.map(function(childIndex) {
    return calculateBlockSizeByEndDate(appointmentNodes, appointmentNodes[childIndex], blockEndDate);
  })), false));
  if (blockEndDate.isSameOrBefore(start) && maxSize === 0) {
    return 0;
  }
  return maxSize + 1;
};
var findBlockIndexByAppointment = function(blocks, appointment) {
  var _a2 = appointment.data, start = _a2.start, offset2 = _a2.offset;
  var blockIndex = blocks.length - 1;
  while (blockIndex >= 0) {
    var currentBlock = blocks[blockIndex];
    if (intervalIncludes(currentBlock.start, currentBlock.end, start) && offset2 >= currentBlock.minOffset && offset2 <= currentBlock.maxOffset && (!appointment.overlappingSubTreeRoot || appointment.overlappingSubTreeRoot && !currentBlock.items.length)) {
      break;
    }
    blockIndex -= 1;
  }
  return blockIndex;
};
var findIncludedBlocks = function(groupedIntoBlocks) {
  return groupedIntoBlocks.map(function(_a2) {
    var blocks = _a2.blocks, appointmentForest = _a2.appointmentForest;
    var nextBlocks = blocks.map(function(props) {
      return __assign3({}, props);
    });
    nextBlocks.forEach(function(block, blockIndex) {
      block.includedBlocks = [];
      for (var currentBlockIndex = blockIndex + 1; currentBlockIndex < nextBlocks.length; currentBlockIndex += 1) {
        var currentBlock = nextBlocks[currentBlockIndex];
        if (isIncludedBlock(block, currentBlock)) {
          block.includedBlocks.push(currentBlockIndex);
          currentBlock.includedInto = blockIndex;
        }
      }
    });
    return {
      blocks: nextBlocks,
      appointmentForest
    };
  });
};
var isIncludedBlock = function(block, possibleIncludedBlock) {
  var start = block.start, end = block.end, minOffset = block.minOffset, maxOffset = block.maxOffset;
  var possibleIncludedStart = possibleIncludedBlock.start, possibleIncludedEnd = possibleIncludedBlock.end, possibleMinOffset = possibleIncludedBlock.minOffset, possibleMaxOffset = possibleIncludedBlock.maxOffset;
  return intervalIncludes(start, end, possibleIncludedStart) && intervalIncludes(start, end, possibleIncludedEnd) && possibleMaxOffset <= maxOffset && possibleMinOffset >= minOffset;
};
var findChildBlocks = function(groupedIntoBlocks) {
  return groupedIntoBlocks.map(function(_a2) {
    var blocks = _a2.blocks, appointmentForest = _a2.appointmentForest;
    var nextBlocks = blocks.map(function(props) {
      return __assign3({}, props);
    });
    nextBlocks.forEach(function(block, index) {
      block.children = [];
      for (var currentIndex = index + 1; currentIndex < nextBlocks.length; currentIndex += 1) {
        var nextBlock = nextBlocks[currentIndex];
        if (isChildBlock(block, nextBlock)) {
          block.children.push(currentIndex);
          nextBlock.parent = index;
        }
      }
      return block;
    });
    return {
      appointmentForest,
      blocks: nextBlocks
    };
  });
};
var isChildBlock = function(block, possibleChildBlock) {
  var start = block.start, endForChildren = block.endForChildren, minOffset = block.minOffset, includedInto = block.includedInto;
  var childStart = possibleChildBlock.start, childIncludedInto = possibleChildBlock.includedInto, childMaxOffset = possibleChildBlock.maxOffset;
  return intervalIncludes(start, endForChildren, childStart) && childMaxOffset + 1 === minOffset && (childIncludedInto === void 0 || childIncludedInto === includedInto);
};
var adjustByBlocks = function(groupedIntoBlocks, indirectChildLeftOffset) {
  var updatedBlocks = groupedIntoBlocks.map(function(_a2) {
    var blocks = _a2.blocks, appointmentForest = _a2.appointmentForest;
    var dimensionsCalculated = calculateBlocksDimensions(blocks, appointmentForest.items);
    return {
      blocks: alignBlocksWithPrevious(dimensionsCalculated, appointmentForest.items),
      appointmentForest
    };
  });
  var adjustedByBlocks = updatedBlocks.map(function(_a2) {
    var blocks = _a2.blocks, appointmentForest = _a2.appointmentForest;
    return __assign3(__assign3({}, appointmentForest), { items: adjustAppointmentsByBlocks(appointmentForest.items, blocks, indirectChildLeftOffset) });
  });
  return adjustedByBlocks;
};
var calculateBlocksDimensions = function(blocks, appointments2) {
  return updateBlocksProportions(calculateBlocksLeftLimit(calculateBlocksTotalSize(blocks), appointments2));
};
var alignBlocksWithPrevious = function(blocks, appointments2) {
  var nextBlocks = blocks.map(function(_a2) {
    var right = _a2.right, restProps = __rest2(_a2, ["right"]);
    return __assign3({}, restProps);
  });
  var leftLimitCalculated = calculateBlocksLeftLimit(updateBlocksLeft(nextBlocks, appointments2), appointments2);
  return updateBlocksProportions(leftLimitCalculated);
};
var adjustAppointmentsByBlocks = function(appointments2, blocks, indirectChildLeftOffset) {
  var nextAppointments = appointments2.map(function(props) {
    return __assign3({}, props);
  });
  var nextBlocks = blocks.map(function(props) {
    return __assign3({}, props);
  });
  nextBlocks.forEach(function(block, index) {
    if (index !== 0) {
      var items = block.items, blockLeft = block.left, right = block.right, children_1 = block.children;
      var maxRight_1 = calculateIncludedBlockMaxRight(nextBlocks, block);
      var finalMaxRight_1 = maxRight_1 * right;
      var defaultLeft_1 = blockLeft * maxRight_1;
      items.forEach(function(appointmentIndex, itemIndex) {
        var appointment = nextAppointments[appointmentIndex];
        if (itemIndex === 0) {
          var _a2 = calculateAppointmentLeftAndWidth(nextAppointments, nextBlocks, appointment, finalMaxRight_1, indirectChildLeftOffset, defaultLeft_1), left_1 = _a2.left, width = _a2.width;
          appointment.data.left = left_1;
          appointment.data.width = width;
          if (defaultLeft_1 !== left_1) {
            children_1.forEach(function(childIndex) {
              redistributeChildBlocks(nextBlocks, childIndex, left_1 / maxRight_1);
            });
          }
        } else {
          var _b = calculateAppointmentLeftAndWidth(nextAppointments, nextBlocks, appointment, finalMaxRight_1, indirectChildLeftOffset, void 0), left = _b.left, width = _b.width;
          appointment.data.left = left;
          appointment.data.width = width;
        }
      });
    }
  });
  blocks[0].items.forEach(function(appointmentIndex) {
    var appointment = nextAppointments[appointmentIndex];
    var _a2 = calculateAppointmentLeftAndWidth(nextAppointments, blocks, appointment, 1, indirectChildLeftOffset, void 0), left = _a2.left, width = _a2.width;
    appointment.data.left = left;
    appointment.data.width = width;
  });
  return nextAppointments;
};
var redistributeChildBlocks = function(blocks, blockIndex, right) {
  var block = blocks[blockIndex];
  var leftOffset = block.leftOffset, size = block.size, leftLimit = block.leftLimit, children = block.children;
  block.right = right;
  var width = size + leftOffset;
  var relativeWidth = right - leftLimit;
  var left = right - relativeWidth * size / width;
  block.left = left;
  children.forEach(function(childIndex) {
    redistributeChildBlocks(blocks, childIndex, left);
  });
};
var calculateIncludedBlockMaxRight = function(blocks, includedBlock) {
  var includedIntoIndex = includedBlock.includedInto;
  if (includedIntoIndex === void 0) {
    return 1;
  }
  var includedInto = blocks[includedIntoIndex];
  var currentMaxRight = includedInto.right;
  return currentMaxRight * calculateIncludedBlockMaxRight(blocks, includedInto);
};
var calculateBlocksTotalSize = function(blocks) {
  var result = blocks.map(function(block) {
    var totalSize = calculateSingleBlockTotalSize(blocks, block);
    return __assign3(__assign3({}, block), { totalSize, leftOffset: totalSize - block.size });
  });
  return result;
};
var calculateSingleBlockTotalSize = function(blocks, block) {
  var children = block.children, size = block.size;
  if (children.length === 0) {
    return size;
  }
  return Math.max.apply(Math, __spreadArray4([], __read3(children.map(function(childIndex) {
    return calculateSingleBlockTotalSize(blocks, blocks[childIndex]);
  })), false)) + size;
};
var calculateBlocksLeftLimit = function(blocks, appointments2) {
  return blocks.map(function(block) {
    var leftLimit = calculateSingleBlockLeftLimit(blocks, appointments2, block);
    return __assign3(__assign3({}, block), { leftLimit });
  });
};
var calculateSingleBlockLeftLimit = function(blocks, appointments2, block) {
  var _a2 = block, children = _a2.children, items = _a2.items, left = _a2.left;
  if (children.length === 0) {
    return left !== void 0 ? Math.min(left, appointments2[items[0]].data.left) : appointments2[items[0]].data.left;
  }
  return Math.min.apply(Math, __spreadArray4([], __read3(children.map(function(childIndex) {
    return calculateSingleBlockLeftLimit(blocks, appointments2, blocks[childIndex]);
  })), false));
};
var updateBlocksProportions = function(blocks) {
  var nextBlocks = blocks.map(function(props) {
    return __assign3({}, props);
  });
  nextBlocks.forEach(function(block) {
    var parentIndex = block.parent, leftLimit = block.leftLimit, leftOffset = block.leftOffset, totalSize = block.totalSize;
    if (parentIndex === void 0) {
      block.right = 1;
      block.left = (1 - leftLimit) * leftOffset / totalSize + leftLimit;
      return;
    }
    var parent = nextBlocks[parentIndex];
    var _a2 = parent, parentLeft = _a2.left, parentTotalSize = _a2.totalSize;
    block.totalSize = parentTotalSize;
    block.right = parentLeft;
    block.left = (1 - leftLimit) * leftOffset / parentTotalSize + leftLimit;
  });
  return nextBlocks;
};
var updateBlocksLeft = function(blocks, appointments2) {
  return blocks.map(function(block) {
    var items = block.items, left = block.left;
    var firstItem = appointments2[items[0]];
    var firstItemParentIndex = firstItem.parent;
    if (firstItemParentIndex === void 0) {
      return block;
    }
    var firstItemParent = appointments2[firstItemParentIndex];
    var parentBlock = blocks[firstItemParent.blockIndex];
    return __assign3(__assign3({}, block), { left: parentBlock.parent === void 0 ? left : blocks[parentBlock.parent].left });
  });
};
var createAndAdjustAppointmentForest = function(appointmentGroups, cellDuration) {
  var appointmentForest = createAppointmentForest(appointmentGroups, cellDuration);
  var indirectChildLeftOffset = Math.min(1 / findMaxReduceValue(appointmentForest), INDIRECT_CHILD_LEFT_OFFSET);
  var baseCalculated = calculateAppointmentsMetaData(appointmentForest, indirectChildLeftOffset);
  var preparedToGroupIntoBlocks = prepareToGroupIntoBlocks(baseCalculated);
  var groupedIntoBlocks = groupAppointmentsIntoBlocks(preparedToGroupIntoBlocks);
  var blocksWithIncluded = findIncludedBlocks(groupedIntoBlocks);
  var blocksWithParents = findChildBlocks(blocksWithIncluded);
  return adjustByBlocks(blocksWithParents, indirectChildLeftOffset);
};
var calculateRectByDateAndGroupIntervals = function(type, intervals, rectByDates, rectByDatesMeta, viewMetaData) {
  var growDirection = type.growDirection, multiline = type.multiline;
  var isHorizontal = growDirection === HORIZONTAL_TYPE;
  var sorted = intervals.map(sortAppointments);
  var grouped = sorted.reduce(function(acc, sortedGroup) {
    return __spreadArray4(__spreadArray4([], __read3(acc), false), __read3(findOverlappedAppointments(sortedGroup, isHorizontal)), false);
  }, []);
  var cellDuration = rectByDatesMeta.cellDuration, placeAppointmentsNextToEachOther = rectByDatesMeta.placeAppointmentsNextToEachOther;
  var rectCalculator = isHorizontal ? horizontalRectCalculator : placeAppointmentsNextToEachOther ? oldVerticalRectCalculator : verticalRectCalculator;
  var groupsCalculated = calculateAppointmentOffsets(grouped, isHorizontal);
  var isAppointmentForestNeeded = !isHorizontal && !placeAppointmentsNextToEachOther;
  var appointmentForest;
  if (isAppointmentForestNeeded) {
    appointmentForest = createAndAdjustAppointmentForest(groupsCalculated, cellDuration);
  }
  var unwrappedAppointments = isAppointmentForestNeeded ? unwrapAppointmentForest(appointmentForest) : unwrapGroups(groupsCalculated);
  var rects = unwrappedAppointments.map(function(appointment) {
    return rectCalculator(appointment, viewMetaData, { rectByDates, multiline, rectByDatesMeta });
  });
  return rects.sort(function(first, second) {
    return first.offset >= second.offset ? 1 : -1;
  });
};
var sliceAppointmentByDay = function(appointment, cellDuration) {
  var start = appointment.start, end = appointment.end, dataItem = appointment.dataItem, key = appointment.key;
  if (start.isSame(end, "day"))
    return [appointment];
  var minDuration = cellDuration / 2;
  var isShortOnFirstDay = start.clone().endOf("day").diff(start, "minutes") < minDuration;
  var isShortOnSecondDay = end.clone().diff(end.clone().startOf("day"), "minutes") < minDuration;
  var firstAppointmentKey = addDateToKey(key, start);
  var secondAppointmentKey = addDateToKey(key, end);
  return [
    isShortOnFirstDay ? {
      start: start.clone().endOf("day").add(-minDuration, "minutes"),
      end: start.clone().endOf("day"),
      dataItem,
      key: firstAppointmentKey
    } : {
      start,
      end: start.clone().endOf("day"),
      dataItem,
      key: firstAppointmentKey
    },
    isShortOnSecondDay ? {
      start: end.clone().startOf("day"),
      end: end.clone().startOf("day").add(minDuration, "minutes"),
      dataItem,
      key: secondAppointmentKey
    } : {
      start: end.clone().startOf("day"),
      end,
      dataItem,
      key: secondAppointmentKey
    }
  ];
};
var dayBoundaryPredicate = function(appointment, leftBound, rightBound, excludedDays) {
  if (excludedDays === void 0) {
    excludedDays = [];
  }
  var dayStart = moment_default(leftBound);
  var dayEnd = moment_default(rightBound);
  var startDayTime = moment_default(appointment.start).hour(dayStart.hour()).minutes(dayStart.minutes());
  var endDayTime = moment_default(appointment.start).hour(dayEnd.hour()).minutes(dayEnd.minutes());
  if (appointment.end.isBefore(dayStart) || appointment.start.isAfter(dayEnd))
    return false;
  if (excludedDays.findIndex(function(day) {
    return day === moment_default(appointment.start).day();
  }) !== -1)
    return false;
  return appointment.end.isAfter(startDayTime) && appointment.start.isBefore(endDayTime);
};
var reduceAppointmentByDayBounds = function(appointment, leftBound, rightBound, cellDuration) {
  var dayStart = moment_default(leftBound);
  var dayEnd = moment_default(rightBound);
  var startDayTime = moment_default(appointment.start).hour(dayStart.hour()).minutes(dayStart.minutes()).seconds(dayStart.seconds());
  var endDayTime = moment_default(appointment.start).hour(dayEnd.hour()).minutes(dayEnd.minutes()).seconds(dayEnd.seconds());
  var minDuration = cellDuration / 2;
  var isShortOnFirstDay = endDayTime.clone().diff(appointment.start, "minutes") < minDuration;
  var isShortOnSecondDay = appointment.end.clone().diff(startDayTime, "minutes") < minDuration;
  if (isShortOnFirstDay) {
    return __assign3(__assign3({}, appointment), { start: endDayTime.clone().add(-minDuration, "minutes"), end: endDayTime });
  }
  if (isShortOnSecondDay) {
    return __assign3(__assign3({}, appointment), { start: startDayTime, end: startDayTime.clone().add(minDuration, "minutes") });
  }
  return __assign3(__assign3(__assign3({}, appointment), appointment.start.isSameOrBefore(startDayTime) ? { start: startDayTime } : null), appointment.end.isSameOrAfter(endDayTime) ? { end: endDayTime } : null);
};
var normalizeAppointmentDuration = function(appointment, cellDuration) {
  var minDuration = cellDuration / 2;
  var start = moment_default(appointment.start);
  var end = moment_default(appointment.end);
  if (end.diff(start, "minutes") > minDuration) {
    return __assign3(__assign3({}, appointment), { start, end });
  }
  if (end.isSame(start.clone().add(minDuration, "minutes"), "day")) {
    return __assign3(__assign3({}, appointment), { start, end: start.clone().add(minDuration, "minutes") });
  }
  return __assign3(__assign3({}, appointment), { start: start.clone().endOf("day").add(-minDuration, "minutes"), end: start.clone().endOf("day") });
};
var getWeekVerticallyGroupedColumnIndex = function(viewCellsData2, date) {
  return viewCellsData2[0].findIndex(function(timeCell) {
    return moment_default(date).isSame(timeCell.startDate, "date");
  });
};
var getWeekHorizontallyGroupedColumnIndex = function(viewCellsData2, appointment, date) {
  return viewCellsData2[0].findIndex(function(timeCell) {
    var isCorrectGroup = checkCellGroupingInfo(timeCell, appointment);
    return moment_default(date).isSame(timeCell.startDate, "date") && isCorrectGroup;
  });
};
var getWeekVerticallyGroupedRowIndex = function(viewCellsData2, appointment, date, columnIndex, takePrev, groupCount) {
  var timeTableHeight = viewCellsData2.length / groupCount;
  var timeTableRowIndex = getWeekHorizontallyGroupedRowIndex(viewCellsData2, date, columnIndex, takePrev);
  if (!viewCellsData2[0][0].groupingInfo)
    return timeTableRowIndex;
  var isWrongCell = !checkCellGroupingInfo(viewCellsData2[timeTableRowIndex][columnIndex], appointment);
  while (isWrongCell) {
    timeTableRowIndex += timeTableHeight;
    isWrongCell = !checkCellGroupingInfo(viewCellsData2[timeTableRowIndex][columnIndex], appointment);
  }
  return timeTableRowIndex;
};
var getWeekHorizontallyGroupedRowIndex = function(viewCellsData2, date, columnIndex, takePrev) {
  return viewCellsData2.findIndex(function(timeCell) {
    return moment_default(date).isBetween(timeCell[columnIndex].startDate, timeCell[columnIndex].endDate, "seconds", takePrev ? "(]" : "[)");
  });
};
var calculateWeekDateIntervals = function(appointments2, leftBound, rightBound, excludedDays, cellDuration) {
  return [
    appointments2.map(function(appointment) {
      return normalizeAppointmentDuration(appointment, cellDuration);
    }).reduce(function(acc, appointment) {
      return __spreadArray4(__spreadArray4([], __read3(acc), false), __read3(filterByViewBoundaries(appointment, leftBound, rightBound, excludedDays, true)), false);
    }, []).reduce(function(acc, appointment) {
      return __spreadArray4(__spreadArray4([], __read3(acc), false), __read3(sliceAppointmentByDay(appointment, cellDuration)), false);
    }, []).filter(function(appointment) {
      return dayBoundaryPredicate(appointment, leftBound, rightBound, excludedDays);
    }).map(function(appointment) {
      return reduceAppointmentByDayBounds(appointment, leftBound, rightBound, cellDuration);
    })
  ];
};
var CELL_GAP_PX = 10;
var CELL_BOUND_HORIZONTAL_OFFSET_PX = 1;
var CELL_BOUND_VERTICAL_OFFSET_PX = 4;
var getVerticalCellIndexByAppointmentData = function(appointment, viewCellsData2, viewMetaData, date, takePrev) {
  if (takePrev === void 0) {
    takePrev = false;
  }
  var groupOrientation = viewMetaData.groupOrientation, groupCount = viewMetaData.groupCount;
  var columnIndex = groupOrientation === VERTICAL_GROUP_ORIENTATION ? getWeekVerticallyGroupedColumnIndex(viewCellsData2, date) : getWeekHorizontallyGroupedColumnIndex(viewCellsData2, appointment, date);
  var rowIndex = groupOrientation === VERTICAL_GROUP_ORIENTATION ? getWeekVerticallyGroupedRowIndex(viewCellsData2, appointment, date, columnIndex, takePrev, groupCount) : getWeekHorizontallyGroupedRowIndex(viewCellsData2, date, columnIndex, takePrev);
  var cellIndex2 = rowIndex * viewCellsData2[0].length + columnIndex;
  return {
    index: cellIndex2,
    startDate: viewCellsData2[rowIndex][columnIndex].startDate
  };
};
var getCellRect = function(date, appointment, viewCellsData2, cellDuration, cellElementsMeta, takePrev, viewMetaData) {
  var _a2 = getVerticalCellIndexByAppointmentData(appointment, viewCellsData2, viewMetaData, date, takePrev), cellIndex2 = _a2.index, cellStartDate = _a2.startDate;
  var _b = cellElementsMeta.getCellRects[cellIndex2](), top = _b.top, left = _b.left, width = _b.width, cellHeight = _b.height;
  var timeOffset = moment_default(date).diff(cellStartDate, "minutes");
  var topOffset = cellHeight * (timeOffset / cellDuration);
  var parentRect = cellElementsMeta.parentRect();
  return {
    top,
    left,
    width,
    topOffset,
    parentRect
  };
};
var getVerticalRectByAppointmentData = function(appointment, viewMetaData, _a2) {
  var viewCellsData2 = _a2.viewCellsData, cellDuration = _a2.cellDuration, cellElementsMeta = _a2.cellElementsMeta, placeAppointmentsNextToEachOther = _a2.placeAppointmentsNextToEachOther;
  var firstCellRect = getCellRect(appointment.start.toDate(), appointment, viewCellsData2, cellDuration, cellElementsMeta, false, viewMetaData);
  var lastCellRect = getCellRect(appointment.end.toDate(), appointment, viewCellsData2, cellDuration, cellElementsMeta, true, viewMetaData);
  var top = firstCellRect.top + firstCellRect.topOffset;
  var height = lastCellRect.top + lastCellRect.topOffset - top;
  return {
    width: firstCellRect.width - CELL_GAP_PX - CELL_BOUND_HORIZONTAL_OFFSET_PX,
    top: top - firstCellRect.parentRect.top + CELL_BOUND_HORIZONTAL_OFFSET_PX,
    left: firstCellRect.left - firstCellRect.parentRect.left + CELL_BOUND_HORIZONTAL_OFFSET_PX,
    parentWidth: firstCellRect.parentRect.width,
    height: placeAppointmentsNextToEachOther ? height - CELL_BOUND_VERTICAL_OFFSET_PX : height
  };
};
var allDayPredicate = function(appointment) {
  return appointment.end.diff(appointment.start, "hours") > 23 || !!appointment.allDay;
};
var getAllDayCellIndexByAppointmentData = function(viewCellsData2, viewMetaData, date, appointment, takePrev) {
  var currentDate = moment_default(date);
  var groupOrientation = viewMetaData.groupOrientation, groupCount = viewMetaData.groupCount;
  var columnIndex = groupOrientation === HORIZONTAL_GROUP_ORIENTATION ? getAllDayHorizontallyGroupedColumnIndex(viewCellsData2, currentDate, appointment) : getAllDayVerticallyGroupedColumnIndex(viewCellsData2, currentDate);
  var rowIndex = groupOrientation === HORIZONTAL_GROUP_ORIENTATION ? 0 : getAllDayVerticallyGroupedRowIndex(viewCellsData2, appointment, groupCount);
  var cellIndex2 = rowIndex * viewCellsData2[0].length + columnIndex;
  if (takePrev && currentDate.format() === currentDate.startOf("day").format()) {
    cellIndex2 -= 1;
  }
  return cellIndex2;
};
var getAllDayVerticallyGroupedColumnIndex = function(viewCellsData2, date) {
  return viewCellsData2[0].findIndex(function(timeCell) {
    return date.isSame(timeCell.startDate, "date");
  });
};
var getAllDayHorizontallyGroupedColumnIndex = function(viewCellsData2, date, appointment) {
  return viewCellsData2[0].findIndex(function(timeCell) {
    return date.isSame(timeCell.startDate, "date") && checkCellGroupingInfo(timeCell, appointment);
  });
};
var getAllDayVerticallyGroupedRowIndex = function(viewCellsData2, appointment, groupCount) {
  var index = viewCellsData2.findIndex(function(viewCellsDataRow) {
    return checkCellGroupingInfo(viewCellsDataRow[0], appointment);
  });
  return index * groupCount / viewCellsData2.length;
};
var sliceAppointmentsByBoundaries = function(appointment, left, right, excludedDays) {
  if (excludedDays === void 0) {
    excludedDays = [];
  }
  var startDate = appointment.start.clone();
  var endDate = appointment.end.clone();
  var nextStart = startDate.clone();
  var nextEnd = endDate.clone();
  if (startDate.isBefore(left)) {
    nextStart = moment_default(left);
    nextStart.startOf("day");
  }
  if (endDate.isAfter(right)) {
    nextEnd = moment_default(right);
    nextEnd.endOf("day");
  }
  if (excludedDays.findIndex(function(day) {
    return day === startDate.day();
  }) !== -1) {
    while (excludedDays.findIndex(function(day) {
      return day === nextStart.day();
    }) !== -1 && nextStart.isSameOrBefore(endDate, "day")) {
      nextStart.add(1, "days").startOf("day");
    }
  }
  if (excludedDays.findIndex(function(day) {
    return day === endDate.day();
  }) !== -1) {
    while (excludedDays.findIndex(function(day) {
      return day === nextEnd.day();
    }) !== -1 && nextStart.isSameOrAfter(startDate, "day")) {
      nextEnd.add(-1, "days").endOf("day");
    }
  }
  return [__assign3(__assign3({}, appointment), { start: nextStart, end: nextEnd })];
};
var sliceAppointmentsByDays = function(appointment, excludedDays) {
  if (excludedDays === void 0) {
    excludedDays = [];
  }
  var startDate = appointment.start;
  var endDate = appointment.end;
  var nextStart = startDate.clone();
  var appointments2 = [];
  while (nextStart.isBefore(endDate)) {
    if (excludedDays.findIndex(function(day) {
      return day === nextStart.day();
    }) === -1) {
      appointments2.push(__assign3(__assign3({}, appointment), { start: nextStart, end: moment_default(nextStart).endOf("day") }));
    }
    nextStart = moment_default(nextStart).add(1, "day");
  }
  return appointments2;
};
var DEFAULT_RULE_OBJECT = {
  interval: 1
};
var DAYS_OF_WEEK = {
  MONDAY: 0,
  TUESDAY: 1,
  WEDNESDAY: 2,
  THURSDAY: 3,
  FRIDAY: 4,
  SATURDAY: 5,
  SUNDAY: 6
};
var RRULE_DAYS_OF_WEEK = [
  RRule.MO,
  RRule.TU,
  RRule.WE,
  RRule.TH,
  RRule.FR,
  RRule.SA,
  RRule.SU
];
var DAYS_IN_WEEK = 7;
var DAYS_OF_WEEK_ARRAY = [
  DAYS_OF_WEEK.SUNDAY,
  DAYS_OF_WEEK.MONDAY,
  DAYS_OF_WEEK.TUESDAY,
  DAYS_OF_WEEK.WEDNESDAY,
  DAYS_OF_WEEK.THURSDAY,
  DAYS_OF_WEEK.FRIDAY,
  DAYS_OF_WEEK.SATURDAY
];
var RRULE_REPEAT_TYPES = {
  YEARLY: RRule.YEARLY,
  MONTHLY: RRule.MONTHLY,
  WEEKLY: RRule.WEEKLY,
  DAILY: RRule.DAILY,
  HOURLY: RRule.HOURLY,
  MINUTELY: RRule.MINUTELY
};
var REPEAT_TYPES = {
  DAILY: "daily",
  WEEKLY: "weekly",
  MONTHLY: "monthly",
  YEARLY: "yearly",
  NEVER: "never"
};
var REPEAT_TYPES_ARRAY = [
  REPEAT_TYPES.DAILY,
  REPEAT_TYPES.WEEKLY,
  REPEAT_TYPES.MONTHLY,
  REPEAT_TYPES.YEARLY
];
var WEEK_NUMBER_LABELS = [
  "firstLabel",
  "secondLabel",
  "thirdLabel",
  "fourthLabel",
  "lastLabel"
];
var END_REPEAT_RADIO_GROUP = "endRepeat";
var MONTHLY_RADIO_GROUP = "monthlyRadioGroup";
var YEARLY_RADIO_GROUP = "yearlyRadioGroup";
var TITLE_TEXT_EDITOR = "titleTextEditor";
var MULTILINE_TEXT_EDITOR = "multilineTextEditor";
var ORDINARY_TEXT_EDITOR = "ordinaryTextEditor";
var NUMBER_EDITOR = "numberEditor";
var TITLE = "title";
var ORDINARY_LABEL = "ordinaryLabel";
var SAVE_BUTTON = "saveButton";
var DELETE_BUTTON = "deleteButton";
var CANCEL_BUTTON = "cancelButton";
var OUTLINED_SELECT = "outlinedSelect";
var STANDARD_SELECT = "standardSelect";
var SUNDAY_DATE = new Date(2019, 7, 11);
var MONDAY_DATE = new Date(2019, 7, 12);
var TUESDAY_DATE = new Date(2019, 7, 13);
var WEDNESDAY_DATE = new Date(2019, 7, 14);
var THURSDAY_DATE = new Date(2019, 7, 15);
var FRIDAY_DATE = new Date(2019, 7, 16);
var SATURDAY_DATE = new Date(2019, 7, 17);
var DAYS_OF_WEEK_DATES = [
  SUNDAY_DATE,
  MONDAY_DATE,
  TUESDAY_DATE,
  WEDNESDAY_DATE,
  THURSDAY_DATE,
  FRIDAY_DATE,
  SATURDAY_DATE
];
var JANUARY_DATE = new Date(2019, 0, 1);
var FEBRUARY_DATE = new Date(2019, 1, 1);
var MARCH_DATE = new Date(2019, 2, 1);
var APRIL_DATE = new Date(2019, 3, 1);
var MAY_DATE = new Date(2019, 4, 1);
var JUNE_DATE = new Date(2019, 5, 1);
var JULY_DATE = new Date(2019, 6, 1);
var AUGUST_DATE = new Date(2019, 7, 1);
var SEPTEMBER_DATE = new Date(2019, 8, 1);
var OCTOBER_DATE = new Date(2019, 9, 1);
var NOVEMBER_DATE = new Date(2019, 10, 1);
var DECEMBER_DATE = new Date(2019, 11, 1);
var MONTHS_DATES = [
  JANUARY_DATE,
  FEBRUARY_DATE,
  MARCH_DATE,
  APRIL_DATE,
  MAY_DATE,
  JUNE_DATE,
  JULY_DATE,
  AUGUST_DATE,
  SEPTEMBER_DATE,
  OCTOBER_DATE,
  NOVEMBER_DATE,
  DECEMBER_DATE
];
var LAST_WEEK = 4;
var BASIC_YEALY_COUNT = 5;
var BASIC_MONTHLY_COUNT = 12;
var BASIC_WEEKLY_COUNT = 13;
var BASIC_DAILY_COUNT = 30;
var sliceAppointmentByWeek = function(timeBounds, appointment, step) {
  var left = timeBounds.left, right = timeBounds.right;
  var pieces = [];
  var start = appointment.start, end = appointment.end, key = appointment.key, restFields = __rest2(appointment, ["start", "end", "key"]);
  var apptStart = start;
  var apptEnd = end;
  if (apptStart.isBefore(left))
    apptStart = left.clone();
  if (apptEnd.isAfter(right))
    apptEnd = right.clone();
  var pieceFrom = apptStart.clone();
  var pieceTo = apptStart.clone();
  var i = 0;
  while (pieceTo.isBefore(apptEnd)) {
    var currentRightBound = left.clone().add(step * i, "days").subtract(1, "second");
    if (currentRightBound.isAfter(apptStart)) {
      pieceTo = apptStart.clone().add(step * i, "days");
      if (pieceTo.isAfter(currentRightBound)) {
        pieceTo = currentRightBound.clone();
      }
      if (pieceTo.isAfter(apptEnd)) {
        pieceTo = apptEnd.clone();
      }
      if (!pieceFrom.isSameOrAfter(pieceTo)) {
        pieces.push(__assign3({ start: pieceFrom, end: pieceTo, key: addDateToKey(key, pieceFrom) }, restFields));
        pieceFrom = pieceTo.clone().add(1, "second");
      }
    }
    i += 1;
  }
  return pieces;
};
var getMonthCellIndexByAppointmentData = function(viewCellsData2, viewMetaData, date, appointment, takePrev) {
  if (takePrev === void 0) {
    takePrev = false;
  }
  var groupOrientation = viewMetaData.groupOrientation, groupedByDate = viewMetaData.groupedByDate, groupCount = viewMetaData.groupCount;
  var startViewDate2 = moment_default(viewCellsData2[0][0].startDate);
  var currentDate = moment_default(date);
  var dayNumber = currentDate.diff(startViewDate2, "days");
  if (takePrev && currentDate.format() === currentDate.startOf("day").format()) {
    dayNumber -= 1;
  }
  var weekNumber = Math.floor(dayNumber / DAYS_IN_WEEK);
  var dayOfWeek = dayNumber % DAYS_IN_WEEK;
  var columnIndex = groupOrientation === HORIZONTAL_GROUP_ORIENTATION ? getMonthHorizontallyGroupedColumnIndex(viewCellsData2, appointment, weekNumber, dayOfWeek, groupCount, groupedByDate) : dayOfWeek;
  var rowIndex = groupOrientation === HORIZONTAL_GROUP_ORIENTATION ? weekNumber : getMonthVerticallyGroupedRowIndex(viewCellsData2, appointment, weekNumber, dayOfWeek, groupCount);
  var totalCellIndex = rowIndex * viewCellsData2[0].length + columnIndex;
  return totalCellIndex;
};
var getMonthHorizontallyGroupedColumnIndex = function(viewCellsData2, appointment, weekNumber, dayOfWeek, groupCount, groupByDate) {
  var columnIndex = -1;
  var currentColumnIndex = groupByDate ? dayOfWeek * groupCount : dayOfWeek;
  var cellsInGroupRow = groupByDate ? 1 : DAYS_IN_WEEK;
  while (columnIndex === -1) {
    var isCorrectCell = checkCellGroupingInfo(viewCellsData2[weekNumber][currentColumnIndex], appointment);
    if (isCorrectCell) {
      columnIndex = currentColumnIndex;
    }
    currentColumnIndex += cellsInGroupRow;
  }
  return columnIndex;
};
var getMonthVerticallyGroupedRowIndex = function(viewCellsData2, appointment, weekNumber, dayOfWeek, groupCount) {
  var rowsInOneGroup = viewCellsData2.length / groupCount;
  var rowIndex = -1;
  var currentRowIndex = weekNumber;
  while (rowIndex === -1) {
    var isCorrectCell = checkCellGroupingInfo(viewCellsData2[currentRowIndex][dayOfWeek], appointment);
    if (isCorrectCell) {
      rowIndex = currentRowIndex;
    }
    currentRowIndex += rowsInOneGroup;
  }
  return rowIndex;
};
var TOP_CELL_OFFSET = 0.32;
var CELL_BOUND_OFFSET_PX = 1;
var getCellRect$1 = function(date, appointment, viewCellsData2, viewMetaData, cellElementsMeta, takePrev, multiline) {
  var cellIndex2 = multiline ? getMonthCellIndexByAppointmentData(viewCellsData2, viewMetaData, date, appointment, takePrev) : getAllDayCellIndexByAppointmentData(viewCellsData2, viewMetaData, date, appointment, takePrev);
  var _a2 = cellElementsMeta.getCellRects[cellIndex2](), top = _a2.top, left = _a2.left, width = _a2.width, height = _a2.height;
  var parentRect = cellElementsMeta.parentRect();
  return {
    top,
    left,
    width,
    height,
    parentRect
  };
};
var getHorizontalRectByAppointmentData = function(appointment, viewMetaData, _a2) {
  var multiline = _a2.multiline, viewCellsData2 = _a2.viewCellsData, cellElementsMeta = _a2.cellElementsMeta;
  var firstCellRect = getCellRect$1(appointment.start.toDate(), appointment, viewCellsData2, viewMetaData, cellElementsMeta, false, multiline);
  var lastCellRect = getCellRect$1(appointment.end.toDate(), appointment, viewCellsData2, viewMetaData, cellElementsMeta, true, multiline);
  var top = firstCellRect.top + firstCellRect.height * TOP_CELL_OFFSET;
  var height = firstCellRect.height - firstCellRect.height * TOP_CELL_OFFSET;
  return {
    top: top - firstCellRect.parentRect.top,
    left: firstCellRect.left - firstCellRect.parentRect.left + CELL_BOUND_OFFSET_PX,
    width: lastCellRect.left - firstCellRect.left + firstCellRect.width - CELL_BOUND_OFFSET_PX,
    height,
    parentWidth: firstCellRect.parentRect.width
  };
};
var DAY_COUNT = 7;
var MONTH_LENGTH = 31;
var monthCellsData = function(currentDate, firstDayOfWeek, intervalCount, today) {
  if (intervalCount === void 0) {
    intervalCount = 1;
  }
  var targetDate = moment_default(currentDate);
  var currentMonths = [targetDate.month()];
  while (currentMonths.length < intervalCount) {
    currentMonths.push(targetDate.add(1, "months").month());
  }
  var firstMonthDate = moment_default(currentDate).date(1);
  var firstMonthDay = firstMonthDate.day() - firstDayOfWeek;
  var prevMonthDayCount = firstMonthDate.day(firstMonthDay).day() || DAY_COUNT;
  var prevMonth = moment_default(currentDate).subtract(1, "months");
  var prevMonthStartDay = prevMonth.daysInMonth() - (prevMonthDayCount - 1);
  var from2 = moment_default().year(prevMonth.year()).month(prevMonth.month()).date(prevMonthStartDay).startOf("day");
  var result = [];
  while (result.length < Math.trunc(MONTH_LENGTH * intervalCount / DAY_COUNT) + 2) {
    var week = [];
    while (week.length < DAY_COUNT) {
      week.push({
        startDate: from2.toDate(),
        endDate: from2.clone().add(1, "day").toDate(),
        otherMonth: currentMonths.findIndex(function(month) {
          return month === from2.month();
        }) === -1,
        today: today ? moment_default(today).isSame(from2, "date") : false
      });
      from2.add(1, "day");
    }
    result.push(week);
  }
  return result;
};
var calculateMonthDateIntervals = function(appointments2, leftBound, rightBound) {
  return [
    appointments2.map(function(_a2) {
      var start = _a2.start, end = _a2.end, restArgs = __rest2(_a2, ["start", "end"]);
      return __assign3({ start: moment_default(start), end: moment_default(end) }, restArgs);
    }).reduce(function(acc, appointment) {
      return __spreadArray4(__spreadArray4([], __read3(acc), false), __read3(filterByViewBoundaries(appointment, leftBound, rightBound, [], false)), false);
    }, []).reduce(function(acc, appointment) {
      return __spreadArray4(__spreadArray4([], __read3(acc), false), __read3(sliceAppointmentByWeek({ left: moment_default(leftBound), right: moment_default(rightBound) }, appointment, DAY_COUNT)), false);
    }, [])
  ];
};
var calculateAllDayDateIntervals = function(appointments2, leftBound, rightBound, excludedDays) {
  return [
    appointments2.map(function(_a2) {
      var start = _a2.start, end = _a2.end, restArgs = __rest2(_a2, ["start", "end"]);
      return __assign3({ start: moment_default(start), end: moment_default(end) }, restArgs);
    }).reduce(function(acc, appointment) {
      return __spreadArray4(__spreadArray4([], __read3(acc), false), __read3(filterByViewBoundaries(appointment, leftBound, rightBound, excludedDays, false)), false);
    }, []).filter(function(appointment) {
      return allDayPredicate(appointment);
    }).reduce(function(acc, appointment) {
      return __spreadArray4(__spreadArray4([], __read3(acc), false), __read3(sliceAppointmentsByBoundaries(appointment, leftBound, rightBound, excludedDays)), false);
    }, [])
  ];
};
var getGroupFromResourceInstance = function(resourceInstance) {
  return {
    id: resourceInstance.id,
    fieldName: resourceInstance.fieldName,
    text: resourceInstance.text
  };
};
var addGroupInfoToCells = function(currentGroup, groups, sortedResources, viewCellRow, index, endOfGroup, groupOrientation) {
  return viewCellRow.map(function(viewCell, cellIndex2) {
    var groupedCell = addGroupInfoToCell(currentGroup, groups, sortedResources, viewCell, index, endOfGroup, groupOrientation);
    return cellIndex2 === viewCellRow.length - 1 && groupOrientation === HORIZONTAL_GROUP_ORIENTATION ? __assign3(__assign3({}, groupedCell), { endOfGroup: true }) : groupedCell;
  });
};
var addGroupInfoToCell = function(currentGroup, groups, sortedResources, viewCell, index, endOfGroup, groupOrientation) {
  var previousIndex = index;
  var groupingInfo = groups.reduceRight(function(acc, group, currentIndex) {
    if (currentIndex === groups.length - 1)
      return acc;
    var previousResourceLength = sortedResources[currentIndex + 1].instances.length;
    var currentGroupingInstance = group[Math.floor(previousIndex / previousResourceLength)];
    previousIndex = currentIndex;
    return __spreadArray4(__spreadArray4([], __read3(acc), false), [currentGroupingInstance], false);
  }, [currentGroup]);
  return __assign3(__assign3({}, viewCell), { groupingInfo, endOfGroup, groupOrientation });
};
var getCurrentGroup = function(groups, resources, index, group) {
  var currentIndex = index;
  return groups.reduceRight(function(groupAcc, groupsRow, rowIndex) {
    if (rowIndex === groups.length - 1) {
      return groupAcc;
    }
    currentIndex = Math.floor(currentIndex / resources[rowIndex + 1].instances.length);
    var currentInstance = groupsRow[currentIndex];
    return __spreadArray4(__spreadArray4([], __read3(groupAcc), false), [
      currentInstance
    ], false);
  }, [group]);
};
var groupAppointments = function(appointments2, resources, groups) {
  if (!resources || !groups)
    return [appointments2.slice()];
  var mainResource = resources.find(function(resource) {
    return resource.isMain;
  });
  return groups[groups.length - 1].map(function(group, index) {
    var currentGroup = getCurrentGroup(groups, resources, index, group);
    return appointments2.reduce(function(acc, appointment) {
      var _a2;
      var belongsToGroup = currentGroup.reduce(function(isBelonging, groupItem) {
        return isBelonging && groupItem.id === appointment[groupItem.fieldName];
      }, true);
      if (!belongsToGroup)
        return acc;
      var currentMainResourceId = currentGroup.find(function(groupItem) {
        return groupItem.fieldName === mainResource.fieldName;
      }).id;
      var updatedAppointment = __assign3(__assign3({}, appointment), { dataItem: __assign3(__assign3({}, appointment.dataItem), (_a2 = {}, _a2[mainResource.fieldName] = rearrangeResourceIds(mainResource, appointment, currentMainResourceId), _a2)), resources: appointment.resources && rearrangeResources(mainResource, appointment, currentMainResourceId) });
      return __spreadArray4(__spreadArray4([], __read3(acc), false), [updatedAppointment], false);
    }, []);
  });
};
var rearrangeResourceIds = function(mainResource, appointment, mainResourceId) {
  if (!mainResource.allowMultiple) {
    return mainResourceId;
  }
  return __spreadArray4([
    mainResourceId
  ], __read3(appointment.dataItem[mainResource.fieldName].filter(function(id) {
    return id !== mainResourceId;
  })), false);
};
var rearrangeResources = function(mainResource, appointment, currentResourceInstanceId) {
  var _a2;
  if (!mainResource.allowMultiple) {
    return appointment.resources;
  }
  var resources = appointment.resources.slice();
  var firstMainResource = resources.findIndex(function(el) {
    return el.isMain;
  });
  var currentResourceIndex = resources.findIndex(function(el) {
    return el.isMain && el.id === currentResourceInstanceId;
  });
  _a2 = __read3([resources[currentResourceIndex], resources[firstMainResource]], 2), resources[firstMainResource] = _a2[0], resources[currentResourceIndex] = _a2[1];
  return resources;
};
var expandGroupedAppointment = function(appointment, grouping, resources) {
  if (!resources || !grouping) {
    return [appointment];
  }
  return resources.reduce(function(acc, resource) {
    var isGroupedByResource = grouping.find(function(group) {
      return group.resourceName === resource.fieldName;
    }) !== void 0;
    if (!isGroupedByResource)
      return acc;
    var resourceField = resource.fieldName;
    if (!resource.allowMultiple) {
      return acc.reduce(function(accumulatedAppointments, currentAppointment) {
        var _a2;
        return __spreadArray4(__spreadArray4([], __read3(accumulatedAppointments), false), [
          __assign3(__assign3({}, currentAppointment), (_a2 = {}, _a2[resourceField] = currentAppointment.dataItem[resourceField], _a2))
        ], false);
      }, []);
    }
    return acc.reduce(function(accumulatedAppointments, currentAppointment) {
      return __spreadArray4(__spreadArray4([], __read3(accumulatedAppointments), false), __read3(currentAppointment.dataItem[resourceField].map(function(resourceValue) {
        var _a2;
        return __assign3(__assign3({}, currentAppointment), (_a2 = {}, _a2[resourceField] = resourceValue, _a2.key = generateMultipleResourceKey(currentAppointment.key, resourceValue), _a2));
      })), false);
    }, []);
  }, [appointment]);
};
var generateMultipleResourceKey = function(previousKey, resourceValue) {
  return "".concat(previousKey, "_").concat(resourceValue);
};
var getGroupsLastRow = function(groups) {
  return groups[groups.length - 1];
};
var filterResourcesByGrouping = function(resources, grouping) {
  return resources.filter(function(resource) {
    return grouping.find(function(resourceId) {
      return resource.fieldName === resourceId.resourceName;
    });
  });
};
var sortFilteredResources = function(resources, grouping) {
  return grouping.map(function(_a2) {
    var resourceName = _a2.resourceName;
    return resources.find(function(resource) {
      return resource.fieldName === resourceName;
    });
  });
};
var getGroupsFromResources = function(sortedAndFilteredResources) {
  return sortedAndFilteredResources.reduce(function(acc, resource, index) {
    if (index === 0) {
      return [resource.instances.map(function(instance) {
        return getGroupFromResourceInstance(instance);
      })];
    }
    return __spreadArray4(__spreadArray4([], __read3(acc), false), [
      acc[index - 1].reduce(function(currentResourceNames) {
        return __spreadArray4(__spreadArray4([], __read3(currentResourceNames), false), __read3(resource.instances.map(function(instance) {
          return getGroupFromResourceInstance(instance);
        })), false);
      }, [])
    ], false);
  }, []);
};
var expandViewCellsDataWithGroups = function(viewCellsData2, groups, sortedResources, groupByDate, groupOrientation) {
  if (groups.length === 0)
    return viewCellsData2;
  if (groupByDate) {
    return expandCellsWithGroupedByDateData(viewCellsData2, groups, sortedResources);
  }
  if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {
    return expandHorizontallyGroupedCells(viewCellsData2, groups, sortedResources);
  }
  return expandVerticallyGroupedCells(viewCellsData2, groups, sortedResources);
};
var expandCellsWithGroupedByDateData = function(viewCellsData2, groups, sortedResources) {
  return viewCellsData2.map(function(cellsRow) {
    return cellsRow.reduce(function(acc, viewCell) {
      var groupedCells = getGroupsLastRow(groups).map(function(group, index) {
        return addGroupInfoToCell(group, groups, sortedResources, viewCell, index, false, HORIZONTAL_GROUP_ORIENTATION);
      });
      groupedCells[groupedCells.length - 1] = __assign3(__assign3({}, groupedCells[groupedCells.length - 1]), { endOfGroup: true });
      return __spreadArray4(__spreadArray4([], __read3(acc), false), __read3(groupedCells), false);
    }, []);
  });
};
var expandHorizontallyGroupedCells = function(viewCellsData2, groups, sortedResources) {
  return getGroupsLastRow(groups).reduce(function(acc, group, index) {
    if (index === 0) {
      return viewCellsData2.map(function(viewCellsRow) {
        return addGroupInfoToCells(group, groups, sortedResources, viewCellsRow, index, false, HORIZONTAL_GROUP_ORIENTATION);
      });
    }
    return acc.map(function(item, id) {
      return __spreadArray4(__spreadArray4([], __read3(item), false), __read3(addGroupInfoToCells(group, groups, sortedResources, viewCellsData2[id], index, false, HORIZONTAL_GROUP_ORIENTATION)), false);
    });
  }, [[]]);
};
var expandVerticallyGroupedCells = function(viewCellsData2, groups, sortedResources) {
  return getGroupsLastRow(groups).reduce(function(acc, group, index) {
    if (index === 0) {
      return viewCellsData2.map(function(viewCellsRow, viewRowIndex) {
        return addGroupInfoToCells(group, groups, sortedResources, viewCellsRow, index, viewRowIndex === viewCellsData2.length - 1, VERTICAL_GROUP_ORIENTATION);
      });
    }
    return __spreadArray4(__spreadArray4([], __read3(acc), false), __read3(viewCellsData2.map(function(viewCellsRow, viewRowIndex) {
      return addGroupInfoToCells(group, groups, sortedResources, viewCellsRow, index, viewRowIndex === viewCellsData2.length - 1, VERTICAL_GROUP_ORIENTATION);
    })), false);
  }, [[]]);
};
var updateGroupingWithMainResource = function(grouping, resources) {
  return grouping || [{ resourceName: resources.find(function(resource) {
    return resource.isMain;
  }).fieldName }];
};
var expandGroups = function(appointments2, grouping, resources, groups, excludedDays, sliceByDay) {
  if (sliceByDay === void 0) {
    sliceByDay = false;
  }
  var slicedAppointments = sliceByDay ? appointments2[0].reduce(function(acc, appointment) {
    return __spreadArray4(__spreadArray4([], __read3(acc), false), __read3(sliceAppointmentsByDays(appointment, excludedDays)), false);
  }, []) : appointments2[0];
  var expandedAppointments = slicedAppointments.reduce(function(acc, appointment) {
    return __spreadArray4(__spreadArray4([], __read3(acc), false), __read3(expandGroupedAppointment(appointment, grouping, resources)), false);
  }, []);
  return groupAppointments(expandedAppointments, resources, groups);
};
var updateTimeTableCellElementsMeta = function(timeTableElementsMeta, groupOrientation, groups, allDayPanelExists, viewCellsData2, currentView) {
  if (checkCellElementsMeta(timeTableElementsMeta, groupOrientation, currentView, allDayPanelExists)) {
    return timeTableElementsMeta;
  }
  var _a2 = initializeCellElementsData(timeTableElementsMeta, viewCellsData2, groups), groupCount = _a2.groupCount, timeTableWidth = _a2.timeTableWidth, groupSize = _a2.groupSize, validGetCellRects = _a2.validGetCellRects;
  var allDayPanelsLeft = groupCount;
  while (allDayPanelsLeft > 0) {
    allDayPanelsLeft -= 1;
    validGetCellRects.splice(allDayPanelsLeft * (timeTableWidth + groupSize), timeTableWidth);
  }
  return {
    parentRect: timeTableElementsMeta.parentRect,
    getCellRects: validGetCellRects
  };
};
var updateAllDayCellElementsMeta = function(allDayElementsMeta, timeTableElementsMeta, groupOrientation, groups, allDayPanelExists, viewCellsData2, currentView) {
  if (checkCellElementsMeta(timeTableElementsMeta, groupOrientation, currentView, allDayPanelExists)) {
    return allDayElementsMeta;
  }
  var _a2 = initializeCellElementsData(timeTableElementsMeta, viewCellsData2, groups), groupCount = _a2.groupCount, timeTableWidth = _a2.timeTableWidth, groupSize = _a2.groupSize, validGetCellRects = _a2.validGetCellRects;
  var allDayPanelsLeft = groupCount;
  while (allDayPanelsLeft > 0) {
    allDayPanelsLeft -= 1;
    validGetCellRects.splice(groupSize * allDayPanelsLeft + timeTableWidth * (allDayPanelsLeft + 1), groupSize);
  }
  return {
    parentRect: timeTableElementsMeta.parentRect,
    getCellRects: validGetCellRects
  };
};
var checkCellElementsMeta = function(cellElementsMeta, groupOrientation, currentView, allDayPanelExists) {
  return groupOrientation(currentView.name) === HORIZONTAL_GROUP_ORIENTATION || !allDayPanelExists || !cellElementsMeta.getCellRects;
};
var initializeCellElementsData = function(cellElementsMeta, viewCellsData2, groups) {
  var timeTableWidth = viewCellsData2[0].length;
  var groupCount = getGroupsLastRow(groups).length;
  var groupHeight = viewCellsData2.length / groupCount;
  return {
    groupCount,
    timeTableWidth,
    groupSize: timeTableWidth * groupHeight,
    validGetCellRects: cellElementsMeta.getCellRects.slice()
  };
};
var updateTimeCellsData = function(viewCellsData2, timeCellsData2, groups, sortedResources, groupOrientation) {
  var firstViewDate = viewCellsData2[0][0].startDate;
  if (!containsDSTChange(firstViewDate)) {
    return viewCellsData2;
  }
  if (groupOrientation !== VERTICAL_GROUP_ORIENTATION) {
    return timeCellsData2;
  }
  return expandVerticallyGroupedCells(timeCellsData2, groups, sortedResources);
};
var allDayRects = function(appointments2, startViewDate2, endViewDate2, excludedDays, viewCellsData2, cellElementsMeta, grouping, resources, groups, groupOrientation, sliceAppointments) {
  var intervals = calculateAllDayDateIntervals(appointments2, startViewDate2, endViewDate2, excludedDays);
  var groupedIntervals = expandGroups(intervals, grouping, resources, groups, excludedDays, sliceAppointments);
  return calculateRectByDateAndGroupIntervals({
    growDirection: HORIZONTAL_TYPE,
    multiline: false
  }, groupedIntervals, getHorizontalRectByAppointmentData, {
    startViewDate: startViewDate2,
    endViewDate: endViewDate2,
    viewCellsData: viewCellsData2,
    cellElementsMeta,
    excludedDays
  }, {
    groupOrientation,
    groupedByDate: sliceAppointments,
    groupCount: groups ? getGroupsLastRow(groups).length : 1
  });
};
var verticalTimeTableRects = function(appointments2, startViewDate2, endViewDate2, excludedDays, viewCellsData2, cellDuration, cellElementsMeta, grouping, resources, groups, groupOrientation, groupByDate) {
  var intervals = calculateWeekDateIntervals(appointments2, startViewDate2, endViewDate2, excludedDays, cellDuration);
  var groupedIntervals = expandGroups(intervals, grouping, resources, groups, excludedDays, false);
  return calculateRectByDateAndGroupIntervals({
    growDirection: VERTICAL_TYPE,
    multiline: false
  }, groupedIntervals, getVerticalRectByAppointmentData, {
    startViewDate: startViewDate2,
    endViewDate: endViewDate2,
    viewCellsData: viewCellsData2,
    cellDuration,
    cellElementsMeta
  }, {
    groupOrientation,
    groupedByDate: groupByDate,
    groupCount: groups ? getGroupsLastRow(groups).length : 1
  });
};
var horizontalTimeTableRects = function(appointments2, startViewDate2, endViewDate2, viewCellsData2, cellElementsMeta, grouping, resources, groups, groupOrientation, sliceAppointments) {
  var intervals = calculateMonthDateIntervals(appointments2, startViewDate2, endViewDate2);
  var groupedIntervals = expandGroups(intervals, grouping, resources, groups, [], sliceAppointments);
  return calculateRectByDateAndGroupIntervals({
    growDirection: HORIZONTAL_TYPE,
    multiline: true
  }, groupedIntervals, getHorizontalRectByAppointmentData, {
    startViewDate: startViewDate2,
    endViewDate: endViewDate2,
    viewCellsData: viewCellsData2,
    cellElementsMeta
  }, {
    groupOrientation,
    groupedByDate: sliceAppointments,
    groupCount: groups ? getGroupsLastRow(groups).length : 1
  });
};
var dateTimeFormatInstance = function(locale2, formatOptions) {
  return new Intl.DateTimeFormat(locale2, formatOptions);
};
var appointments = function(data) {
  return data.map(function(appointment, index) {
    return __assign3(__assign3(__assign3(__assign3(__assign3({ dataItem: appointment, start: appointment.startDate }, appointment.endDate !== void 0 ? {
      end: appointment.endDate
    } : {
      end: appointment.startDate,
      dataItem: __assign3(__assign3({}, appointment), { endDate: appointment.startDate })
    }), appointment.allDay !== void 0 && {
      allDay: appointment.allDay
    }), appointment.rRule !== void 0 && {
      rRule: appointment.rRule
    }), appointment.exDate !== void 0 && {
      exDate: appointment.exDate
    }), { key: appointment.id || index });
  });
};
var formatDateTimeGetter = function(locale2) {
  var cache = /* @__PURE__ */ new Map();
  var formatter = function(nextDate, nextOptions) {
    if (nextDate === void 0)
      return "";
    var date = convertToMoment(nextDate).toDate();
    var formatInstance = cache.get(nextOptions);
    if (!formatInstance) {
      formatInstance = dateTimeFormatInstance(locale2, nextOptions);
      cache.set(nextOptions, formatInstance);
    }
    return formatInstance.format(date);
  };
  return formatter;
};
var getCellKey = function(groups, groupIndex, rowNumber) {
  var currentIndex = groupIndex;
  return groups.reduceRight(function(acc, groupRow, rowIndex) {
    if (rowNumber < rowIndex)
      return acc;
    var currentKey = groupRow[currentIndex].id;
    if (rowIndex > 0) {
      var currentRowLength = groups[rowIndex].length / groups[rowIndex - 1].length;
      currentIndex = Math.floor(currentIndex / currentRowLength);
    }
    return acc + currentKey;
  }, "");
};
var getRowFromGroups = function(width, groupRow, cellStyle, groups, rowIndex) {
  var row = [];
  var currentRowLength = groupRow.length;
  var standardWidth = width / getGroupsLastRow(groups).length;
  var colSpan = getGroupsLastRow(groups).length / currentRowLength;
  var _loop_1 = function(i2) {
    row = __spreadArray4(__spreadArray4([], __read3(row), false), __read3(groupRow.reduce(function(acc, group, index) {
      return __spreadArray4(__spreadArray4([], __read3(acc), false), [
        {
          group,
          colSpan,
          key: getCellKey(groups, index, rowIndex) + i2,
          left: cellStyle.left,
          endOfGroup: index === currentRowLength - 1
        }
      ], false);
    }, [])), false);
  };
  for (var i = 0; i < standardWidth; i += 1) {
    _loop_1(i);
  }
  return row;
};
var getVerticalRowFromGroups = function(groups, groupIndex, groupingPanelRowSpan, timeTableCellHeight, addAllDayHeight, allDayCellHeight) {
  return groups.reduce(function(acc, groupColumn, columnIndex) {
    var groupSpan = getGroupsLastRow(groups).length / groupColumn.length;
    var cellIndex2 = groupIndex / groupSpan;
    var baseHeight = groupingPanelRowSpan * groupSpan * timeTableCellHeight / getGroupsLastRow(groups).length;
    var allDayHeight = groupSpan * allDayCellHeight;
    return groupIndex % groupSpan !== 0 ? acc : __spreadArray4(__spreadArray4([], __read3(acc), false), [
      {
        group: groupColumn[cellIndex2],
        rowSpan: groupSpan,
        height: addAllDayHeight ? baseHeight + allDayHeight : baseHeight,
        key: getCellKey(groups, cellIndex2, columnIndex)
      }
    ], false);
  }, []);
};
var getLabelsForSingleGroup = function(groups, cellsData, groupIndex, groupHeight) {
  var currentGroupIndex = groupIndex * groupHeight;
  var nextGroupIndex = currentGroupIndex + groupHeight;
  return cellsData.slice(currentGroupIndex, nextGroupIndex - 1).reduce(function(acc, days2) {
    return __spreadArray4(__spreadArray4([], __read3(acc), false), [
      {
        startDate: days2[0].startDate,
        endDate: days2[0].endDate,
        key: days2[0].endDate + getCellKey(groups, groupIndex, groups.length - 1),
        groupingInfo: days2[0].groupingInfo
      }
    ], false);
  }, []);
};
var getLabelsForAllGroups = function(cellsData, groups, groupOrientation) {
  if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {
    return [cellsData.map(function(cellsRow) {
      return {
        startDate: cellsRow[0].startDate,
        endDate: cellsRow[0].endDate,
        groupingInfo: cellsRow[0].groupingInfo,
        key: cellsRow[0].endDate
      };
    })];
  }
  var groupCount = getGroupsLastRow(groups).length;
  var singleGroupHeight = cellsData.length / groupCount;
  return getGroupsLastRow(groups).reduce(function(acc, group, groupIndex) {
    return __spreadArray4(__spreadArray4([], __read3(acc), false), [
      getLabelsForSingleGroup(groups, cellsData, groupIndex, singleGroupHeight)
    ], false);
  }, []);
};
var prepareVerticalViewCellsData = function(cellsData, allDayCellsData) {
  var groupCount = (allDayCellsData === null || allDayCellsData === void 0 ? void 0 : allDayCellsData.length) || 1;
  var validCellsData = [];
  var groupHeight = cellsData.length / groupCount;
  for (var i = 0; i < groupCount; i += 1) {
    validCellsData.push(cellsData.slice(i * groupHeight, (i + 1) * groupHeight));
  }
  return validCellsData;
};
var changeCurrentDate = function(currentDate, _a2) {
  var nextDate = _a2.nextDate, step = _a2.step, amount = _a2.amount, direction = _a2.direction;
  return nextDate || moment_default(currentDate)[direction === "back" ? "subtract" : "add"](amount, step).toDate() || moment_default().subtract(amount, step);
};
var setCurrentViewName = function(currentViewName, nextViewName) {
  return nextViewName;
};
var setAppointmentMeta = function(prevAppointmentMeta, _a2) {
  var target = _a2.target, data = _a2.data;
  return { target, data };
};
var OPEN_COMMAND_BUTTON = "open";
var CLOSE_COMMAND_BUTTON = "close";
var DELETE_COMMAND_BUTTON = "delete";
var setAppointmentData = function(prevAppointmentData, _a2) {
  var appointmentData = _a2.appointmentData;
  return appointmentData;
};
var getWeekNumberLabels = function(getMessage) {
  return WEEK_NUMBER_LABELS.map(function(weekNumberLabel, index) {
    return {
      text: getMessage(weekNumberLabel),
      id: index
    };
  });
};
var getDaysOfWeek = function(formatDate, firstDayOfWeek) {
  var daysOfWeekArray = getDaysOfWeekArray(firstDayOfWeek);
  var daysOfWeekDates = getDaysOfWeekDates(firstDayOfWeek);
  return daysOfWeekDates.map(function(day, index) {
    return {
      text: getDayOfWeek(day, formatDate),
      id: index + 1 < DAYS_IN_WEEK ? daysOfWeekArray[index + 1] : daysOfWeekArray[0]
    };
  });
};
var getMonths = function(formatDate) {
  return MONTHS_DATES.map(function(month, index) {
    return {
      text: getMonth(month, formatDate),
      id: getMonthId(index)
    };
  });
};
var getMonthsWithOf = function(getMessage, formatDate) {
  return MONTHS_DATES.map(function(month, index) {
    return {
      text: getMonthWithOf(month, getMessage, formatDate),
      id: getMonthId(index)
    };
  });
};
var getMonthWithOf = function(date, getMessage, formatDate) {
  return getMessage("ofLabel") + formatDate(date, DAY_LONG_MONTH_OPTIONS).replace(/[\d.,]/g, "").toString();
};
var getMonth = function(date, formatDate) {
  return formatDate(date, LONG_MONTH_OPTIONS);
};
var getDayOfWeek = function(date, formatDate) {
  return formatDate(date, LONG_WEEK_DAY_OPTIONS);
};
var getMonthId = function(index) {
  return index + 1;
};
var getAvailableRecurrenceOptions = function(getMessage) {
  return REPEAT_TYPES_ARRAY.map(function(type) {
    return {
      text: getMessage(type),
      id: type
    };
  });
};
var getCountDependingOnRecurrenceType = function(frequency) {
  var count;
  switch (frequency) {
    case RRULE_REPEAT_TYPES.YEARLY:
      count = BASIC_YEALY_COUNT;
      break;
    case RRULE_REPEAT_TYPES.MONTHLY:
      count = BASIC_MONTHLY_COUNT;
      break;
    case RRULE_REPEAT_TYPES.WEEKLY:
      count = BASIC_WEEKLY_COUNT;
      break;
    case RRULE_REPEAT_TYPES.DAILY:
      count = BASIC_DAILY_COUNT;
      break;
  }
  return count;
};
var checkIsNaturalNumber = function(number) {
  return number > 0 && number <= Number.MAX_SAFE_INTEGER;
};
var callActionIfExists = function(action, payload) {
  if (action) {
    action(payload);
  }
};
var isAllDayCell = function(startDate, endDate) {
  return moment_default(endDate).diff(moment_default(startDate), "days") >= 1;
};
var changeRecurrenceFrequency = function(rule, freq, startDate) {
  if (!rule) {
    if (freq === RRULE_REPEAT_TYPES.MONTHLY) {
      return new RRule(__assign3(__assign3({}, DEFAULT_RULE_OBJECT), { freq, bymonthday: [startDate.getDate()], count: getCountDependingOnRecurrenceType(freq) })).toString();
    }
    if (freq === RRULE_REPEAT_TYPES.YEARLY) {
      return new RRule(__assign3(__assign3({}, DEFAULT_RULE_OBJECT), { freq, bymonthday: [startDate.getDate()], bymonth: startDate.getMonth() + 1, count: getCountDependingOnRecurrenceType(freq) })).toString();
    }
    return new RRule(__assign3(__assign3({}, DEFAULT_RULE_OBJECT), { freq, count: getCountDependingOnRecurrenceType(freq) })).toString();
  }
  var options = RRule.parseString(rule);
  if (options.freq === freq)
    return rule;
  options.freq = freq;
  options.count = getCountDependingOnRecurrenceType(freq);
  if (freq === RRULE_REPEAT_TYPES.MONTHLY || freq === RRULE_REPEAT_TYPES.YEARLY) {
    options.bymonthday = startDate.getDate();
  }
  if (freq === RRULE_REPEAT_TYPES.YEARLY) {
    options.bymonth = startDate.getMonth() + 1;
  }
  if (freq === RRULE_REPEAT_TYPES.DAILY || freq === RRULE_REPEAT_TYPES.WEEKLY) {
    options.bymonthday = void 0;
  }
  options.byweekday = void 0;
  var nextRule = new RRule(options);
  return nextRule.toString();
};
var getRecurrenceOptions = function(rule) {
  return !rule ? null : RRule.parseString(rule);
};
var changeRecurrenceOptions = function(options) {
  return options ? new RRule(__assign3({}, options)).toString() : void 0;
};
var handleStartDateChange = function(nextStartDay, options) {
  if (nextStartDay <= 31) {
    var nextOptions = __assign3(__assign3({}, options), { bymonthday: nextStartDay });
    return changeRecurrenceOptions(nextOptions);
  }
  return changeRecurrenceOptions(options);
};
var handleToDayOfWeekChange = function(weekNumber, dayOfWeek, options) {
  var validDayOfWeek = dayOfWeek > 0 ? dayOfWeek - 1 : 6;
  var validWeekNumber = weekNumber === 4 ? -1 : weekNumber + 1;
  var rruleDayOfWeek = RRULE_DAYS_OF_WEEK[validDayOfWeek];
  var nextOptions = __assign3(__assign3({}, options), { byweekday: [rruleDayOfWeek.nth(validWeekNumber)], bymonthday: void 0 });
  return changeRecurrenceOptions(nextOptions);
};
var getRRuleFrequency = function(repeatType) {
  return RRULE_REPEAT_TYPES[repeatType.toUpperCase()];
};
var getFrequencyString = function(rRuleFrequency) {
  if (rRuleFrequency === RRULE_REPEAT_TYPES.DAILY)
    return REPEAT_TYPES.DAILY;
  if (rRuleFrequency === RRULE_REPEAT_TYPES.WEEKLY)
    return REPEAT_TYPES.WEEKLY;
  if (rRuleFrequency === RRULE_REPEAT_TYPES.MONTHLY)
    return REPEAT_TYPES.MONTHLY;
  if (rRuleFrequency === RRULE_REPEAT_TYPES.YEARLY)
    return REPEAT_TYPES.YEARLY;
  return REPEAT_TYPES.NEVER;
};
var getRadioGroupDisplayData = function(recurrenceOptions, stateDayOfWeek, stateWeekNumber, stateDayNumber, firstOption, secondOption) {
  if (recurrenceOptions.bymonthday && !Array.isArray(recurrenceOptions.bymonthday)) {
    return {
      dayNumberTextField: recurrenceOptions.bymonthday,
      weekNumber: stateWeekNumber,
      dayOfWeek: stateDayOfWeek,
      radioGroupValue: firstOption
    };
  }
  if (!recurrenceOptions.byweekday) {
    return {
      dayOfWeek: stateDayOfWeek,
      weekNumber: stateWeekNumber,
      radioGroupValue: secondOption,
      dayNumberTextField: stateDayNumber
    };
  }
  var dayOfWeek = recurrenceOptions.byweekday[0].weekday < 6 ? recurrenceOptions.byweekday[0].weekday + 1 : 0;
  var weekNumber = recurrenceOptions.byweekday[0].n === -1 ? LAST_WEEK : recurrenceOptions.byweekday[0].n - 1;
  return {
    dayOfWeek,
    weekNumber,
    radioGroupValue: secondOption,
    dayNumberTextField: stateDayNumber
  };
};
var handleChangeFrequency = function(repeatType, rRule, startDate, action) {
  var rruleRepeatType = getRRuleFrequency(repeatType);
  var nextRRule;
  if (rruleRepeatType !== void 0) {
    nextRRule = changeRecurrenceFrequency(rRule, rruleRepeatType, startDate);
  }
  action({ rRule: nextRRule });
};
var handleWeekDaysChange = function(options, currentWeekDay) {
  var byWeekDay = options.byweekday || [];
  var index = byWeekDay.findIndex(function(_a2) {
    var weekday = _a2.weekday;
    return weekday === currentWeekDay;
  });
  var isAdded = index === -1;
  if (isAdded) {
    byWeekDay.push(RRULE_DAYS_OF_WEEK[currentWeekDay]);
  } else if (index > -1) {
    byWeekDay.splice(index, 1);
  }
  if (byWeekDay === 0)
    return __assign3(__assign3({}, options), { byweekday: void 0 });
  return __assign3(__assign3({}, options), { byweekday: byWeekDay });
};
var getDaysOfWeekArray = function(firstDayOfWeek) {
  var firstPart = DAYS_OF_WEEK_ARRAY.filter(function(dayOfWeek) {
    return dayOfWeek >= firstDayOfWeek - 1 && dayOfWeek < DAYS_IN_WEEK - 1;
  });
  var secondPart = DAYS_OF_WEEK_ARRAY.filter(function(dayOfWeek) {
    return dayOfWeek < firstDayOfWeek - 1 || dayOfWeek >= DAYS_IN_WEEK - 1;
  });
  return firstDayOfWeek !== 0 ? __spreadArray4(__spreadArray4([], __read3(firstPart), false), __read3(secondPart), false) : __spreadArray4(__spreadArray4([], __read3(secondPart), false), __read3(firstPart), false);
};
var getDaysOfWeekDates = function(firstDayOfWeek) {
  var firstPart = DAYS_OF_WEEK_DATES.slice(firstDayOfWeek, DAYS_OF_WEEK_DATES.length);
  var secondPart = DAYS_OF_WEEK_DATES.slice(0, firstDayOfWeek);
  return __spreadArray4(__spreadArray4([], __read3(firstPart), false), __read3(secondPart), false);
};
var checkMultipleResourceFields = function(resourceFields, resources) {
  return resources.reduce(function(acc, resource) {
    var _a2;
    if (!resource.allowMultiple) {
      return acc;
    }
    var fieldName = resource.fieldName;
    var field = resourceFields[fieldName];
    return __assign3(__assign3({}, acc), (_a2 = {}, _a2[fieldName] = Array.isArray(field) ? field : [field], _a2));
  }, resourceFields);
};
var addAppointment = function(addedAppointmentData, _a2) {
  var _b = _a2 === void 0 ? { appointmentData: {} } : _a2, appointmentData = _b.appointmentData;
  return appointmentData;
};
var cancelAddedAppointment = function() {
  return {};
};
var startEditAppointment = function(prevEditingAppointment, appointmentData) {
  return appointmentData;
};
var stopEditAppointment = function() {
  return null;
};
var changeAppointment = function(appointment, _a2) {
  var change = _a2.change;
  return __assign3(__assign3({}, appointment), change);
};
var cancelChanges = function() {
  return {};
};
var changedAppointmentById = function(changes, appointmentId) {
  var _a2;
  return _a2 = {}, _a2[appointmentId] = changes, _a2;
};
var mergeNewChanges = function(appointmentData, changes) {
  var appointment = __assign3({}, appointmentData);
  delete appointment.id;
  delete appointment.rRule;
  delete appointment.exDate;
  delete appointment.parentData;
  return __assign3(__assign3({}, appointment), changes);
};
var reduceExDate = function(prevExDate, boundDate) {
  if (prevExDate.length > 0) {
    return prevExDate.split(",").reduce(function(acc, date) {
      var momentDate = moment_default.utc(date);
      if (momentDate.isBefore(boundDate)) {
        return __spreadArray4(__spreadArray4([], __read3(acc), false), [date], false);
      }
      return acc;
    }, []).join(",");
  }
  return void 0;
};
var configureExDate = function(exDate, date) {
  var currentExDate = "".concat(moment_default.utc(date).format("YYYYMMDDTHHmmss"), "Z");
  return exDate ? "".concat(exDate, ",").concat(currentExDate) : currentExDate;
};
var configureDateSequence = function(rRule, exDate, prevStartDate, nextStartDate) {
  var rruleSet = getRRuleSetWithExDates(exDate);
  var currentOptions = RRule.parseString(rRule);
  var correctedOptions = currentOptions.until ? __assign3(__assign3({}, currentOptions), { until: moment_default(getUTCDate(currentOptions.until)).toDate() }) : currentOptions;
  var prevStartDateUTC = moment_default(getUTCDate(prevStartDate)).toDate();
  rruleSet.rrule(new RRule(__assign3(__assign3({}, correctedOptions), { dtstart: prevStartDateUTC })));
  if (currentOptions.count || currentOptions.until) {
    return {
      options: currentOptions,
      dates: rruleSet.all().map(function(nextDate) {
        return moment_default(formatDateToString(nextDate)).toDate();
      })
    };
  }
  var leftBound = prevStartDateUTC;
  var rightBound = moment_default(getUTCDate(nextStartDate)).toDate();
  return {
    options: currentOptions,
    dates: rruleSet.between(leftBound, rightBound, true).map(function(nextDate) {
      return moment_default(formatDateToString(nextDate)).toDate();
    })
  };
};
var configureICalendarRules = function(rRule, options) {
  var rruleSet = new RRuleSet();
  rruleSet.rrule(new RRule(__assign3(__assign3({}, RRule.parseString(rRule)), options)));
  return rruleSet.valueOf();
};
var changeCurrentAndFollowing = function(appointmentData, changes, changeAllAction) {
  var _a2;
  var rRule = appointmentData.rRule, startDate = appointmentData.startDate, parentData = appointmentData.parentData, _b = appointmentData.exDate, prevExDate = _b === void 0 ? "" : _b, id = appointmentData.id;
  var _c = getAppointmentSequenceData(parentData.startDate, moment_default.utc(startDate).toDate(), prevExDate, rRule), initialSequence = _c.initialSequence, currentChildIndex = _c.currentChildIndex;
  if (currentChildIndex === 0)
    return changeAllAction(appointmentData, changes);
  var changedRules = configureICalendarRules(rRule, {
    dtstart: moment_default.utc(parentData.startDate).toDate(),
    until: moment_default.utc(initialSequence[currentChildIndex - 1]).toDate(),
    count: null
  });
  var nextExDate = reduceExDate(prevExDate, startDate);
  return {
    changed: (_a2 = {}, _a2[id] = __assign3({ rRule: changedRules[1].slice(6) }, nextExDate && prevExDate !== nextExDate ? { exDate: nextExDate } : {}), _a2)
  };
};
var getAppointmentSequenceData = function(prevStartDate, startDate, exDate, rRule) {
  var initialSequence = configureDateSequence(rRule, exDate, moment_default.utc(prevStartDate).toDate(), moment_default.utc(startDate).toDate()).dates;
  var currentChildIndex = initialSequence.findIndex(function(date) {
    return moment_default(date).isSame(startDate);
  });
  return { initialSequence, currentChildIndex };
};
var deleteCurrent = function(appointmentData) {
  var _a2;
  var _b = configureDateSequence(appointmentData.rRule, appointmentData.exDate, moment_default.utc(appointmentData.parentData.startDate).toDate(), moment_default.utc(appointmentData.startDate).toDate()), options = _b.options, dates = _b.dates;
  if ((options.count || options.until) && dates.length === 1) {
    return deleteAll(appointmentData);
  }
  var nextExDate = configureExDate(appointmentData.exDate, appointmentData.startDate);
  return { changed: (_a2 = {}, _a2[appointmentData.id] = { exDate: nextExDate }, _a2) };
};
var deleteAll = function(appointmentData) {
  return { deleted: appointmentData.id };
};
var deleteCurrentAndFollowing = function(appointmentData) {
  return changeCurrentAndFollowing(appointmentData, {}, deleteAll);
};
var editAll = function(appointmentData, changes) {
  var _a2, _b;
  var rRule = appointmentData.rRule, id = appointmentData.id;
  var initialRule = new RRule(RRule.parseString(rRule));
  if (changes.startDate && moment_default.utc(changes.startDate).isAfter(initialRule.options.until)) {
    return {
      changed: (_a2 = {}, _a2[id] = __assign3(__assign3({}, changes), { rRule: "FREQ=DAILY;COUNT=1", exDate: "" }), _a2)
    };
  }
  return { changed: (_b = {}, _b[appointmentData.id] = changes, _b) };
};
var editCurrent = function(appointmentData, changes) {
  var _a2;
  return {
    changed: (_a2 = {}, _a2[appointmentData.id] = {
      exDate: configureExDate(appointmentData.exDate, appointmentData.startDate)
    }, _a2),
    added: mergeNewChanges(appointmentData, changes)
  };
};
var editCurrentAndFollowing = function(appointmentData, changes) {
  var rRule = appointmentData.rRule, startDate = appointmentData.startDate, _a2 = appointmentData.exDate, prevExDate = _a2 === void 0 ? "" : _a2, parentData = appointmentData.parentData;
  var initialRule = new RRule(RRule.parseString(rRule));
  var _b = getAppointmentSequenceData(parentData.startDate, moment_default.utc(startDate).toDate(), prevExDate, rRule), initialSequence = _b.initialSequence, currentChildIndex = _b.currentChildIndex;
  if (currentChildIndex === 0)
    return editAll(appointmentData, changes);
  var addedOptions = initialRule.options.count || initialRule.options.until ? { count: initialSequence.length - currentChildIndex } : {};
  var addedRules = configureICalendarRules(appointmentData.rRule, __assign3({ dtstart: moment_default.utc(startDate).toDate() }, addedOptions));
  var addedAppointment = moment_default.utc(changes.startDate).isAfter(initialRule.options.until) ? { rRule: "FREQ=DAILY;COUNT=1", exDate: "" } : { rRule: addedRules[1].slice(6) };
  return {
    changed: changeCurrentAndFollowing(appointmentData, changes, editAll).changed,
    added: __assign3(__assign3({}, addedAppointment), mergeNewChanges(appointmentData, changes))
  };
};
var preCommitChanges = function(changes, appointmentData, editType) {
  if (changes === null) {
    switch (editType) {
      case RECURRENCE_EDIT_SCOPE.ALL: {
        return deleteAll(appointmentData);
      }
      case RECURRENCE_EDIT_SCOPE.CURRENT: {
        return deleteCurrent(appointmentData);
      }
      case RECURRENCE_EDIT_SCOPE.CURRENT_AND_FOLLOWING: {
        return deleteCurrentAndFollowing(appointmentData);
      }
    }
  } else {
    switch (editType) {
      case RECURRENCE_EDIT_SCOPE.ALL: {
        return editAll(appointmentData, changes);
      }
      case RECURRENCE_EDIT_SCOPE.CURRENT: {
        return editCurrent(appointmentData, changes);
      }
      case RECURRENCE_EDIT_SCOPE.CURRENT_AND_FOLLOWING: {
        return editCurrentAndFollowing(appointmentData, changes);
      }
    }
  }
  return {};
};
var clamp2 = function(value, min2, max2) {
  return Math.max(Math.min(value, max2), min2);
};
var calculateInsideOffset = function(targetType, insidePart, cellDurationMinutes) {
  return targetType === VERTICAL_TYPE ? insidePart * cellDurationMinutes * 60 / 2 : 0;
};
var cellType = function(data) {
  return moment_default(data.startDate).isSame(data.endDate, "day") ? VERTICAL_TYPE : HORIZONTAL_TYPE;
};
var intervalDuration = function(data, type) {
  return moment_default(data.endDate).diff(data.startDate, type);
};
var cellIndex = function(getCellRects, clientOffset) {
  return getCellRects.findIndex(function(getCellRect2) {
    var _a2 = getCellRect2(), left = _a2.left, top = _a2.top, right = _a2.right, bottom = _a2.bottom;
    var isOver = clientOffset && clamp2(clientOffset.x, left, right) === clientOffset.x && clamp2(clientOffset.y, top, bottom) === clientOffset.y;
    return isOver;
  });
};
var cellData = function(timeTableIndex, allDayIndex, viewCellsData2, allDayCellsData) {
  var cellsData = allDayIndex !== -1 ? allDayCellsData : viewCellsData2;
  var currentIndex = allDayIndex !== -1 ? allDayIndex : timeTableIndex;
  var tableWidth = cellsData[0].length;
  var rowIndex = Math.floor(currentIndex / tableWidth);
  var columnIndex = currentIndex % tableWidth;
  return cellsData[rowIndex][columnIndex];
};
var autoScroll = function(clientOffset, scrollingStrategy, scrollSpeed) {
  scroll(clientOffset.y, scrollingStrategy.topBoundary, scrollingStrategy.bottomBoundary, scrollingStrategy.changeVerticalScroll, scrollSpeed);
  scroll(clientOffset.x, scrollingStrategy.leftBoundary, scrollingStrategy.rightBoundary, scrollingStrategy.changeHorizontalScroll, scrollSpeed);
};
var scroll = function(offset2, firstBoundary, secondBoundary, changeScroll, scrollSpeed) {
  if (offset2 < firstBoundary + SCROLL_OFFSET2 && offset2 > firstBoundary) {
    changeScroll(-scrollSpeed);
  }
  if (secondBoundary - SCROLL_OFFSET2 < offset2) {
    changeScroll(+scrollSpeed);
  }
};
var timeBoundariesByResize = function(payload, targetData, targetType, cellDurationMinutes, insidePart) {
  if (targetType !== payload.appointmentType) {
    return { appointmentStartTime: void 0, appointmentEndTime: void 0 };
  }
  var appointmentStartTime;
  var appointmentEndTime;
  var sourceType = payload.type;
  if (sourceType === RESIZE_TOP) {
    var insideTopOffset = calculateInsideOffset(targetType, insidePart, cellDurationMinutes);
    appointmentStartTime = moment_default(targetData.startDate).add(insideTopOffset, SECONDS).toDate();
    appointmentEndTime = moment_default(payload.endDate).toDate();
  }
  if (sourceType === RESIZE_BOTTOM) {
    var insideBottomOffset = insidePart === 0 && targetType === VERTICAL_TYPE ? cellDurationMinutes * 60 / 2 : 0;
    appointmentEndTime = moment_default(targetData.endDate).add(-insideBottomOffset, SECONDS).toDate();
    appointmentStartTime = moment_default(payload.startDate).toDate();
  }
  if (moment_default(appointmentEndTime).diff(appointmentStartTime, MINUTES) < 1) {
    appointmentStartTime = moment_default(payload.startDate).toDate();
    appointmentEndTime = moment_default(payload.endDate).toDate();
  }
  return { appointmentStartTime, appointmentEndTime };
};
var timeBoundariesByDrag = function(payload, targetData, targetType, cellDurationMinutes, insidePart, offsetTimeTopBase) {
  if (targetType === HORIZONTAL_TYPE && intervalDuration(payload, SECONDS) < intervalDuration(targetData, SECONDS)) {
    return {
      appointmentStartTime: targetData.startDate,
      appointmentEndTime: targetData.endDate,
      offsetTimeTop: 0
    };
  }
  var offsetTimeTop;
  var appointmentStartTime;
  var appointmentEndTime;
  var insideOffset = calculateInsideOffset(targetType, insidePart, cellDurationMinutes);
  var start = moment_default(targetData.startDate).add(insideOffset, SECONDS);
  if (offsetTimeTopBase === null) {
    offsetTimeTop = moment_default(targetData.startDate).diff(payload.startDate, SECONDS) + insideOffset;
  } else {
    offsetTimeTop = offsetTimeTopBase;
  }
  if (payload.type === targetType) {
    var appointmentDurationSeconds = intervalDuration(payload, SECONDS);
    appointmentStartTime = moment_default(start).add(offsetTimeTop * -1, SECONDS).toDate();
    appointmentEndTime = moment_default(start).add(appointmentDurationSeconds - offsetTimeTop, SECONDS).toDate();
  } else {
    appointmentStartTime = moment_default(targetData.startDate).add(insideOffset, SECONDS).toDate();
    appointmentEndTime = moment_default(targetData.endDate).add(insideOffset, SECONDS).toDate();
  }
  return { appointmentStartTime, appointmentEndTime, offsetTimeTop };
};
var calculateAppointmentTimeBoundaries = function(payload, targetData, targetType, cellDurationMinutes, insidePart, offsetTimeTopBase) {
  var isDragging = payload.type === VERTICAL_TYPE || payload.type === HORIZONTAL_TYPE;
  return isDragging ? timeBoundariesByDrag(payload, targetData, targetType, cellDurationMinutes, insidePart, offsetTimeTopBase) : timeBoundariesByResize(payload, targetData, targetType, cellDurationMinutes, insidePart);
};
var calculateInsidePart = function(top, timeTableCellsRects, timeTableIndex) {
  if (timeTableIndex !== void 0 && timeTableIndex !== -1) {
    var cellRect = timeTableCellsRects[timeTableIndex]();
    return top > cellRect.top + cellRect.height / 2 ? 1 : 0;
  }
  return 0;
};
var calculateDraftAppointments = function(allDayIndex, draftAppointments, startViewDate2, endViewDate2, excludedDays, viewCellsData2, getAllDayCellsElementRects, targetType, cellDurationMinutes, getTableCellElementRects, grouping, resources, groups, groupOrientation, groupedByDate) {
  if (allDayIndex !== -1 || targetType === VERTICAL_TYPE && getAllDayCellsElementRects.getCellRects.length && intervalDuration(draftAppointments[0].dataItem, HOURS) > 23) {
    var allDayDrafts = draftAppointments.map(function(draftAppt) {
      return __assign3(__assign3({}, draftAppt), { allDay: true });
    });
    return {
      allDayDraftAppointments: allDayRects(allDayDrafts, startViewDate2, endViewDate2, excludedDays, viewCellsData2, getAllDayCellsElementRects, grouping, resources, groups, groupOrientation, groupedByDate),
      timeTableDraftAppointments: []
    };
  }
  if (targetType === VERTICAL_TYPE || allDayIndex !== -1) {
    return {
      allDayDraftAppointments: [],
      timeTableDraftAppointments: verticalTimeTableRects(draftAppointments, startViewDate2, endViewDate2, excludedDays, viewCellsData2, cellDurationMinutes, getTableCellElementRects, grouping, resources, groups, groupOrientation, groupedByDate)
    };
  }
  return {
    allDayDraftAppointments: [],
    timeTableDraftAppointments: horizontalTimeTableRects(draftAppointments, startViewDate2, endViewDate2, viewCellsData2, getTableCellElementRects, grouping, resources, groups, groupOrientation, groupedByDate)
  };
};
var calculateAppointmentGroups = function(cellGroupingInfo, resources, appointmentData) {
  if (!cellGroupingInfo)
    return {};
  return cellGroupingInfo.reduce(function(acc, group) {
    var _a2;
    var isMultipleResource = resources.find(function(resource) {
      return resource.fieldName === group.fieldName;
    }).allowMultiple;
    return __assign3(__assign3({}, acc), (_a2 = {}, _a2[group.fieldName] = isMultipleResource ? updateMultipleResourceInfo(group, appointmentData) : group.id, _a2));
  }, {});
};
var updateMultipleResourceInfo = function(cellResource, appointmentData) {
  var appointmentGroupItems = appointmentData[cellResource.fieldName];
  if (appointmentGroupItems.findIndex(function(groupItem) {
    return groupItem === cellResource.id;
  }) !== -1) {
    return appointmentGroupItems;
  }
  return [cellResource.id];
};
var appointmentDragged = function(start, startPrev, end, endPrev, groupingInfo, groupingInfoPrev) {
  if (moment_default(start).isSame(startPrev) && moment_default(end).isSame(endPrev) && groupingInfoNotChanged(groupingInfo, groupingInfoPrev)) {
    return false;
  }
  return true;
};
var groupingInfoNotChanged = function(groupingInfo, groupingInfoPrev) {
  var fields = Object.getOwnPropertyNames(groupingInfo);
  return fields.every(function(field) {
    if (Array.isArray(groupingInfo[field]) && Array.isArray(groupingInfoPrev[field])) {
      return groupingInfo[field].every(function(item, index) {
        return item === groupingInfoPrev[field][index];
      });
    }
    return groupingInfo[field] === groupingInfoPrev[field];
  });
};
var isMonthCell = function(otherMonth) {
  return otherMonth !== void 0;
};
var isShadedAppointment = function(_a2, currentTime, shadePreviousAppointments) {
  var appointmentData = _a2.data;
  var momentCurrentDate = moment_default(currentTime);
  if (appointmentData.allDay) {
    return momentCurrentDate.isAfter(appointmentData.endDate, "day") && shadePreviousAppointments;
  }
  if (momentCurrentDate.isAfter(appointmentData.endDate)) {
    return shadePreviousAppointments;
  }
  return false;
};
var getCurrentTimeIndicatorTop = function(cellData2, currentTime) {
  var top = (currentTime - cellData2.startDate.getTime()) * 100 / (cellData2.endDate.getTime() - cellData2.startDate.getTime());
  return top < 0 || top > 100 ? void 0 : "".concat(top, "%");
};
var isCellShaded = function(_a2, currentTime, shadePreviousCells) {
  var startDate = _a2.startDate, endDate = _a2.endDate, otherMonth = _a2.otherMonth;
  var monthCell = isMonthCell(otherMonth);
  return (startDate.getTime() < currentTime && !monthCell || endDate.getTime() < currentTime && monthCell) && shadePreviousCells;
};
var getAppointmentResources = function(appointment, resources, plainResources) {
  if (!resources || resources.length === 0 || !plainResources || plainResources.length === 0)
    return [];
  return resources.reduce(function(acc, resource) {
    var appointmentResourceId = appointment[resource.fieldName];
    if (appointmentResourceId === void 0)
      return acc;
    if (resource.allowMultiple && !Array.isArray(appointmentResourceId) || !resource.allowMultiple && Array.isArray(appointmentResourceId)) {
      return acc;
    }
    if (resource.allowMultiple) {
      return __spreadArray4(__spreadArray4([], __read3(acc), false), __read3(appointmentResourceId.reduce(function(prevResources, itemId) {
        return addResourceToAppointmentResources(plainResources, prevResources, resource, itemId);
      }, [])), false);
    }
    return addResourceToAppointmentResources(plainResources, acc, resource, appointmentResourceId);
  }, []);
};
var addResourceToAppointmentResources = function(plainResources, appointmentResources, resource, resourceId) {
  var currentResource = plainResources.find(function(plainItem) {
    return resource.fieldName === plainItem.fieldName && plainItem.id === resourceId;
  });
  return currentResource ? __spreadArray4(__spreadArray4([], __read3(appointmentResources), false), [
    currentResource
  ], false) : appointmentResources;
};
var convertResourcesToPlain = function(validResources) {
  return validResources.reduce(function(acc, resource) {
    return __spreadArray4(__spreadArray4([], __read3(acc), false), __read3(resource.instances.map(function(item) {
      return item;
    })), false);
  }, []);
};
var validateResources = function(resources, mainResourceName, palette) {
  var isMainResourceDefined = !!mainResourceName;
  var currentPaletteIndex = 0;
  return resources.map(function(resource, groupIndex) {
    var fieldName = resource.fieldName;
    var isMain = isMainResourceDefined && mainResourceName === fieldName || groupIndex === 0 && !isMainResourceDefined;
    var title = resource.title || fieldName;
    var allowMultiple = !!resource.allowMultiple;
    return {
      fieldName,
      isMain,
      title,
      allowMultiple,
      instances: resource.instances.map(function(resourceItem) {
        var color = resourceItem.color || palette[currentPaletteIndex % palette.length];
        if (!resourceItem.color)
          currentPaletteIndex += 1;
        return {
          id: resourceItem.id,
          color,
          fieldName,
          text: resourceItem.text || title || fieldName,
          title,
          allowMultiple,
          isMain
        };
      })
    };
  });
};
var addResourcesToAppointments = function(appointments2, resources, plainResources) {
  return [
    appointments2.map(function(appointment) {
      return __assign3(__assign3({}, appointment), { resources: getAppointmentResources(appointment.dataItem, resources, plainResources) });
    })
  ];
};
var toggleExpandedGroups = function(state, _a2) {
  var groupKey = _a2.groupKey;
  var expandedGroups = slice(state.expandedGroups);
  var groupKeyIndex = expandedGroups.indexOf(groupKey);
  if (groupKeyIndex > -1) {
    expandedGroups.splice(groupKeyIndex, 1);
  } else {
    expandedGroups.push(groupKey);
  }
  return { expandedGroups };
};
var getDayScaleCellColSpan = function(cellsData) {
  var firstDate = cellsData[0][0].startDate;
  var count = 1;
  while (cellsData[0][count] && moment_default(cellsData[0][count].startDate).isSame(firstDate, "day")) {
    count += 1;
  }
  return count;
};
var getDayScaleCells = function(cellsData, groupedByDate) {
  if (!groupedByDate) {
    return cellsData[0].map(function(_a2, index) {
      var startDate = _a2.startDate, endDate = _a2.endDate, today = _a2.today, endOfGroup = _a2.endOfGroup, groupingInfo = _a2.groupingInfo;
      return {
        key: index.toString(),
        startDate,
        endDate,
        today,
        endOfGroup,
        groupingInfo
      };
    });
  }
  var prevDate;
  var colSpan = getDayScaleCellColSpan(cellsData);
  return cellsData[0].reduce(function(acc, _a2, index) {
    var startDate = _a2.startDate, endDate = _a2.endDate, today = _a2.today;
    var currentDate = moment_default(startDate);
    if (currentDate.isSame(prevDate)) {
      return acc;
    }
    prevDate = currentDate;
    return __spreadArray4(__spreadArray4([], __read3(acc), false), [
      {
        key: index.toString(),
        startDate,
        endDate,
        today,
        colSpan,
        endOfGroup: true
      }
    ], false);
  }, []);
};
var navigateByOneMonth = function(currentDate, isBackward) {
  return moment_default(currentDate)[isBackward ? "subtract" : "add"](1, "month").toDate();
};
var RecurrenceFrequency;
(function(RecurrenceFrequency2) {
  RecurrenceFrequency2[RecurrenceFrequency2["Daily"] = RRULE_REPEAT_TYPES.DAILY] = "Daily";
  RecurrenceFrequency2[RecurrenceFrequency2["Weekly"] = RRULE_REPEAT_TYPES.WEEKLY] = "Weekly";
  RecurrenceFrequency2[RecurrenceFrequency2["Monthly"] = RRULE_REPEAT_TYPES.MONTHLY] = "Monthly";
  RecurrenceFrequency2[RecurrenceFrequency2["Yearly"] = RRULE_REPEAT_TYPES.YEARLY] = "Yearly";
})(RecurrenceFrequency || (RecurrenceFrequency = {}));

// node_modules/@devexpress/dx-react-scheduler/dist/dx-react-scheduler.es.js
var extendStatics3 = function(d, b) {
  extendStatics3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics3(d, b);
};
function __extends3(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics3(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign4 = function() {
  __assign4 = Object.assign || function __assign5(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign4.apply(this, arguments);
};
function __rest3(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __read4(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
var SchedulerCoreBase = function(_super) {
  __extends3(SchedulerCoreBase2, _super);
  function SchedulerCoreBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.formatDateTimeGetter = memoize(function(locale2) {
      return formatDateTimeGetter(locale2);
    });
    return _this;
  }
  SchedulerCoreBase2.prototype.render = function() {
    var _a2 = this.props, data = _a2.data, Root = _a2.rootComponent, locale2 = _a2.locale, height = _a2.height, firstDayOfWeek = _a2.firstDayOfWeek;
    return (0, import_react2.createElement)(
      Plugin,
      { name: "SchedulerCore" },
      (0, import_react2.createElement)(Getter, { name: "appointments", value: appointments(data) }),
      (0, import_react2.createElement)(Getter, { name: "formatDate", value: this.formatDateTimeGetter(locale2) }),
      (0, import_react2.createElement)(Getter, { name: "firstDayOfWeek", value: firstDayOfWeek }),
      (0, import_react2.createElement)(Getter, { name: "locale", value: locale2 }),
      (0, import_react2.createElement)(
        Template,
        { name: "root" },
        (0, import_react2.createElement)(
          Root,
          { height },
          (0, import_react2.createElement)(TemplatePlaceholder, { name: "schedulerRoot" }),
          (0, import_react2.createElement)(TemplatePlaceholder, { name: "header" }),
          (0, import_react2.createElement)(TemplatePlaceholder, { name: "body" }),
          (0, import_react2.createElement)(TemplatePlaceholder, { name: "footer" })
        )
      )
    );
  };
  return SchedulerCoreBase2;
}(import_react2.PureComponent);
var SchedulerCore = SchedulerCoreBase;
var SchedulerBase = function(_a2) {
  var data = _a2.data, rootComponent = _a2.rootComponent, children = _a2.children, locale2 = _a2.locale, height = _a2.height, firstDayOfWeek = _a2.firstDayOfWeek;
  return (0, import_react2.createElement)(
    PluginHost2,
    null,
    (0, import_react2.createElement)(SchedulerCore, { data, rootComponent, locale: locale2, height, firstDayOfWeek }),
    children
  );
};
SchedulerBase.defaultProps = {
  data: [],
  locale: "en-US",
  height: "auto",
  firstDayOfWeek: 0
};
var Scheduler = SchedulerBase;
var CellPlaceholder = function(params) {
  return (0, import_react2.createElement)(TemplatePlaceholder, { name: "cell", params });
};
var TimeTableAppointmentLayer = function() {
  return (0, import_react2.createElement)(TemplatePlaceholder, { name: "timeTableAppointmentLayer" });
};
var startViewDateBaseComputed = function(_a2) {
  var viewCellsData2 = _a2.viewCellsData;
  return startViewDate(viewCellsData2);
};
var endViewDateBaseComputed = function(_a2) {
  var viewCellsData2 = _a2.viewCellsData;
  return endViewDate(viewCellsData2);
};
var TimeTablePlaceholder = function() {
  return (0, import_react2.createElement)(TemplatePlaceholder, { name: "timeTable" });
};
var DayScalePlaceholder = function() {
  return (0, import_react2.createElement)(TemplatePlaceholder, { name: "dayScale" });
};
var DayScaleEmptyCellPlaceholder = function() {
  return (0, import_react2.createElement)(TemplatePlaceholder, { name: "dayScaleEmptyCell" });
};
var GroupingPanelPlaceholder = function() {
  return (0, import_react2.createElement)(TemplatePlaceholder, { name: "groupingPanel" });
};
var BasicViewBase = function(_super) {
  __extends3(BasicViewBase2, _super);
  function BasicViewBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.state = {
      timeTableElementsMeta: {},
      scrollingStrategy: {
        topBoundary: 0,
        bottomBoundary: 0,
        leftBoundary: 0,
        rightBoundary: 0,
        changeVerticalScroll: function() {
          return void 0;
        },
        changeHorizontalScroll: function() {
          return void 0;
        }
      },
      previousTimeTableCell: null,
      // The key has to be generated every time the TimeTableCell is updated to rerender TimeTable
      // and, consequently, update timeTableElementsMeta
      timeTableLayoutKey: 0
    };
    _this.scrollingStrategyComputed = memoize(function(viewName, scrollingStrategy) {
      return function(getters) {
        return computed(getters, viewName, function() {
          return scrollingStrategy;
        }, getters.scrollingStrategy);
      };
    });
    _this.timeTableElementsMetaComputed = memoize(function(viewName, timeTableElementsMeta) {
      return function(getters) {
        return computed(getters, viewName, function() {
          return timeTableElementsMeta;
        }, getters.timeTableElementsMeta);
      };
    });
    _this.intervalCountComputed = memoize(function(viewName, intervalCount) {
      return function(getters) {
        return computed(getters, viewName, function() {
          return intervalCount;
        }, getters.intervalCount);
      };
    });
    _this.cellDurationComputed = memoize(function(viewName, cellDuration) {
      return function(getters) {
        return computed(getters, viewName, function() {
          return cellDuration;
        }, getters.cellDuration);
      };
    });
    _this.excludedDaysComputed = memoize(function(viewName, excludedDays) {
      return function(getters) {
        return computed(getters, viewName, function() {
          return excludedDays;
        }, getters.excludedDays);
      };
    });
    _this.availableViewsComputed = memoize(function(viewName, viewDisplayName) {
      return function(_a2) {
        var availableViews$1 = _a2.availableViews;
        return availableViews(availableViews$1, viewName, viewDisplayName);
      };
    });
    _this.currentViewComputed = memoize(function(viewName, viewDisplayName, type) {
      return function(_a2) {
        var currentView = _a2.currentView;
        return currentView && currentView.name !== viewName ? currentView : { name: viewName, type, displayName: viewDisplayName };
      };
    });
    _this.endViewDateComputed = function(getters) {
      var viewName = _this.props.name;
      return computed(getters, viewName, endViewDateBaseComputed, getters.endViewDate);
    };
    _this.startViewDateComputed = function(getters) {
      var viewName = _this.props.name;
      return computed(getters, viewName, startViewDateBaseComputed, getters.startViewDate);
    };
    _this.viewCellsDataComputed = memoize(function(viewName, cellDuration, startDayHour, endDayHour, viewCellsDataBaseComputed2) {
      return function(getters) {
        return computed(getters, viewName, viewCellsDataBaseComputed2(cellDuration, startDayHour, endDayHour), getters.viewCellsData);
      };
    });
    _this.timeTableAppointmentsComputed = memoize(function(viewName, cellDuration, calculateAppointmentsIntervals) {
      return function(getters) {
        return computed(getters, viewName, calculateAppointmentsIntervals(cellDuration), getters.timeTableAppointments);
      };
    });
    _this.updateCellElementsMeta = memoize(function(cellElementsMeta) {
      _this.setState({ timeTableElementsMeta: cellElementsMeta });
    });
    _this.setScrollingStrategy = function(scrollingStrategy) {
      _this.setState({ scrollingStrategy });
    };
    return _this;
  }
  BasicViewBase2.getDerivedStateFromProps = function(props, state) {
    if (props.timeTableCellComponent !== state.previousTimeTableCell) {
      return __assign4(__assign4({}, state), { previousTimeTableCell: props.timeTableCellComponent, timeTableLayoutKey: Math.random() });
    }
    return null;
  };
  BasicViewBase2.prototype.render = function() {
    var _this = this;
    var _a2 = this.props, viewName = _a2.name, intervalCount = _a2.intervalCount, displayName = _a2.displayName, type = _a2.type, excludedDays = _a2.excludedDays, cellDuration = _a2.cellDuration, startDayHour = _a2.startDayHour, endDayHour = _a2.endDayHour, viewCellsDataComputed = _a2.viewCellsDataComputed, calculateAppointmentsIntervals = _a2.calculateAppointmentsIntervals, dayScaleCellComponent = _a2.dayScaleCellComponent, dayScaleRowComponent = _a2.dayScaleRowComponent, DayScale = _a2.dayScaleLayoutComponent, TimeTableCell = _a2.timeTableCellComponent, TimeTableLayout = _a2.timeTableLayoutComponent, timeTableRowComponent = _a2.timeTableRowComponent, AppointmentLayer = _a2.appointmentLayerComponent, DayScaleEmptyCell = _a2.dayScaleEmptyCellComponent, layoutProps = _a2.layoutProps, Layout = _a2.layoutComponent;
    var _b = this.state, timeTableElementsMeta = _b.timeTableElementsMeta, scrollingStrategy = _b.scrollingStrategy, timeTableLayoutKey = _b.timeTableLayoutKey;
    var viewDisplayName = displayName || viewName;
    return (0, import_react2.createElement)(
      Plugin,
      { name: "basicView" },
      (0, import_react2.createElement)(Getter, { name: "availableViews", computed: this.availableViewsComputed(viewName, viewDisplayName) }),
      (0, import_react2.createElement)(Getter, { name: "currentView", computed: this.currentViewComputed(viewName, viewDisplayName, type) }),
      (0, import_react2.createElement)(Getter, { name: "intervalCount", computed: this.intervalCountComputed(viewName, intervalCount) }),
      (0, import_react2.createElement)(Getter, { name: "excludedDays", computed: this.excludedDaysComputed(viewName, excludedDays) }),
      (0, import_react2.createElement)(Getter, { name: "viewCellsData", computed: this.viewCellsDataComputed(viewName, cellDuration, startDayHour, endDayHour, viewCellsDataComputed) }),
      (0, import_react2.createElement)(Getter, { name: "startViewDate", computed: this.startViewDateComputed }),
      (0, import_react2.createElement)(Getter, { name: "endViewDate", computed: this.endViewDateComputed }),
      (0, import_react2.createElement)(Getter, { name: "cellDuration", computed: this.cellDurationComputed(viewName, cellDuration) }),
      (0, import_react2.createElement)(Getter, { name: "timeTableElementsMeta", computed: this.timeTableElementsMetaComputed(viewName, timeTableElementsMeta) }),
      (0, import_react2.createElement)(Getter, { name: "scrollingStrategy", computed: this.scrollingStrategyComputed(viewName, scrollingStrategy) }),
      (0, import_react2.createElement)(Getter, { name: "timeTableAppointments", computed: this.timeTableAppointmentsComputed(viewName, cellDuration, calculateAppointmentsIntervals) }),
      (0, import_react2.createElement)(Template, { name: "body" }, function(params) {
        return (0, import_react2.createElement)(TemplateConnector, null, function(_a3) {
          var currentView = _a3.currentView, groupOrientation = _a3.groupOrientation, groups = _a3.groups;
          if (currentView.name !== viewName)
            return (0, import_react2.createElement)(TemplatePlaceholder, null);
          var isVerticalGrouping2 = (groupOrientation === null || groupOrientation === void 0 ? void 0 : groupOrientation(viewName)) === VERTICAL_GROUP_ORIENTATION;
          return (0, import_react2.createElement)(Layout, __assign4({ forwardedRef: params === null || params === void 0 ? void 0 : params.forwardedRef, dayScaleComponent: DayScalePlaceholder, timeTableComponent: TimeTablePlaceholder, setScrollingStrategy: _this.setScrollingStrategy, groupingPanelComponent: isVerticalGrouping2 ? GroupingPanelPlaceholder : void 0, groupingPanelSize: isVerticalGrouping2 ? groups === null || groups === void 0 ? void 0 : groups.length : 0, dayScaleEmptyCellComponent: DayScaleEmptyCellPlaceholder }, layoutProps));
        });
      }),
      (0, import_react2.createElement)(
        Template,
        { name: "dayScale" },
        (0, import_react2.createElement)(TemplateConnector, null, function(_a3) {
          var currentView = _a3.currentView, viewCellsData2 = _a3.viewCellsData, formatDate = _a3.formatDate, groupByDate = _a3.groupByDate, groupOrientation = _a3.groupOrientation;
          if (currentView.name !== viewName)
            return (0, import_react2.createElement)(TemplatePlaceholder, null);
          var groupByDateEnabled = groupByDate === null || groupByDate === void 0 ? void 0 : groupByDate(viewName);
          var isHorizontalGrouping = (groupOrientation === null || groupOrientation === void 0 ? void 0 : groupOrientation(viewName)) === HORIZONTAL_GROUP_ORIENTATION;
          return (0, import_react2.createElement)(DayScale, { cellComponent: dayScaleCellComponent, rowComponent: dayScaleRowComponent, groupingPanelComponent: isHorizontalGrouping ? GroupingPanelPlaceholder : void 0, cellsData: viewCellsData2, formatDate, groupedByDate: groupByDateEnabled });
        })
      ),
      (0, import_react2.createElement)(Template, { name: "cell" }, function(params) {
        return (0, import_react2.createElement)(TemplateConnector, null, function(_a3) {
          var currentView = _a3.currentView;
          if (currentView.name !== viewName)
            return (0, import_react2.createElement)(TemplatePlaceholder, { params });
          return (0, import_react2.createElement)(TimeTableCell, __assign4({}, params));
        });
      }),
      (0, import_react2.createElement)(Template, { name: "timeTable" }, function(params) {
        return (0, import_react2.createElement)(TemplateConnector, null, function(_a3) {
          var formatDate = _a3.formatDate, currentView = _a3.currentView, viewCellsData2 = _a3.viewCellsData;
          if (currentView.name !== viewName)
            return (0, import_react2.createElement)(TemplatePlaceholder, null);
          return (0, import_react2.createElement)(
            import_react2.Fragment,
            null,
            (0, import_react2.createElement)(TimeTableLayout, __assign4({ cellsData: viewCellsData2, rowComponent: timeTableRowComponent, cellComponent: CellPlaceholder, formatDate, setCellElementsMeta: _this.updateCellElementsMeta, key: timeTableLayoutKey }, params)),
            (0, import_react2.createElement)(
              AppointmentLayer,
              null,
              (0, import_react2.createElement)(TimeTableAppointmentLayer, null)
            )
          );
        });
      }),
      (0, import_react2.createElement)(
        Template,
        { name: "dayScaleEmptyCell" },
        (0, import_react2.createElement)(TemplateConnector, null, function(_a3) {
          var currentView = _a3.currentView;
          if (currentView.name !== viewName || !DayScaleEmptyCell) {
            return (0, import_react2.createElement)(TemplatePlaceholder, null);
          }
          return (0, import_react2.createElement)(DayScaleEmptyCell, null);
        })
      )
    );
  };
  return BasicViewBase2;
}(import_react2.PureComponent);
var BasicView = BasicViewBase;
var calculateAppointmentsIntervalsBaseComputed = function(cellDuration) {
  return function(_a2) {
    var appointments2 = _a2.appointments, startViewDate2 = _a2.startViewDate, endViewDate2 = _a2.endViewDate, excludedDays = _a2.excludedDays;
    return calculateWeekDateIntervals(appointments2, startViewDate2, endViewDate2, excludedDays, cellDuration);
  };
};
var timeCellsDataComputed = function(startDayHour, endDayHour) {
  return function(_a2) {
    var viewCellsData2 = _a2.viewCellsData, cellDuration = _a2.cellDuration;
    return timeCellsData(viewCellsData2, startDayHour, endDayHour, cellDuration, Date.now());
  };
};
var TimeScalePlaceholder = function() {
  return (0, import_react2.createElement)(TemplatePlaceholder, { name: "timeScale" });
};
var VericalViewBase = function(_super) {
  __extends3(VericalViewBase2, _super);
  function VericalViewBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.timeCellsDataComputed = memoize(function(viewName, startDayHour, endDayHour) {
      return function(getters) {
        return computed(getters, viewName, timeCellsDataComputed(startDayHour, endDayHour), getters.timeCellsData);
      };
    });
    return _this;
  }
  VericalViewBase2.prototype.render = function() {
    var _a2 = this.props, layoutComponent = _a2.layoutComponent, dayScaleEmptyCellComponent = _a2.dayScaleEmptyCellComponent, TimeScale = _a2.timeScaleLayoutComponent, TimeScaleLabel = _a2.timeScaleLabelComponent, timeScaleTickCellComponent = _a2.timeScaleTickCellComponent, timeScaleTicksRowComponent = _a2.timeScaleTicksRowComponent, dayScaleLayoutComponent = _a2.dayScaleLayoutComponent, dayScaleCellComponent = _a2.dayScaleCellComponent, dayScaleRowComponent = _a2.dayScaleRowComponent, timeTableLayoutComponent = _a2.timeTableLayoutComponent, timeTableRowComponent = _a2.timeTableRowComponent, timeTableCellComponent = _a2.timeTableCellComponent, cellDuration = _a2.cellDuration, excludedDays = _a2.excludedDays, viewName = _a2.name, appointmentLayerComponent = _a2.appointmentLayerComponent, intervalCount = _a2.intervalCount, displayName = _a2.displayName, startDayHour = _a2.startDayHour, endDayHour = _a2.endDayHour, viewCellsDataComputed = _a2.viewCellsDataComputed, type = _a2.type;
    return (0, import_react2.createElement)(
      Plugin,
      { name: "WeekView" },
      (0, import_react2.createElement)(BasicView, { viewCellsDataComputed, type, cellDuration, name: viewName, intervalCount, displayName, startDayHour, endDayHour, excludedDays, calculateAppointmentsIntervals: calculateAppointmentsIntervalsBaseComputed, dayScaleEmptyCellComponent, dayScaleLayoutComponent, dayScaleCellComponent, dayScaleRowComponent, timeTableCellComponent, timeTableLayoutComponent, timeTableRowComponent, appointmentLayerComponent, layoutComponent, layoutProps: {
        timeScaleComponent: TimeScalePlaceholder
      } }),
      (0, import_react2.createElement)(Getter, { name: "timeCellsData", computed: this.timeCellsDataComputed(viewName, startDayHour, endDayHour) }),
      (0, import_react2.createElement)(Template, { name: "timeScale" }, function(params) {
        return (0, import_react2.createElement)(TemplateConnector, null, function(_a3) {
          var currentView = _a3.currentView, timeCellsData2 = _a3.timeCellsData, groups = _a3.groups, formatDate = _a3.formatDate, getGroupOrientation = _a3.groupOrientation, timeTableElementsMeta = _a3.timeTableElementsMeta;
          if (currentView.name !== viewName)
            return (0, import_react2.createElement)(TemplatePlaceholder, null);
          var groupOrientation = getGroupOrientation === null || getGroupOrientation === void 0 ? void 0 : getGroupOrientation(viewName);
          return (0, import_react2.createElement)(TimeScale, __assign4({ labelComponent: TimeScaleLabel, tickCellComponent: timeScaleTickCellComponent, rowComponent: timeScaleTicksRowComponent, cellsData: timeCellsData2, formatDate, groups, groupOrientation, height: getTimeTableHeight(timeTableElementsMeta) }, params));
        });
      })
    );
  };
  return VericalViewBase2;
}(import_react2.PureComponent);
var VerticalView = VericalViewBase;
var viewCellsDataBaseComputed = function(cellDuration, startDayHour, endDayHour) {
  return function(_a2) {
    var currentDate = _a2.currentDate, intervalCount = _a2.intervalCount;
    return viewCellsData(currentDate, void 0, intervalCount, [], startDayHour, endDayHour, cellDuration, Date.now());
  };
};
var DayViewBase = function(_super) {
  __extends3(DayViewBase2, _super);
  function DayViewBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  DayViewBase2.prototype.render = function() {
    var _a2 = this.props, layoutComponent = _a2.layoutComponent, DayScaleEmptyCell = _a2.dayScaleEmptyCellComponent, timeScaleLayoutComponent = _a2.timeScaleLayoutComponent, timeScaleLabelComponent = _a2.timeScaleLabelComponent, timeScaleTickCellComponent = _a2.timeScaleTickCellComponent, timeScaleTicksRowComponent = _a2.timeScaleTicksRowComponent, dayScaleLayoutComponent = _a2.dayScaleLayoutComponent, dayScaleCellComponent = _a2.dayScaleCellComponent, dayScaleRowComponent = _a2.dayScaleRowComponent, timeTableLayoutComponent = _a2.timeTableLayoutComponent, timeTableRowComponent = _a2.timeTableRowComponent, timeTableCellComponent = _a2.timeTableCellComponent, appointmentLayerComponent = _a2.appointmentLayerComponent, cellDuration = _a2.cellDuration, viewName = _a2.name, intervalCount = _a2.intervalCount, displayName = _a2.displayName, startDayHour = _a2.startDayHour, endDayHour = _a2.endDayHour;
    return (0, import_react2.createElement)(
      Plugin,
      { name: "DayView" },
      (0, import_react2.createElement)(VerticalView, { viewCellsDataComputed: viewCellsDataBaseComputed, type: VIEW_TYPES.DAY, cellDuration, name: viewName, intervalCount, displayName, startDayHour, endDayHour, dayScaleEmptyCellComponent: DayScaleEmptyCell, dayScaleLayoutComponent, dayScaleCellComponent, dayScaleRowComponent, timeTableCellComponent, timeTableLayoutComponent, timeTableRowComponent, appointmentLayerComponent, layoutComponent, timeScaleLayoutComponent, timeScaleLabelComponent, timeScaleTickCellComponent, timeScaleTicksRowComponent })
    );
  };
  DayViewBase2.defaultProps = {
    name: "Day",
    startDayHour: 0,
    endDayHour: 24,
    cellDuration: 30,
    intervalCount: 1
  };
  DayViewBase2.components = {
    layoutComponent: "Layout",
    layoutContainer: "LayoutContainer",
    appointmentLayerComponent: "AppointmentLayer",
    dayScaleEmptyCellComponent: "DayScaleEmptyCell",
    timeScaleLayoutComponent: "TimeScaleLayout",
    timeScaleLabelComponent: "TimeScaleLabel",
    timeScaleTickCellComponent: "TimeScaleTickCell",
    timeScaleTicksRowComponent: "TimeScaleTicksRow",
    dayScaleLayoutComponent: "DayScaleLayout",
    dayScaleCellComponent: "DayScaleCell",
    dayScaleRowComponent: "DayScaleRow",
    timeTableContainerComponent: "TimeTableContainer",
    timeTableLayoutComponent: "TimeTableLayout",
    timeTableCellComponent: "TimeTableCell",
    timeTableRowComponent: "TimeTableRow"
  };
  return DayViewBase2;
}(import_react2.PureComponent);
var DayView = DayViewBase;
var DAYS_IN_WEEK2 = 7;
var viewCellsDataBaseComputed$1 = function(cellDuration, startDayHour, endDayHour) {
  return function(_a2) {
    var firstDayOfWeek = _a2.firstDayOfWeek, intervalCount = _a2.intervalCount, excludedDays = _a2.excludedDays, currentDate = _a2.currentDate;
    return viewCellsData(currentDate, firstDayOfWeek, intervalCount * DAYS_IN_WEEK2, excludedDays, startDayHour, endDayHour, cellDuration, Date.now());
  };
};
var WeekViewBase = function(_super) {
  __extends3(WeekViewBase2, _super);
  function WeekViewBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  WeekViewBase2.prototype.render = function() {
    var _a2 = this.props, layoutComponent = _a2.layoutComponent, dayScaleEmptyCellComponent = _a2.dayScaleEmptyCellComponent, timeScaleLayoutComponent = _a2.timeScaleLayoutComponent, timeScaleLabelComponent = _a2.timeScaleLabelComponent, timeScaleTickCellComponent = _a2.timeScaleTickCellComponent, timeScaleTicksRowComponent = _a2.timeScaleTicksRowComponent, dayScaleLayoutComponent = _a2.dayScaleLayoutComponent, dayScaleCellComponent = _a2.dayScaleCellComponent, dayScaleRowComponent = _a2.dayScaleRowComponent, timeTableLayoutComponent = _a2.timeTableLayoutComponent, timeTableRowComponent = _a2.timeTableRowComponent, timeTableCellComponent = _a2.timeTableCellComponent, cellDuration = _a2.cellDuration, excludedDays = _a2.excludedDays, viewName = _a2.name, appointmentLayerComponent = _a2.appointmentLayerComponent, intervalCount = _a2.intervalCount, displayName = _a2.displayName, startDayHour = _a2.startDayHour, endDayHour = _a2.endDayHour;
    return (0, import_react2.createElement)(
      Plugin,
      { name: "WeekView" },
      (0, import_react2.createElement)(VerticalView, { viewCellsDataComputed: viewCellsDataBaseComputed$1, type: VIEW_TYPES.WEEK, cellDuration, name: viewName, intervalCount, displayName, startDayHour, endDayHour, excludedDays, dayScaleEmptyCellComponent, dayScaleLayoutComponent, dayScaleCellComponent, dayScaleRowComponent, timeTableCellComponent, timeTableLayoutComponent, timeTableRowComponent, appointmentLayerComponent, layoutComponent, timeScaleLayoutComponent, timeScaleLabelComponent, timeScaleTickCellComponent, timeScaleTicksRowComponent })
    );
  };
  WeekViewBase2.defaultProps = {
    startDayHour: 0,
    endDayHour: 24,
    cellDuration: 30,
    intervalCount: 1,
    excludedDays: [],
    name: "Week"
  };
  WeekViewBase2.components = {
    layoutComponent: "Layout",
    layoutContainerComponent: "LayoutContainer",
    appointmentLayerComponent: "AppointmentLayer",
    dayScaleEmptyCellComponent: "DayScaleEmptyCell",
    timeScaleLayoutComponent: "TimeScaleLayout",
    timeScaleLabelComponent: "TimeScaleLabel",
    timeScaleTickCellComponent: "TimeScaleTickCell",
    timeScaleTicksRowComponent: "TimeScaleTicksRow",
    dayScaleLayoutComponent: "DayScaleLayout",
    dayScaleCellComponent: "DayScaleCell",
    dayScaleRowComponent: "DayScaleRow",
    timeTableContainerComponent: "TimeTableContainer",
    timeTableLayoutComponent: "TimeTableLayout",
    timeTableCellComponent: "TimeTableCell",
    timeTableRowComponent: "TimeTableRow"
  };
  return WeekViewBase2;
}(import_react2.PureComponent);
var WeekView = WeekViewBase;
var viewCellsDataBaseComputed$2 = function(cellDuration, startDayHour, endDayHour) {
  return function(_a2) {
    var currentDate = _a2.currentDate, firstDayOfWeek = _a2.firstDayOfWeek, intervalCount = _a2.intervalCount;
    return monthCellsData(currentDate, firstDayOfWeek, intervalCount, Date.now());
  };
};
var calculateAppointmentsIntervalsBaseComputed$1 = function(cellDuration) {
  return function(_a2) {
    var appointments2 = _a2.appointments, startViewDate2 = _a2.startViewDate, endViewDate2 = _a2.endViewDate, excludedDays = _a2.excludedDays;
    return calculateMonthDateIntervals(appointments2, startViewDate2, endViewDate2);
  };
};
var MonthViewBase = function(_super) {
  __extends3(MonthViewBase2, _super);
  function MonthViewBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MonthViewBase2.prototype.render = function() {
    var _a2 = this.props, layoutComponent = _a2.layoutComponent, dayScaleEmptyCellComponent = _a2.dayScaleEmptyCellComponent, dayScaleLayoutComponent = _a2.dayScaleLayoutComponent, dayScaleCellComponent = _a2.dayScaleCellComponent, dayScaleRowComponent = _a2.dayScaleRowComponent, timeTableLayoutComponent = _a2.timeTableLayoutComponent, timeTableRowComponent = _a2.timeTableRowComponent, timeTableCellComponent = _a2.timeTableCellComponent, appointmentLayerComponent = _a2.appointmentLayerComponent, viewName = _a2.name, intervalCount = _a2.intervalCount, displayName = _a2.displayName;
    return (0, import_react2.createElement)(
      Plugin,
      { name: "MonthView" },
      (0, import_react2.createElement)(BasicView, { viewCellsDataComputed: viewCellsDataBaseComputed$2, type: VIEW_TYPES.MONTH, name: viewName, intervalCount, displayName, calculateAppointmentsIntervals: calculateAppointmentsIntervalsBaseComputed$1, dayScaleEmptyCellComponent, dayScaleLayoutComponent, dayScaleCellComponent, dayScaleRowComponent, timeTableCellComponent, timeTableLayoutComponent, timeTableRowComponent, appointmentLayerComponent, layoutComponent })
    );
  };
  MonthViewBase2.defaultProps = {
    intervalCount: 1,
    name: "Month"
  };
  MonthViewBase2.components = {
    layoutComponent: "Layout",
    appointmentLayerComponent: "AppointmentLayer",
    dayScaleEmptyCellComponent: "DayScaleEmptyCell",
    dayScaleLayoutComponent: "DayScaleLayout",
    dayScaleCellComponent: "DayScaleCell",
    dayScaleRowComponent: "DayScaleRow",
    timeTableContainerComponent: "TimeTableContainer",
    timeTableLayoutComponent: "TimeTableLayout",
    timeTableCellComponent: "TimeTableCell",
    timeTableRowComponent: "TimeTableRow"
  };
  return MonthViewBase2;
}(import_react2.PureComponent);
var MonthView = MonthViewBase;
var ToolbarBase = function(_super) {
  __extends3(ToolbarBase2, _super);
  function ToolbarBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ToolbarBase2.prototype.render = function() {
    var _a2 = this.props, Root = _a2.rootComponent, FlexibleSpaceComponent = _a2.flexibleSpaceComponent;
    return (0, import_react2.createElement)(
      Plugin,
      { name: "Toolbar" },
      (0, import_react2.createElement)(
        Template,
        { name: "header" },
        (0, import_react2.createElement)(
          Root,
          null,
          (0, import_react2.createElement)(TemplatePlaceholder, { name: "toolbarContent" })
        ),
        (0, import_react2.createElement)(TemplatePlaceholder, null)
      ),
      (0, import_react2.createElement)(
        Template,
        { name: "toolbarContent" },
        (0, import_react2.createElement)(FlexibleSpaceComponent, null)
      )
    );
  };
  ToolbarBase2.components = {
    rootComponent: "Root",
    flexibleSpaceComponent: "FlexibleSpace"
  };
  return ToolbarBase2;
}(import_react2.PureComponent);
var Toolbar = ToolbarBase;
var pluginDependencies = [
  { name: "Toolbar" },
  { name: "ViewState" }
];
var navigate = function(action, currentView, intervalCount) {
  return function(direction, nextDate) {
    return action({
      direction,
      nextDate,
      amount: intervalCount,
      step: currentView.type
    });
  };
};
var DateNavigatorBase = function(_super) {
  __extends3(DateNavigatorBase2, _super);
  function DateNavigatorBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.state = {
      visible: false
    };
    _this.setRootRef = function(target) {
      _this.target = target;
    };
    _this.handleVisibilityToggle = function() {
      _this.setState(function(prevState) {
        return { visible: !prevState.visible };
      });
    };
    _this.handleHide = function() {
      _this.setState({ visible: false });
    };
    _this.navigateAction = memoize(function(changeCurrentDate2, currentView, intervalCount, navigateAction) {
      return navigateAction(changeCurrentDate2, currentView, intervalCount);
    });
    return _this;
  }
  DateNavigatorBase2.prototype.render = function() {
    var _this = this;
    var _a2 = this.props, Root = _a2.rootComponent, Overlay = _a2.overlayComponent, OpenButton = _a2.openButtonComponent, NavigationButton = _a2.navigationButtonComponent, Calendar = _a2.calendarComponent, CalendarRow = _a2.calendarRowComponent, CalendarCell = _a2.calendarCellComponent, CalendarHeaderRow = _a2.calendarHeaderRowComponent, CalendarHeaderCell = _a2.calendarHeaderCellComponent, CalendarText = _a2.calendarTextComponent, CalendarNavigationButton = _a2.calendarNavigationButtonComponent, CalendarNavigator = _a2.calendarNavigatorComponent;
    var visible = this.state.visible;
    return (0, import_react2.createElement)(
      Plugin,
      { name: "DateNavigator", dependencies: pluginDependencies },
      (0, import_react2.createElement)(
        Template,
        { name: "toolbarContent" },
        (0, import_react2.createElement)(TemplateConnector, null, function(_a3, _b) {
          var currentDate = _a3.currentDate, startViewDate2 = _a3.startViewDate, endViewDate2 = _a3.endViewDate, firstDayOfWeek = _a3.firstDayOfWeek, currentView = _a3.currentView, intervalCount = _a3.intervalCount, formatDate = _a3.formatDate;
          var changeCurrentDate2 = _b.changeCurrentDate;
          var navigateAction = _this.navigateAction(changeCurrentDate2, currentView, intervalCount, navigate);
          var calendarDateChanged = function(nextDate) {
            navigateAction(void 0, nextDate);
            _this.handleHide();
          };
          var navigatorText = viewBoundText(startViewDate2, endViewDate2, currentView.type, currentDate, intervalCount, formatDate);
          return (0, import_react2.createElement)(
            import_react2.Fragment,
            null,
            (0, import_react2.createElement)(Root, { navigationButtonComponent: NavigationButton, openButtonComponent: OpenButton, navigatorText, rootRef: _this.setRootRef, onVisibilityToggle: _this.handleVisibilityToggle, onNavigate: navigateAction }),
            (0, import_react2.createElement)(
              Overlay,
              { visible, target: _this.target, onHide: _this.handleHide },
              (0, import_react2.createElement)(Calendar, { selectedDate: currentDate, firstDayOfWeek, getCells: monthCellsData, textComponent: CalendarText, navigationButtonComponent: CalendarNavigationButton, rowComponent: CalendarRow, cellComponent: CalendarCell, headerRowComponent: CalendarHeaderRow, headerCellComponent: CalendarHeaderCell, navigatorComponent: CalendarNavigator, onSelectedDateChange: calendarDateChanged, formatDate })
            )
          );
        }),
        (0, import_react2.createElement)(TemplatePlaceholder, null)
      )
    );
  };
  DateNavigatorBase2.components = {
    rootComponent: "Root",
    overlayComponent: "Overlay",
    openButtonComponent: "OpenButton",
    navigationButtonComponent: "NavigationButton",
    calendarComponent: "Calendar",
    calendarRowComponent: "CalendarRow",
    calendarCellComponent: "CalendarCell",
    calendarHeaderRowComponent: "CalendarHeaderRow",
    calendarHeaderCellComponent: "CalendarHeaderCell",
    calendarTextComponent: "CalendarText",
    calendarNavigatorComponent: "CalendarNavigator",
    calendarNavigationButtonComponent: "CalendarNavigationButton"
  };
  return DateNavigatorBase2;
}(import_react2.PureComponent);
var DateNavigator = DateNavigatorBase;
var pluginDependencies$1 = [
  { name: "Toolbar" },
  { name: "ViewState" }
];
var ViewSwitcherBase = function(_super) {
  __extends3(ViewSwitcherBase2, _super);
  function ViewSwitcherBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ViewSwitcherBase2.prototype.render = function() {
    var Switcher = this.props.switcherComponent;
    return (0, import_react2.createElement)(
      Plugin,
      { name: "ViewSwitcher", dependencies: pluginDependencies$1 },
      (0, import_react2.createElement)(
        Template,
        { name: "toolbarContent" },
        (0, import_react2.createElement)(TemplatePlaceholder, null),
        (0, import_react2.createElement)(TemplateConnector, null, function(_a2, _b) {
          var currentView = _a2.currentView, availableViews2 = _a2.availableViews;
          var setCurrentViewName2 = _b.setCurrentViewName;
          return (0, import_react2.createElement)(Switcher, { currentView, availableViews: availableViews2, onChange: setCurrentViewName2 });
        })
      )
    );
  };
  ViewSwitcherBase2.components = {
    switcherComponent: "Switcher"
  };
  return ViewSwitcherBase2;
}(import_react2.PureComponent);
var ViewSwitcher = ViewSwitcherBase;
var AppointmentPlaceholder = function(params) {
  return (0, import_react2.createElement)(TemplatePlaceholder, { name: "appointment", params });
};
var renderAppointments = function(rects) {
  return rects.map(function(_a2) {
    var dataItem = _a2.dataItem, rectType = _a2.type, fromPrev = _a2.fromPrev, toNext = _a2.toNext, durationType = _a2.durationType, resources = _a2.resources, key = _a2.key, geometry = __rest3(_a2, ["dataItem", "type", "fromPrev", "toNext", "durationType", "resources", "key"]);
    return (0, import_react2.createElement)(AppointmentPlaceholder, { key, type: rectType, data: dataItem, fromPrev, toNext, durationType, resources, style: getAppointmentStyle(geometry) });
  });
};
var pluginDependencies$2 = [
  { name: "DayView", optional: true },
  { name: "WeekView", optional: true },
  { name: "MonthView", optional: true }
];
var AppointmentsBase = function(_super) {
  __extends3(AppointmentsBase2, _super);
  function AppointmentsBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.updateTimeTableAppointments = memoize(function(timeTableAppointments, viewCellsData2, timeTableElementsMeta, currentView, startViewDate2, endViewDate2, cellDuration, groups, getGroupOrientation, groupByDate, placeAppointmentsNextToEachOther) {
      if (!isTimeTableElementsMetaActual(viewCellsData2, timeTableElementsMeta))
        return null;
      var groupOrientation = getGroupOrientation ? getGroupOrientation(currentView === null || currentView === void 0 ? void 0 : currentView.name) : HORIZONTAL_GROUP_ORIENTATION;
      var groupCount = groups ? getGroupsLastRow(groups).length : 1;
      var appointmentType = { growDirection: VERTICAL_TYPE, multiline: false };
      var getRects = getVerticalRectByAppointmentData;
      if (currentView.type === VIEW_TYPES.MONTH) {
        appointmentType = { growDirection: HORIZONTAL_TYPE, multiline: true };
        getRects = getHorizontalRectByAppointmentData;
      }
      return renderAppointments(calculateRectByDateAndGroupIntervals(appointmentType, timeTableAppointments, getRects, {
        startViewDate: startViewDate2,
        endViewDate: endViewDate2,
        cellDuration,
        viewCellsData: viewCellsData2,
        cellElementsMeta: timeTableElementsMeta,
        placeAppointmentsNextToEachOther
      }, {
        groupOrientation,
        groupedByDate: groupByDate === null || groupByDate === void 0 ? void 0 : groupByDate(currentView === null || currentView === void 0 ? void 0 : currentView.name),
        groupCount
      }));
    });
    _this.updateAllDayAppointments = memoize(function(allDayAppointments, viewCellsData2, allDayElementsMeta, currentView, startViewDate2, endViewDate2, groups, getGroupOrientation, groupByDate) {
      var groupOrientation = getGroupOrientation ? getGroupOrientation(currentView === null || currentView === void 0 ? void 0 : currentView.name) : HORIZONTAL_GROUP_ORIENTATION;
      var groupCount = groups ? getGroupsLastRow(groups).length : 1;
      if (!isAllDayElementsMetaActual(viewCellsData2, allDayElementsMeta, groupOrientation, groupCount)) {
        return null;
      }
      return renderAppointments(calculateRectByDateAndGroupIntervals({ growDirection: HORIZONTAL_TYPE, multiline: false }, allDayAppointments, getHorizontalRectByAppointmentData, {
        startViewDate: startViewDate2,
        endViewDate: endViewDate2,
        viewCellsData: viewCellsData2,
        cellElementsMeta: allDayElementsMeta
      }, {
        groupOrientation,
        groupedByDate: groupByDate === null || groupByDate === void 0 ? void 0 : groupByDate(currentView === null || currentView === void 0 ? void 0 : currentView.name),
        groupCount
      }));
    });
    return _this;
  }
  AppointmentsBase2.prototype.render = function() {
    var _this = this;
    var _a2 = this.props, SplitIndicator = _a2.splitIndicatorComponent, Appointment = _a2.appointmentComponent, AppointmentContent = _a2.appointmentContentComponent, Container = _a2.containerComponent, recurringIconComponent = _a2.recurringIconComponent, placeAppointmentsNextToEachOther = _a2.placeAppointmentsNextToEachOther;
    return (0, import_react2.createElement)(
      Plugin,
      { name: "Appointments", dependencies: pluginDependencies$2 },
      (0, import_react2.createElement)(
        Template,
        { name: "timeTableAppointmentLayer" },
        (0, import_react2.createElement)(TemplateConnector, null, function(_a3) {
          var timeTableAppointments = _a3.timeTableAppointments, viewCellsData2 = _a3.viewCellsData, timeTableElementsMeta = _a3.timeTableElementsMeta, currentView = _a3.currentView, startViewDate2 = _a3.startViewDate, endViewDate2 = _a3.endViewDate, cellDuration = _a3.cellDuration, groupOrientation = _a3.groupOrientation, groups = _a3.groups, groupByDate = _a3.groupByDate;
          return _this.updateTimeTableAppointments(timeTableAppointments, viewCellsData2, timeTableElementsMeta, currentView, startViewDate2, endViewDate2, cellDuration, groups, groupOrientation, groupByDate, placeAppointmentsNextToEachOther);
        })
      ),
      (0, import_react2.createElement)(
        Template,
        { name: "allDayAppointmentLayer" },
        (0, import_react2.createElement)(TemplateConnector, null, function(_a3) {
          var allDayAppointments = _a3.allDayAppointments, viewCellsData2 = _a3.viewCellsData, allDayElementsMeta = _a3.allDayElementsMeta, startViewDate2 = _a3.startViewDate, endViewDate2 = _a3.endViewDate, groupOrientation = _a3.groupOrientation, currentView = _a3.currentView, groups = _a3.groups, groupByDate = _a3.groupByDate;
          return _this.updateAllDayAppointments(allDayAppointments, viewCellsData2, allDayElementsMeta, currentView, startViewDate2, endViewDate2, groups, groupOrientation, groupByDate);
        })
      ),
      (0, import_react2.createElement)(Template, { name: "appointment" }, function(_a3) {
        var style = _a3.style, params = __rest3(_a3, ["style"]);
        return (0, import_react2.createElement)(TemplateConnector, null, function(_a4) {
          var formatDate = _a4.formatDate;
          return (0, import_react2.createElement)(
            Container,
            { style },
            (0, import_react2.createElement)(TemplatePlaceholder, { name: "appointmentTop", params: { data: params.data, type: params.type, slice: params.fromPrev } }),
            (0, import_react2.createElement)(TemplatePlaceholder, { name: "appointmentContent", params: __assign4(__assign4({}, params), { formatDate }) }),
            (0, import_react2.createElement)(TemplatePlaceholder, { name: "appointmentBottom", params: { data: params.data, type: params.type, slice: params.toNext } })
          );
        });
      }),
      (0, import_react2.createElement)(Template, { name: "appointmentContent" }, function(_a3) {
        var onClick = _a3.onClick, onDoubleClick = _a3.onDoubleClick, formatDate = _a3.formatDate, data = _a3.data, type = _a3.type, fromPrev = _a3.fromPrev, toNext = _a3.toNext, durationType = _a3.durationType, resources = _a3.resources, forwardedRef = _a3.forwardedRef, restParams = __rest3(_a3, ["onClick", "onDoubleClick", "formatDate", "data", "type", "fromPrev", "toNext", "durationType", "resources", "forwardedRef"]);
        return (0, import_react2.createElement)(
          Appointment,
          __assign4({ forwardedRef, data, resources }, createClickHandlers(onClick, onDoubleClick), restParams),
          fromPrev && (0, import_react2.createElement)(SplitIndicator, { position: POSITION_START, appointmentType: type }),
          (0, import_react2.createElement)(AppointmentContent, { data, type, durationType, recurringIconComponent, formatDate, resources }),
          toNext && (0, import_react2.createElement)(SplitIndicator, { position: POSITION_END, appointmentType: type })
        );
      })
    );
  };
  AppointmentsBase2.components = {
    splitIndicatorComponent: "SplitIndicator",
    containerComponent: "Container",
    appointmentComponent: "Appointment",
    appointmentContentComponent: "AppointmentContent",
    recurringIconComponent: "RecurringIcon"
  };
  AppointmentsBase2.defaultProps = {
    placeAppointmentsNextToEachOther: false
  };
  return AppointmentsBase2;
}(import_react2.PureComponent);
var Appointments = AppointmentsBase;
var isMonthView = function(currentView) {
  return currentView.type === VIEW_TYPES.MONTH;
};
var isVerticalGrouping = function(currentView, groupOrientation) {
  return (groupOrientation === null || groupOrientation === void 0 ? void 0 : groupOrientation(currentView.name)) === VERTICAL_GROUP_ORIENTATION;
};
var pluginDependencies$3 = [
  { name: "DayView", optional: true },
  { name: "WeekView", optional: true }
];
var defaultMessages = {
  allDay: "All Day"
};
var AllDayAppointmentLayerPlaceholder = function() {
  return (0, import_react2.createElement)(TemplatePlaceholder, { name: "allDayAppointmentLayer" });
};
var AllDayPanelPlaceholder = function(params) {
  return (0, import_react2.createElement)(TemplatePlaceholder, { name: "allDayPanel", params });
};
var CellPlaceholder$1 = function(params) {
  return (0, import_react2.createElement)(TemplatePlaceholder, { name: "allDayPanelCell", params });
};
var AllDayTitlePlaceholder = function(params) {
  return (0, import_react2.createElement)(TemplatePlaceholder, { name: "allDayTitle", params });
};
var AllDayPanelBase = function(_super) {
  __extends3(AllDayPanelBase2, _super);
  function AllDayPanelBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.state = {
      elementsMeta: {},
      previousCell: null,
      // The key has to be generated every time the Cell component is updated to rerender the Layout
      // and, consequently, update allDayElementsMeta
      layoutKey: 0
    };
    _this.allDayCellsDataComputed = memoize(function(_a2) {
      var viewCellsData2 = _a2.viewCellsData;
      return allDayCells(viewCellsData2);
    });
    _this.updateCellElementsMeta = memoize(function(cellElementsMeta) {
      _this.setState({ elementsMeta: cellElementsMeta });
    });
    _this.allDayAppointmentsComputed = memoize(function(_a2) {
      var appointments2 = _a2.appointments, startViewDate2 = _a2.startViewDate, endViewDate2 = _a2.endViewDate, excludedDays = _a2.excludedDays;
      var allDayLeftBound = moment_default(startViewDate2).hours(0).minutes(0).toDate();
      var allDayRightBound = moment_default(endViewDate2).hours(23).minutes(59).toDate();
      return calculateAllDayDateIntervals(appointments2, allDayLeftBound, allDayRightBound, excludedDays);
    });
    _this.allDayPanelExistsComputed = memoize(function(_a2) {
      var currentView = _a2.currentView;
      return !isMonthView(currentView);
    });
    _this.getMessageFormatter = memoize(function(messages, allDayPanelDefaultMessages) {
      return getMessagesFormatter(__assign4(__assign4({}, allDayPanelDefaultMessages), messages));
    });
    return _this;
  }
  AllDayPanelBase2.getDerivedStateFromProps = function(props, state) {
    if (props.cellComponent !== state.previousCell) {
      return __assign4(__assign4({}, state), { previousCell: props.cellComponent, layoutKey: Math.random() });
    }
    return null;
  };
  AllDayPanelBase2.prototype.render = function() {
    var _this = this;
    var _a2 = this.props, AppointmentLayer = _a2.appointmentLayerComponent, Layout = _a2.layoutComponent, Cell = _a2.cellComponent, rowComponent = _a2.rowComponent, TitleCell = _a2.titleCellComponent, Container = _a2.containerComponent, messages = _a2.messages;
    var _b = this.state, elementsMeta = _b.elementsMeta, layoutKey = _b.layoutKey;
    var getMessage = this.getMessageFormatter(messages, defaultMessages);
    return (0, import_react2.createElement)(
      Plugin,
      { name: "AllDayPanel", dependencies: pluginDependencies$3 },
      (0, import_react2.createElement)(Getter, { name: "allDayElementsMeta", value: elementsMeta }),
      (0, import_react2.createElement)(Getter, { name: "allDayCellsData", computed: this.allDayCellsDataComputed }),
      (0, import_react2.createElement)(Getter, { name: "allDayPanelExists", computed: this.allDayPanelExistsComputed }),
      (0, import_react2.createElement)(Getter, { name: "allDayAppointments", computed: this.allDayAppointmentsComputed }),
      (0, import_react2.createElement)(Template, { name: "timeTable" }, function(params) {
        return (0, import_react2.createElement)(TemplateConnector, null, function(_a3) {
          var currentView = _a3.currentView, groupOrientation = _a3.groupOrientation, allDayCellsData = _a3.allDayCellsData;
          if (isMonthView(currentView) || !isVerticalGrouping(currentView, groupOrientation)) {
            return (0, import_react2.createElement)(TemplatePlaceholder, { params });
          }
          return (0, import_react2.createElement)(
            import_react2.Fragment,
            null,
            (0, import_react2.createElement)(TemplatePlaceholder, { params: __assign4(__assign4({}, params), { allDayCellComponent: CellPlaceholder$1, allDayRowComponent: rowComponent, allDayCellsData }) }),
            (0, import_react2.createElement)(
              AppointmentLayer,
              null,
              (0, import_react2.createElement)(AllDayAppointmentLayerPlaceholder, null)
            )
          );
        });
      }),
      (0, import_react2.createElement)(
        Template,
        { name: "dayScaleEmptyCell" },
        (0, import_react2.createElement)(TemplateConnector, null, function(_a3) {
          var currentView = _a3.currentView, groupOrientation = _a3.groupOrientation;
          if (isMonthView(currentView) || isVerticalGrouping(currentView, groupOrientation)) {
            return (0, import_react2.createElement)(TemplatePlaceholder, null);
          }
          return (0, import_react2.createElement)(AllDayTitlePlaceholder, null);
        })
      ),
      (0, import_react2.createElement)(Template, { name: "timeScale" }, function(params) {
        return (0, import_react2.createElement)(TemplateConnector, null, function(_a3) {
          var currentView = _a3.currentView, groupOrientation = _a3.groupOrientation;
          if (isMonthView(currentView) || !isVerticalGrouping(currentView, groupOrientation)) {
            return (0, import_react2.createElement)(TemplatePlaceholder, { params });
          }
          return (0, import_react2.createElement)(TemplatePlaceholder, { params: __assign4(__assign4({}, params), { allDayTitleComponent: AllDayTitlePlaceholder, showAllDayTitle: true }) });
        });
      }),
      (0, import_react2.createElement)(
        Template,
        { name: "dayScale" },
        (0, import_react2.createElement)(TemplatePlaceholder, null),
        (0, import_react2.createElement)(TemplateConnector, null, function(_a3) {
          var currentView = _a3.currentView, groupOrientation = _a3.groupOrientation;
          if (isMonthView(currentView) || isVerticalGrouping(currentView, groupOrientation)) {
            return null;
          }
          return (0, import_react2.createElement)(
            Container,
            null,
            (0, import_react2.createElement)(AllDayPanelPlaceholder, null)
          );
        })
      ),
      (0, import_react2.createElement)(
        Template,
        { name: "allDayPanel" },
        (0, import_react2.createElement)(TemplatePlaceholder, null),
        (0, import_react2.createElement)(TemplateConnector, null, function(_a3) {
          var currentView = _a3.currentView, formatDate = _a3.formatDate, allDayCellsData = _a3.allDayCellsData;
          if (currentView.type === VIEW_TYPES.MONTH)
            return null;
          return (0, import_react2.createElement)(
            import_react2.Fragment,
            null,
            (0, import_react2.createElement)(Layout, { cellComponent: CellPlaceholder$1, rowComponent, cellsData: allDayCellsData[0], setCellElementsMeta: _this.updateCellElementsMeta, formatDate, key: layoutKey }),
            (0, import_react2.createElement)(
              AppointmentLayer,
              null,
              (0, import_react2.createElement)(AllDayAppointmentLayerPlaceholder, null)
            )
          );
        })
      ),
      (0, import_react2.createElement)(Template, { name: "allDayTitle" }, function(params) {
        return (0, import_react2.createElement)(TitleCell, __assign4({ getMessage }, params));
      }),
      (0, import_react2.createElement)(Template, { name: "allDayPanelCell" }, function(params) {
        return (0, import_react2.createElement)(Cell, __assign4({}, params));
      })
    );
  };
  AllDayPanelBase2.defaultProps = {
    messages: {}
  };
  AllDayPanelBase2.components = {
    appointmentLayerComponent: "AppointmentLayer",
    layoutComponent: "Layout",
    layoutContainerComponent: "LayoutContainer",
    cellComponent: "Cell",
    rowComponent: "Row",
    titleCellComponent: "TitleCell",
    containerComponent: "Container"
  };
  return AllDayPanelBase2;
}(import_react2.PureComponent);
var AllDayPanel = AllDayPanelBase;
var ViewStateBase = function(_super) {
  __extends3(ViewStateBase2, _super);
  function ViewStateBase2(props) {
    var _this = _super.call(this, props) || this;
    _this.getCurrentViewComputed = memoize(function(currentViewName) {
      return function() {
        return currentViewName ? { name: currentViewName } : void 0;
      };
    });
    _this.state = {
      currentDate: props.currentDate || props.defaultCurrentDate,
      currentViewName: props.currentViewName || props.defaultCurrentViewName
    };
    var stateHelper = createStateHelper(_this, {
      currentDate: function() {
        var onCurrentDateChange = _this.props.onCurrentDateChange;
        return onCurrentDateChange;
      },
      currentViewName: function() {
        var onCurrentViewNameChange = _this.props.onCurrentViewNameChange;
        return onCurrentViewNameChange;
      }
    });
    _this.changeCurrentDate = stateHelper.applyFieldReducer.bind(stateHelper, "currentDate", changeCurrentDate);
    _this.setCurrentViewName = stateHelper.applyFieldReducer.bind(stateHelper, "currentViewName", setCurrentViewName);
    return _this;
  }
  ViewStateBase2.getDerivedStateFromProps = function(nextProps, prevState) {
    var _a2 = nextProps.currentDate, currentDate = _a2 === void 0 ? prevState.currentDate : _a2, _b = nextProps.currentViewName, currentViewName = _b === void 0 ? prevState.currentViewName : _b;
    return {
      currentDate,
      currentViewName
    };
  };
  ViewStateBase2.prototype.render = function() {
    var _a2 = this.state, currentDate = _a2.currentDate, stateCurrentViewName = _a2.currentViewName;
    return (0, import_react2.createElement)(
      Plugin,
      { name: "ViewState" },
      (0, import_react2.createElement)(Getter, { name: "currentDate", value: currentDate }),
      (0, import_react2.createElement)(Getter, { name: "currentView", computed: this.getCurrentViewComputed(stateCurrentViewName) }),
      (0, import_react2.createElement)(Action, { name: "changeCurrentDate", action: this.changeCurrentDate }),
      (0, import_react2.createElement)(Action, { name: "setCurrentViewName", action: this.setCurrentViewName })
    );
  };
  ViewStateBase2.defaultProps = {
    defaultCurrentDate: /* @__PURE__ */ new Date()
  };
  return ViewStateBase2;
}(import_react2.PureComponent);
var ViewState = ViewStateBase;
var EditingStateBase = function(_super) {
  __extends3(EditingStateBase2, _super);
  function EditingStateBase2(props) {
    var _this = _super.call(this, props) || this;
    _this.state = {
      editingAppointment: props.editingAppointment || props.defaultEditingAppointment,
      addedAppointment: props.addedAppointment || props.defaultAddedAppointment,
      appointmentChanges: props.appointmentChanges || props.defaultAppointmentChanges
    };
    var stateHelper = createStateHelper(_this, {
      editingAppointment: function() {
        var onEditingAppointmentChange = _this.props.onEditingAppointmentChange;
        return onEditingAppointmentChange;
      },
      addedAppointment: function() {
        var onAddedAppointmentChange = _this.props.onAddedAppointmentChange;
        return onAddedAppointmentChange;
      },
      appointmentChanges: function() {
        var onAppointmentChangesChange = _this.props.onAppointmentChangesChange;
        return onAppointmentChangesChange;
      }
    });
    _this.addAppointment = stateHelper.applyFieldReducer.bind(stateHelper, "addedAppointment", addAppointment);
    _this.changeAddedAppointment = stateHelper.applyFieldReducer.bind(stateHelper, "addedAppointment", changeAppointment);
    _this.cancelAddedAppointment = stateHelper.applyFieldReducer.bind(stateHelper, "addedAppointment", cancelAddedAppointment);
    _this.startEditAppointment = stateHelper.applyFieldReducer.bind(stateHelper, "editingAppointment", startEditAppointment);
    _this.stopEditAppointment = stateHelper.applyFieldReducer.bind(stateHelper, "editingAppointment", stopEditAppointment);
    _this.changeAppointment = stateHelper.applyFieldReducer.bind(stateHelper, "appointmentChanges", changeAppointment);
    _this.cancelChangedAppointment = stateHelper.applyFieldReducer.bind(stateHelper, "appointmentChanges", cancelChanges);
    _this.commitChangedAppointment = function(type) {
      if (type === void 0) {
        type = RECURRENCE_EDIT_SCOPE.CURRENT;
      }
      var _a2 = _this.state, appointmentChanges = _a2.appointmentChanges, editingAppointment = _a2.editingAppointment;
      var _b = _this.props, onCommitChanges = _b.onCommitChanges, preCommitChanges2 = _b.preCommitChanges;
      if (!editingAppointment) {
        return;
      }
      var changes = !editingAppointment.rRule ? { changed: changedAppointmentById(appointmentChanges, editingAppointment.id) } : preCommitChanges2(appointmentChanges, editingAppointment, type);
      onCommitChanges(changes);
      _this.cancelChangedAppointment();
      _this.stopEditAppointment();
    };
    _this.commitAddedAppointment = function() {
      var onCommitChanges = _this.props.onCommitChanges;
      var stateAddedAppointment = _this.state.addedAppointment;
      onCommitChanges({
        added: stateAddedAppointment
      });
    };
    _this.commitDeletedAppointment = function(_a2) {
      var deletedAppointmentData = _a2.deletedAppointmentData, _b = _a2.type, type = _b === void 0 ? "current" : _b;
      var _c = _this.props, onCommitChanges = _c.onCommitChanges, preCommitChanges2 = _c.preCommitChanges;
      var changes = deletedAppointmentData.rRule ? preCommitChanges2(null, deletedAppointmentData, type) : { deleted: deletedAppointmentData.id };
      onCommitChanges(changes);
    };
    return _this;
  }
  EditingStateBase2.getDerivedStateFromProps = function(nextProps, prevState) {
    var _a2 = nextProps.editingAppointment, editingAppointment = _a2 === void 0 ? prevState.editingAppointment : _a2, _b = nextProps.appointmentChanges, appointmentChanges = _b === void 0 ? prevState.appointmentChanges : _b, _c = nextProps.addedAppointment, addedAppointment = _c === void 0 ? prevState.addedAppointment : _c;
    return {
      editingAppointment,
      appointmentChanges,
      addedAppointment
    };
  };
  EditingStateBase2.prototype.render = function() {
    var _a2 = this.state, addedAppointment = _a2.addedAppointment, editingAppointment = _a2.editingAppointment, appointmentChanges = _a2.appointmentChanges;
    return (0, import_react2.createElement)(
      Plugin,
      { name: "EditingState" },
      (0, import_react2.createElement)(Getter, { name: "editingAppointment", value: editingAppointment }),
      (0, import_react2.createElement)(Action, { name: "startEditAppointment", action: this.startEditAppointment }),
      (0, import_react2.createElement)(Action, { name: "stopEditAppointment", action: this.stopEditAppointment }),
      (0, import_react2.createElement)(Getter, { name: "appointmentChanges", value: appointmentChanges }),
      (0, import_react2.createElement)(Action, { name: "changeAppointment", action: this.changeAppointment }),
      (0, import_react2.createElement)(Action, { name: "cancelChangedAppointment", action: this.cancelChangedAppointment }),
      (0, import_react2.createElement)(Action, { name: "commitChangedAppointment", action: this.commitChangedAppointment }),
      (0, import_react2.createElement)(Getter, { name: "addedAppointment", value: addedAppointment }),
      (0, import_react2.createElement)(Action, { name: "addAppointment", action: this.addAppointment }),
      (0, import_react2.createElement)(Action, { name: "changeAddedAppointment", action: this.changeAddedAppointment }),
      (0, import_react2.createElement)(Action, { name: "cancelAddedAppointment", action: this.cancelAddedAppointment }),
      (0, import_react2.createElement)(Action, { name: "commitAddedAppointment", action: this.commitAddedAppointment }),
      (0, import_react2.createElement)(Action, { name: "commitDeletedAppointment", action: this.commitDeletedAppointment })
    );
  };
  EditingStateBase2.defaultProps = {
    defaultEditingAppointment: void 0,
    defaultAppointmentChanges: {},
    defaultAddedAppointment: {},
    preCommitChanges
  };
  return EditingStateBase2;
}(import_react2.PureComponent);
var EditingState = EditingStateBase;
var pluginDependencies$4 = [
  { name: "Appointments" },
  { name: "EditingState", optional: true },
  { name: "EditRecurrenceMenu", optional: true },
  { name: "IntegratedEditing", optional: true }
];
var commandButtonIds = {
  open: OPEN_COMMAND_BUTTON,
  close: CLOSE_COMMAND_BUTTON,
  delete: DELETE_COMMAND_BUTTON
};
var AppointmentTooltipBase = function(_super) {
  __extends3(AppointmentTooltipBase2, _super);
  function AppointmentTooltipBase2(props) {
    var _this = _super.call(this, props) || this;
    _this.state = {
      visible: props.visible,
      appointmentMeta: props.appointmentMeta
    };
    var stateHelper = createStateHelper(_this, {
      visible: function() {
        var onVisibilityChange = _this.props.onVisibilityChange;
        return onVisibilityChange;
      },
      appointmentMeta: function() {
        var onAppointmentMetaChange = _this.props.onAppointmentMetaChange;
        return onAppointmentMetaChange;
      }
    });
    var toggleVisibility = function() {
      var isOpen = _this.state.visible;
      return !isOpen;
    };
    _this.toggleVisibility = stateHelper.applyFieldReducer.bind(stateHelper, "visible", toggleVisibility);
    _this.setAppointmentMeta = stateHelper.applyFieldReducer.bind(stateHelper, "appointmentMeta", setAppointmentMeta);
    _this.onAppointmentClick = function(_a2) {
      var target = _a2.target, data = _a2.data;
      _this.setAppointmentMeta({ target, data });
      _this.toggleVisibility();
    };
    return _this;
  }
  AppointmentTooltipBase2.getDerivedStateFromProps = function(nextProps, prevState) {
    var _a2 = nextProps.visible, visible = _a2 === void 0 ? prevState.visible : _a2, _b = nextProps.appointmentMeta, appointmentMeta = _b === void 0 ? prevState.appointmentMeta : _b;
    return {
      appointmentMeta,
      visible
    };
  };
  AppointmentTooltipBase2.prototype.render = function() {
    var _this = this;
    var _a2 = this.props, showOpenButton = _a2.showOpenButton, showDeleteButton = _a2.showDeleteButton, showCloseButton = _a2.showCloseButton, Layout = _a2.layoutComponent, headerComponent = _a2.headerComponent, contentComponent = _a2.contentComponent, commandButtonComponent = _a2.commandButtonComponent, recurringIconComponent = _a2.recurringIconComponent;
    var _b = this.state, visible = _b.visible, appointmentMeta = _b.appointmentMeta;
    return (0, import_react2.createElement)(
      Plugin,
      { name: "AppointmentTooltip", dependencies: pluginDependencies$4 },
      (0, import_react2.createElement)(Action, { name: TOGGLE_APPOINTMENT_TOOLTIP_VISIBILITY, action: this.toggleVisibility }),
      (0, import_react2.createElement)(
        Template,
        { name: "timeTable" },
        (0, import_react2.createElement)(TemplatePlaceholder, null),
        (0, import_react2.createElement)(TemplateConnector, null, function(_a3, _b2) {
          var formatDate = _a3.formatDate, resources = _a3.resources, plainResources = _a3.plainResources;
          var finishDeleteAppointment = _b2.finishDeleteAppointment, openDeleteConfirmationDialog = _b2.openDeleteConfirmationDialog;
          var onDeleteButtonClick = function() {
            if (!finishDeleteAppointment) {
              return;
            }
            if (openDeleteConfirmationDialog) {
              openDeleteConfirmationDialog({
                hideActionName: TOGGLE_APPOINTMENT_TOOLTIP_VISIBILITY,
                appointmentData: appointmentMeta.data
              });
            } else {
              _this.toggleVisibility();
              finishDeleteAppointment(appointmentMeta.data);
            }
          };
          return (0, import_react2.createElement)(TemplatePlaceholder, { name: "tooltip", params: {
            commandButtonComponent,
            recurringIconComponent,
            showOpenButton,
            showDeleteButton,
            showCloseButton,
            headerComponent,
            contentComponent,
            appointmentMeta,
            appointmentResources: appointmentMeta ? getAppointmentResources(appointmentMeta.data, resources, plainResources) : [],
            visible,
            onHide: _this.toggleVisibility,
            commandButtonIds,
            onDeleteButtonClick,
            formatDate
          } });
        })
      ),
      (0, import_react2.createElement)(Template, { name: "tooltip" }, function(params) {
        return (0, import_react2.createElement)(Layout, __assign4({}, params));
      }),
      (0, import_react2.createElement)(Template, { name: "appointment" }, function(params) {
        return (0, import_react2.createElement)(TemplatePlaceholder, { params: __assign4(__assign4({}, params), { onClick: function(_a3) {
          var target = _a3.target, data = _a3.data;
          return _this.onAppointmentClick({ target, data });
        } }) });
      })
    );
  };
  AppointmentTooltipBase2.defaultProps = {
    showOpenButton: false,
    showDeleteButton: false,
    showCloseButton: false
  };
  AppointmentTooltipBase2.components = {
    layoutComponent: "Layout",
    headerComponent: "Header",
    contentComponent: "Content",
    commandButtonComponent: "CommandButton",
    recurringIconComponent: "RecurringIcon"
  };
  return AppointmentTooltipBase2;
}(import_react2.PureComponent);
var AppointmentTooltip = AppointmentTooltipBase;
var addDoubleClickToCell = function(title, startDate, endDate, groupingInfo, resources, allDay, openFormHandler, addAppointment2, params) {
  var resourceFields = !!groupingInfo ? groupingInfo.reduce(function(acc, currentGroup) {
    var _a2;
    return __assign4(__assign4({}, acc), (_a2 = {}, _a2[currentGroup.fieldName] = currentGroup.id, _a2));
  }, {}) : {};
  var validResourceFields = resources ? checkMultipleResourceFields(resourceFields, resources) : resourceFields;
  var newAppointmentData = __assign4({ title, startDate, endDate, allDay }, validResourceFields);
  return (0, import_react2.createElement)(TemplatePlaceholder, { params: __assign4(__assign4({}, params), { onDoubleClick: function() {
    openFormHandler(newAppointmentData);
    callActionIfExists(addAppointment2, { appointmentData: newAppointmentData });
  } }) });
};
var defaultMessages$1 = {
  allDayLabel: "All Day",
  titleLabel: "Title",
  commitCommand: "Save",
  detailsLabel: "Details",
  moreInformationLabel: "More Information",
  repeatLabel: "Repeat",
  notesLabel: "Notes",
  never: "Never",
  daily: "Daily",
  weekly: "Weekly",
  monthly: "Monthly",
  yearly: "Yearly",
  repeatEveryLabel: "Repeat every",
  daysLabel: "day(s)",
  endRepeatLabel: "End repeat",
  onLabel: "On",
  afterLabel: "After",
  occurrencesLabel: "occurrence(s)",
  weeksOnLabel: "week(s) on:",
  monthsLabel: "month(s)",
  ofEveryMonthLabel: "of every month",
  theLabel: "The",
  firstLabel: "First",
  secondLabel: "Second",
  thirdLabel: "Third",
  fourthLabel: "Fourth",
  lastLabel: "Last",
  yearsLabel: "year(s)",
  ofLabel: "of ",
  everyLabel: "Every"
};
var CommandLayoutPlaceholder = function() {
  return (0, import_react2.createElement)(TemplatePlaceholder, { name: "commandLayout" });
};
var BasicLayoutPlaceholder = function() {
  return (0, import_react2.createElement)(TemplatePlaceholder, { name: "basicLayout" });
};
var RecurrenceLayoutPlaceholder = function() {
  return (0, import_react2.createElement)(TemplatePlaceholder, { name: "recurrenceLayout" });
};
var pluginDependencies$5 = [
  { name: "EditingState", optional: true },
  { name: "Appointments", optional: true },
  { name: "AppointmentTooltip", optional: true },
  { name: "EditRecurrenceMenu", optional: true },
  { name: "IntegratedEditing", optional: true }
];
var prepareChanges = function(appointmentData, editingAppointment, addedAppointment, appointmentChanges, resources, plainResources) {
  var isNew = !editingAppointment;
  var changedAppointment = __assign4(__assign4(__assign4({}, appointmentData), appointmentChanges), isNew && addedAppointment);
  var appointmentResources = getAppointmentResources(changedAppointment, resources, plainResources);
  var isFormEdited = isNew || Object.getOwnPropertyNames(appointmentChanges).length !== 0;
  return { changedAppointment, appointmentResources, isNew, isFormEdited };
};
var isFormFullSize = function(isFormVisible, changedAppointmentRRule, previousAppointmentRRule) {
  return !!changedAppointmentRRule || !isFormVisible && !!previousAppointmentRRule;
};
var AppointmentFormBase = function(_super) {
  __extends3(AppointmentFormBase2, _super);
  function AppointmentFormBase2(props) {
    var _this = _super.call(this, props) || this;
    _this.container = (0, import_react2.createRef)();
    _this.commitChanges = memoize(function(finishCommitAppointment, commitAddedAppointment, isNew, changedAppointment) {
      return function() {
        _this.toggleVisibility();
        if (isNew) {
          callActionIfExists(commitAddedAppointment, changedAppointment);
        } else if (finishCommitAppointment) {
          finishCommitAppointment();
        }
        _this.setState({ previousAppointment: changedAppointment });
      };
    });
    _this.cancelChanges = memoize(function(openCancelConfirmationDialog, isNew, stopEditAppointment2, appointmentChanges, changedAppointment, cancelAddedAppointment2, cancelChangedAppointment) {
      return function() {
        if (openCancelConfirmationDialog && Object.keys(appointmentChanges).length !== 0) {
          openCancelConfirmationDialog(TOGGLE_APPOINTMENT_FORM_VISIBILITY);
        } else {
          if (isNew) {
            callActionIfExists(cancelAddedAppointment2, appointmentChanges);
          } else {
            callActionIfExists(stopEditAppointment2, appointmentChanges);
            callActionIfExists(cancelChangedAppointment, appointmentChanges);
          }
          _this.toggleVisibility();
        }
        _this.setState({ previousAppointment: changedAppointment });
      };
    });
    _this.deleteAppointment = memoize(function(finishDeleteAppointment, appointmentData, openDeleteConfirmationDialog, changedAppointment, cancelAddedAppointment2, cancelChangedAppointment, stopEditAppointment2, isNew) {
      return function() {
        if (openDeleteConfirmationDialog) {
          openDeleteConfirmationDialog({
            hideActionName: TOGGLE_APPOINTMENT_FORM_VISIBILITY,
            appointmentData: changedAppointment
          });
        } else {
          callActionIfExists(finishDeleteAppointment, appointmentData);
          if (isNew) {
            callActionIfExists(cancelAddedAppointment2, appointmentData);
          } else {
            callActionIfExists(cancelChangedAppointment, appointmentData);
            callActionIfExists(stopEditAppointment2, appointmentData);
          }
          _this.toggleVisibility();
        }
        _this.setState({ previousAppointment: changedAppointment });
      };
    });
    _this.changeAppointmentField = memoize(function(isNew, changeAddedAppointment, changeAppointment2) {
      return function(change) {
        if (change && change.rRule) {
          _this.setState({ previousAppointment: __assign4(__assign4({}, _this.state.previousAppointment), { rRule: change.rRule }) });
        }
        if (isNew) {
          callActionIfExists(changeAddedAppointment, { change });
        } else {
          callActionIfExists(changeAppointment2, { change });
        }
      };
    });
    _this.getMessage = memoize(function(menuMessages, messages) {
      return getMessagesFormatter(__assign4(__assign4({}, menuMessages), messages));
    });
    _this.state = {
      visible: props.visible,
      appointmentData: props.appointmentData || {},
      previousAppointment: props.appointmentData || {}
    };
    var stateHelper = createStateHelper(_this, {
      visible: function() {
        var onVisibilityChange = _this.props.onVisibilityChange;
        return onVisibilityChange;
      },
      appointmentData: function() {
        var onAppointmentDataChange = _this.props.onAppointmentDataChange;
        return onAppointmentDataChange;
      }
    });
    var toggleVisibility = function() {
      var isOpen = _this.state.visible;
      return !isOpen;
    };
    _this.toggleVisibility = stateHelper.applyFieldReducer.bind(stateHelper, "visible", toggleVisibility);
    _this.setAppointmentData = stateHelper.applyFieldReducer.bind(stateHelper, "appointmentData", setAppointmentData);
    _this.openFormHandler = function(appointmentData) {
      _this.setAppointmentData({ appointmentData });
      _this.toggleVisibility();
    };
    return _this;
  }
  AppointmentFormBase2.getDerivedStateFromProps = function(nextProps, prevState) {
    var _a2 = nextProps.visible, visible = _a2 === void 0 ? prevState.visible : _a2, _b = nextProps.appointmentData, appointmentData = _b === void 0 ? prevState.appointmentData : _b;
    return {
      appointmentData,
      visible
    };
  };
  AppointmentFormBase2.prototype.render = function() {
    var _this = this;
    var _a2 = this.props, Container = _a2.containerComponent, Overlay = _a2.overlayComponent, Layout = _a2.layoutComponent, CommandLayout = _a2.commandLayoutComponent, BasicLayout = _a2.basicLayoutComponent, RecurrenceLayout = _a2.recurrenceLayoutComponent, commandButtonComponent = _a2.commandButtonComponent, textEditorComponent = _a2.textEditorComponent, labelComponent = _a2.labelComponent, dateEditorComponent = _a2.dateEditorComponent, booleanEditorComponent = _a2.booleanEditorComponent, selectComponent = _a2.selectComponent, radioGroupComponent = _a2.radioGroupComponent, weeklyRecurrenceSelectorComponent = _a2.weeklyRecurrenceSelectorComponent, resourceEditorComponent = _a2.resourceEditorComponent, readOnly = _a2.readOnly, messages = _a2.messages;
    var _b = this.state, visible = _b.visible, appointmentData = _b.appointmentData, previousAppointment = _b.previousAppointment;
    var getMessage = this.getMessage(defaultMessages$1, messages);
    return (0, import_react2.createElement)(
      Plugin,
      { name: "AppointmentForm", dependencies: pluginDependencies$5 },
      (0, import_react2.createElement)(Action, { name: TOGGLE_APPOINTMENT_FORM_VISIBILITY, action: this.toggleVisibility }),
      (0, import_react2.createElement)(
        Template,
        { name: "schedulerRoot" },
        (0, import_react2.createElement)(TemplateConnector, null, function(_a3, _b2) {
          var editingAppointment = _a3.editingAppointment, addedAppointment = _a3.addedAppointment, appointmentChanges = _a3.appointmentChanges, resources = _a3.resources, plainResources = _a3.plainResources;
          var openCancelConfirmationDialog = _b2.openCancelConfirmationDialog, stopEditAppointment2 = _b2.stopEditAppointment, cancelAddedAppointment2 = _b2.cancelAddedAppointment, cancelChangedAppointment = _b2.cancelChangedAppointment;
          var _c = prepareChanges(appointmentData, editingAppointment, addedAppointment, appointmentChanges, resources, plainResources), changedAppointment = _c.changedAppointment, isNew = _c.isNew;
          var fullSize = isFormFullSize(visible, changedAppointment.rRule, previousAppointment.rRule);
          var onHideAction = function() {
            return visible && _this.cancelChanges(openCancelConfirmationDialog, isNew, stopEditAppointment2, __assign4(__assign4({}, appointmentChanges), addedAppointment), changedAppointment, cancelAddedAppointment2, cancelChangedAppointment)();
          };
          return (0, import_react2.createElement)(
            import_react2.Fragment,
            null,
            (0, import_react2.createElement)(Container, { ref: _this.container }),
            (0, import_react2.createElement)(
              Overlay,
              { visible, onHide: onHideAction, fullSize, target: _this.container },
              (0, import_react2.createElement)(Layout, { basicLayoutComponent: BasicLayoutPlaceholder, commandLayoutComponent: CommandLayoutPlaceholder, recurrenceLayoutComponent: RecurrenceLayoutPlaceholder, isRecurrence: fullSize })
            ),
            (0, import_react2.createElement)(TemplatePlaceholder, null)
          );
        })
      ),
      (0, import_react2.createElement)(
        Template,
        { name: "commandLayout" },
        (0, import_react2.createElement)(TemplateConnector, null, function(_a3, _b2) {
          var editingAppointment = _a3.editingAppointment, addedAppointment = _a3.addedAppointment, appointmentChanges = _a3.appointmentChanges, resources = _a3.resources, plainResources = _a3.plainResources;
          var commitAddedAppointment = _b2.commitAddedAppointment, finishCommitAppointment = _b2.finishCommitAppointment, finishDeleteAppointment = _b2.finishDeleteAppointment, stopEditAppointment2 = _b2.stopEditAppointment, cancelAddedAppointment2 = _b2.cancelAddedAppointment, cancelChangedAppointment = _b2.cancelChangedAppointment, openCancelConfirmationDialog = _b2.openCancelConfirmationDialog, openDeleteConfirmationDialog = _b2.openDeleteConfirmationDialog;
          var _c = prepareChanges(appointmentData, editingAppointment, addedAppointment, appointmentChanges, resources, plainResources), isNew = _c.isNew, changedAppointment = _c.changedAppointment, isFormEdited = _c.isFormEdited;
          var isRecurrence = isFormFullSize(visible, changedAppointment.rRule, previousAppointment.rRule);
          return (0, import_react2.createElement)(CommandLayout, { commandButtonComponent, onCommitButtonClick: _this.commitChanges(finishCommitAppointment, commitAddedAppointment, isNew, changedAppointment), onCancelButtonClick: _this.cancelChanges(openCancelConfirmationDialog, isNew, stopEditAppointment2, __assign4(__assign4({}, appointmentChanges), addedAppointment), changedAppointment, cancelAddedAppointment2, cancelChangedAppointment), onDeleteButtonClick: _this.deleteAppointment(finishDeleteAppointment, appointmentData, openDeleteConfirmationDialog, changedAppointment, cancelAddedAppointment2, cancelChangedAppointment, stopEditAppointment2, isNew), getMessage, readOnly, fullSize: isRecurrence, disableSaveButton: !isFormEdited, hideDeleteButton: isNew });
        })
      ),
      (0, import_react2.createElement)(
        Template,
        { name: "basicLayout" },
        (0, import_react2.createElement)(TemplateConnector, null, function(_a3, _b2) {
          var editingAppointment = _a3.editingAppointment, addedAppointment = _a3.addedAppointment, appointmentChanges = _a3.appointmentChanges, locale2 = _a3.locale, resources = _a3.resources, plainResources = _a3.plainResources;
          var changeAppointment2 = _b2.changeAppointment, changeAddedAppointment = _b2.changeAddedAppointment;
          var _c = prepareChanges(appointmentData, editingAppointment, addedAppointment, appointmentChanges, resources, plainResources), isNew = _c.isNew, changedAppointment = _c.changedAppointment, appointmentResources = _c.appointmentResources;
          return (0, import_react2.createElement)(BasicLayout, { locale: locale2, appointmentData: visible ? changedAppointment : previousAppointment, onFieldChange: _this.changeAppointmentField(isNew, changeAddedAppointment, changeAppointment2), getMessage, readOnly, textEditorComponent, dateEditorComponent, booleanEditorComponent, selectComponent, labelComponent, resourceEditorComponent, fullSize: !changedAppointment.rRule, resources, appointmentResources });
        })
      ),
      (0, import_react2.createElement)(
        Template,
        { name: "recurrenceLayout" },
        (0, import_react2.createElement)(TemplateConnector, null, function(_a3, _b2) {
          var editingAppointment = _a3.editingAppointment, addedAppointment = _a3.addedAppointment, appointmentChanges = _a3.appointmentChanges, formatDate = _a3.formatDate, locale2 = _a3.locale, firstDayOfWeek = _a3.firstDayOfWeek;
          var changeAddedAppointment = _b2.changeAddedAppointment, changeAppointment2 = _b2.changeAppointment;
          var _c = prepareChanges(appointmentData, editingAppointment, addedAppointment, appointmentChanges, void 0, void 0), isNew = _c.isNew, changedAppointment = _c.changedAppointment;
          var isRecurrenceLayoutVisible = isFormFullSize(visible, changedAppointment.rRule, previousAppointment.rRule);
          var correctedAppointment = !changedAppointment.rRule ? __assign4(__assign4({}, changedAppointment), { rRule: previousAppointment.rRule }) : changedAppointment;
          return (0, import_react2.createElement)(RecurrenceLayout, { locale: locale2, appointmentData: visible ? correctedAppointment : previousAppointment, onFieldChange: _this.changeAppointmentField(isNew, changeAddedAppointment, changeAppointment2), getMessage, readOnly, formatDate, textEditorComponent, dateEditorComponent, radioGroupComponent, weeklyRecurrenceSelectorComponent, labelComponent, selectComponent, visible: isRecurrenceLayoutVisible, firstDayOfWeek });
        })
      ),
      (0, import_react2.createElement)(Template, { name: "tooltip" }, function(params) {
        return (0, import_react2.createElement)(TemplateConnector, null, function(getters, _a3) {
          var startEditAppointment2 = _a3.startEditAppointment;
          return (0, import_react2.createElement)(TemplatePlaceholder, { params: __assign4(__assign4({}, params), { onOpenButtonClick: function() {
            _this.openFormHandler(params.appointmentMeta.data);
            callActionIfExists(startEditAppointment2, params.appointmentMeta.data);
          } }) });
        });
      }),
      (0, import_react2.createElement)(Template, { name: "appointment" }, function(params) {
        return (0, import_react2.createElement)(TemplateConnector, null, function(getters, _a3) {
          var startEditAppointment2 = _a3.startEditAppointment;
          return (0, import_react2.createElement)(TemplatePlaceholder, { params: __assign4(__assign4({}, params), { onDoubleClick: function() {
            _this.openFormHandler(params.data);
            callActionIfExists(startEditAppointment2, params.data);
          } }) });
        });
      }),
      (0, import_react2.createElement)(Template, { name: "cell" }, function(params) {
        return (0, import_react2.createElement)(TemplateConnector, null, function(_a3, _b2) {
          var resources = _a3.resources;
          var addAppointment2 = _b2.addAppointment;
          return addDoubleClickToCell(void 0, params.startDate, params.endDate, params.groupingInfo, resources, isAllDayCell(params.startDate, params.endDate), _this.openFormHandler, addAppointment2, params);
        });
      }),
      (0, import_react2.createElement)(Template, { name: "allDayPanelCell" }, function(params) {
        return (0, import_react2.createElement)(TemplateConnector, null, function(_a3, _b2) {
          var resources = _a3.resources;
          var addAppointment2 = _b2.addAppointment;
          return addDoubleClickToCell(void 0, params.startDate, params.endDate, params.groupingInfo, resources, true, _this.openFormHandler, addAppointment2, params);
        });
      })
    );
  };
  AppointmentFormBase2.defaultProps = {
    messages: {},
    readOnly: false,
    onVisibilityChange: function() {
      return void 0;
    },
    onAppointmentDataChange: function() {
      return void 0;
    }
  };
  AppointmentFormBase2.components = {
    overlayComponent: "Overlay",
    layoutComponent: "Layout",
    commandLayoutComponent: "CommandLayout",
    commandButtonComponent: "CommandButton",
    basicLayoutComponent: "BasicLayout",
    textEditorComponent: "TextEditor",
    labelComponent: "Label",
    dateEditorComponent: "DateEditor",
    booleanEditorComponent: "BooleanEditor",
    selectComponent: "Select",
    recurrenceLayoutComponent: "RecurrenceLayout",
    radioGroupComponent: "RadioGroup",
    weeklyRecurrenceSelectorComponent: "WeeklyRecurrenceSelector",
    resourceEditorComponent: "ResourceEditor",
    containerComponent: "Container"
  };
  return AppointmentFormBase2;
}(import_react2.PureComponent);
var AppointmentForm = AppointmentFormBase;
var renderAppointmentItems = function(items, Wrapper, draftData) {
  return items.length > 0 ? (0, import_react2.createElement)(Wrapper, null, items.map(function(draftAppointment, index) {
    return (0, import_react2.createElement)(TemplatePlaceholder, { name: "draftAppointment", key: index.toString(), params: { data: draftData, draftAppointment } });
  })) : null;
};
var pluginDependencies$6 = [
  { name: "EditingState" },
  { name: "Appointments" },
  { name: "EditRecurrenceMenu", optional: true },
  { name: "IntegratedEditing", optional: true },
  { name: "DayView", optional: true },
  { name: "WeekView", optional: true },
  { name: "MonthView", optional: true },
  { name: "AllDayPanel", optional: true }
];
var DragDropProviderBase = function(_super) {
  __extends3(DragDropProviderBase2, _super);
  function DragDropProviderBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.timeTableDraftAppointments = [];
    _this.allDayDraftAppointments = [];
    _this.offsetTimeTop = null;
    _this.appointmentStartTime = null;
    _this.appointmentEndTime = null;
    _this.appointmentGroupingInfo = {};
    _this.state = {
      startTime: null,
      endTime: null,
      appointmentGroupingInfo: null,
      payload: null,
      isOutside: false,
      allowDrag: function() {
        return true;
      },
      allowResize: function() {
        return true;
      },
      appointmentContentTemplateKey: 0,
      appointmentTopTemplateKey: 0,
      appointmentBottomTemplateKey: 0
    };
    _this.handleDrop = function(_a2) {
      var finishCommitAppointment = _a2.finishCommitAppointment;
      return function() {
        finishCommitAppointment();
        _this.resetCache();
      };
    };
    _this.handleLeave = function() {
      _this.setState({ isOutside: true });
    };
    return _this;
  }
  DragDropProviderBase2.getDerivedStateFromProps = function(props, state) {
    var isAllowDragSame = props.allowDrag === state.allowDrag;
    var isAllowResizeSame = props.allowResize === state.allowResize;
    if (isAllowDragSame && isAllowResizeSame) {
      return null;
    }
    return __assign4(__assign4({}, state), { appointmentContentTemplateKey: isAllowDragSame ? state.appointmentContentTemplateKey : Math.random(), appointmentTopTemplateKey: isAllowResizeSame ? state.appointmentTopTemplateKey : Math.random(), appointmentBottomTemplateKey: isAllowResizeSame ? state.appointmentBottomTemplateKey : Math.random(), allowDrag: props.allowDrag, allowResize: props.allowResize });
  };
  DragDropProviderBase2.prototype.onPayloadChange = function(actions) {
    var _this = this;
    return function(args) {
      return _this.handlePayloadChange(args, actions);
    };
  };
  DragDropProviderBase2.prototype.calculateNextBoundaries = function(getters, actions, scrollSpeed) {
    var _this = this;
    return function(args) {
      return _this.calculateBoundaries(args, getters, actions, scrollSpeed);
    };
  };
  DragDropProviderBase2.prototype.resetCache = function() {
    this.timeTableDraftAppointments = [];
    this.allDayDraftAppointments = [];
    this.offsetTimeTop = null;
    this.appointmentStartTime = null;
    this.appointmentEndTime = null;
    this.appointmentGroupingInfo = {};
    this.setState({
      payload: null,
      startTime: null,
      endTime: null,
      isOutside: false
    });
  };
  DragDropProviderBase2.prototype.applyChanges = function(startTime, endTime, payload, startEditAppointment2, changeAppointment2, appointmentGroupingInfo) {
    startEditAppointment2(payload);
    changeAppointment2({
      change: __assign4(__assign4({ startDate: startTime, endDate: endTime }, payload.allDay && { allDay: void 0 }), this.appointmentGroupingInfo)
    });
    this.setState({ startTime, endTime, payload, isOutside: false, appointmentGroupingInfo });
  };
  DragDropProviderBase2.prototype.handlePayloadChange = function(_a2, _b) {
    var payload = _a2.payload;
    var finishCommitAppointment = _b.finishCommitAppointment;
    var isOutside = this.state.isOutside;
    if (payload || !isOutside)
      return;
    finishCommitAppointment();
    this.resetCache();
  };
  DragDropProviderBase2.prototype.calculateBoundaries = function(_a2, _b, _c, scrollSpeed) {
    var payload = _a2.payload, clientOffset = _a2.clientOffset;
    var viewCellsData2 = _b.viewCellsData, allDayCellsData = _b.allDayCellsData, startViewDate2 = _b.startViewDate, endViewDate2 = _b.endViewDate, excludedDays = _b.excludedDays, currentView = _b.currentView, timeTableElementsMeta = _b.timeTableElementsMeta, allDayElementsMeta = _b.allDayElementsMeta, scrollingStrategy = _b.scrollingStrategy, grouping = _b.grouping, resources = _b.resources, groups = _b.groups, getGroupOrientation = _b.groupOrientation, groupByDate = _b.groupByDate;
    var changeAppointment2 = _c.changeAppointment, startEditAppointment2 = _c.startEditAppointment;
    if (clientOffset) {
      autoScroll(clientOffset, scrollingStrategy, scrollSpeed);
    }
    var tableCellElementsMeta = timeTableElementsMeta;
    var groupOrientation = getGroupOrientation ? getGroupOrientation(currentView === null || currentView === void 0 ? void 0 : currentView.name) : HORIZONTAL_GROUP_ORIENTATION;
    var allDayCellsElementsMeta = allDayElementsMeta && allDayElementsMeta.getCellRects ? allDayElementsMeta : { getCellRects: [] };
    var timeTableIndex = cellIndex(tableCellElementsMeta.getCellRects, clientOffset);
    var allDayIndex = cellIndex(allDayCellsElementsMeta.getCellRects, clientOffset);
    if (allDayIndex === -1 && timeTableIndex === -1)
      return;
    var targetData = cellData(timeTableIndex, allDayIndex, viewCellsData2, allDayCellsData);
    var targetType = cellType(targetData);
    var insidePart = calculateInsidePart(clientOffset.y, tableCellElementsMeta.getCellRects, timeTableIndex);
    var cellDurationMinutes = intervalDuration(targetData, "minutes");
    var _d = calculateAppointmentTimeBoundaries(payload, targetData, targetType, cellDurationMinutes, insidePart, this.offsetTimeTop), appointmentStartTime = _d.appointmentStartTime, appointmentEndTime = _d.appointmentEndTime, offsetTimeTop = _d.offsetTimeTop;
    var appointmentGroups = calculateAppointmentGroups(targetData.groupingInfo, resources, payload);
    this.appointmentStartTime = appointmentStartTime || this.appointmentStartTime;
    this.appointmentEndTime = appointmentEndTime || this.appointmentEndTime;
    this.appointmentGroupingInfo = appointmentGroups || this.appointmentGroupingInfo;
    this.offsetTimeTop = offsetTimeTop;
    var _e = this.state, startTime = _e.startTime, endTime = _e.endTime, appointmentGroupingInfo = _e.appointmentGroupingInfo;
    if (!appointmentDragged(this.appointmentStartTime, startTime, this.appointmentEndTime, endTime, this.appointmentGroupingInfo, appointmentGroupingInfo)) {
      return;
    }
    var draftAppointments = [{
      dataItem: __assign4(__assign4(__assign4({}, payload), { startDate: this.appointmentStartTime, endDate: this.appointmentEndTime }), this.appointmentGroupingInfo),
      start: this.appointmentStartTime,
      end: this.appointmentEndTime
    }];
    var _f = calculateDraftAppointments(allDayIndex, draftAppointments, startViewDate2, endViewDate2, excludedDays, viewCellsData2, allDayCellsElementsMeta, targetType, cellDurationMinutes, tableCellElementsMeta, grouping, resources, groups, groupOrientation, groupByDate === null || groupByDate === void 0 ? void 0 : groupByDate(currentView === null || currentView === void 0 ? void 0 : currentView.name)), allDayDraftAppointments = _f.allDayDraftAppointments, timeTableDraftAppointments = _f.timeTableDraftAppointments;
    this.allDayDraftAppointments = allDayDraftAppointments;
    this.timeTableDraftAppointments = timeTableDraftAppointments;
    this.applyChanges(this.appointmentStartTime, this.appointmentEndTime, payload, startEditAppointment2, changeAppointment2, this.appointmentGroupingInfo);
  };
  DragDropProviderBase2.prototype.render = function() {
    var _this = this;
    var _a2 = this.state, payload = _a2.payload, appointmentContentTemplateKey = _a2.appointmentContentTemplateKey, appointmentBottomTemplateKey = _a2.appointmentBottomTemplateKey, appointmentTopTemplateKey = _a2.appointmentTopTemplateKey;
    var _b = this.props, Container = _b.containerComponent, DraftAppointment = _b.draftAppointmentComponent, SourceAppointment = _b.sourceAppointmentComponent, Resize = _b.resizeComponent, allowDrag = _b.allowDrag, allowResize = _b.allowResize, scrollSpeed = _b.scrollSpeed;
    var draftData = __assign4(__assign4({}, payload), { startDate: this.appointmentStartTime, endDate: this.appointmentEndTime });
    return (0, import_react2.createElement)(
      Plugin,
      { name: "DragDropProvider", dependencies: pluginDependencies$6 },
      (0, import_react2.createElement)(
        Template,
        { name: "body" },
        (0, import_react2.createElement)(TemplateConnector, null, function(_a3, _b2) {
          var viewCellsData2 = _a3.viewCellsData, allDayCellsData = _a3.allDayCellsData, startViewDate2 = _a3.startViewDate, endViewDate2 = _a3.endViewDate, excludedDays = _a3.excludedDays, timeTableElementsMeta = _a3.timeTableElementsMeta, allDayElementsMeta = _a3.allDayElementsMeta, scrollingStrategy = _a3.scrollingStrategy, grouping = _a3.grouping, resources = _a3.resources, groups = _a3.groups, currentView = _a3.currentView, groupByDate = _a3.groupByDate, groupOrientation = _a3.groupOrientation;
          var changeAppointment2 = _b2.changeAppointment, startEditAppointment2 = _b2.startEditAppointment, finishCommitAppointment = _b2.finishCommitAppointment;
          var calculateBoundariesByMove = _this.calculateNextBoundaries({
            viewCellsData: viewCellsData2,
            allDayCellsData,
            currentView,
            startViewDate: startViewDate2,
            endViewDate: endViewDate2,
            excludedDays,
            timeTableElementsMeta,
            allDayElementsMeta,
            scrollingStrategy,
            resources,
            grouping,
            groups,
            groupByDate,
            groupOrientation
          }, { changeAppointment: changeAppointment2, startEditAppointment: startEditAppointment2 }, scrollSpeed);
          return (0, import_react2.createElement)(
            DragDropProvider,
            { onChange: _this.onPayloadChange({ finishCommitAppointment }) },
            (0, import_react2.createElement)(
              DropTarget,
              { onOver: calculateBoundariesByMove, onEnter: calculateBoundariesByMove, onDrop: _this.handleDrop({ finishCommitAppointment }), onLeave: _this.handleLeave },
              (0, import_react2.createElement)(PlaceholderWithRef, null)
            )
          );
        })
      ),
      (0, import_react2.createElement)(Template, { name: "appointmentContent", predicate: function(_a3) {
        var data = _a3.data;
        return allowDrag(data);
      }, key: appointmentContentTemplateKey }, function(_a3) {
        var styles2 = _a3.styles, params = __rest3(_a3, ["styles"]);
        return (0, import_react2.createElement)(DragSource, { payload: __assign4(__assign4({}, params.data), { type: params.type }) }, payload && params.data.id === payload.id ? (0, import_react2.createElement)(SourceAppointment, __assign4({}, params)) : (0, import_react2.createElement)(PlaceholderWithRef, { params: __assign4(__assign4({}, params), { draggable: true }) }));
      }),
      (0, import_react2.createElement)(Template, { name: "appointmentTop", predicate: function(params) {
        return !params.slice && allowResize(params.data);
      }, key: appointmentTopTemplateKey }, function(_a3) {
        var data = _a3.data, type = _a3.type;
        return (0, import_react2.createElement)(
          DragSource,
          { payload: __assign4(__assign4({}, data), { type: RESIZE_TOP, appointmentType: type }) },
          (0, import_react2.createElement)(Resize, { position: POSITION_START, appointmentType: type })
        );
      }),
      (0, import_react2.createElement)(Template, { name: "appointmentBottom", predicate: function(params) {
        return !params.slice && allowResize(params.data);
      }, key: appointmentBottomTemplateKey }, function(_a3) {
        var data = _a3.data, type = _a3.type;
        return (0, import_react2.createElement)(
          DragSource,
          { payload: __assign4(__assign4({}, data), { type: RESIZE_BOTTOM, appointmentType: type }) },
          (0, import_react2.createElement)(Resize, { position: POSITION_END, appointmentType: type })
        );
      }),
      (0, import_react2.createElement)(
        Template,
        { name: "allDayPanel" },
        (0, import_react2.createElement)(TemplateConnector, null, function(_a3) {
          var currentView = _a3.currentView, groupOrientation = _a3.groupOrientation;
          return (0, import_react2.createElement)(
            import_react2.Fragment,
            null,
            (0, import_react2.createElement)(TemplatePlaceholder, null),
            (groupOrientation === null || groupOrientation === void 0 ? void 0 : groupOrientation(currentView.name)) !== VERTICAL_GROUP_ORIENTATION ? renderAppointmentItems(_this.allDayDraftAppointments, Container, draftData) : null
          );
        })
      ),
      (0, import_react2.createElement)(
        Template,
        { name: "timeTable" },
        (0, import_react2.createElement)(TemplateConnector, null, function(_a3) {
          var currentView = _a3.currentView, groupOrientation = _a3.groupOrientation;
          return (0, import_react2.createElement)(
            import_react2.Fragment,
            null,
            (0, import_react2.createElement)(TemplatePlaceholder, null),
            renderAppointmentItems(_this.timeTableDraftAppointments, Container, draftData),
            (groupOrientation === null || groupOrientation === void 0 ? void 0 : groupOrientation(currentView.name)) === VERTICAL_GROUP_ORIENTATION ? renderAppointmentItems(_this.allDayDraftAppointments, Container, draftData) : null
          );
        })
      ),
      (0, import_react2.createElement)(Template, { name: "draftAppointment" }, function(_a3) {
        var data = _a3.data, draftAppointment = _a3.draftAppointment, restParams = __rest3(_a3, ["data", "draftAppointment"]);
        return (0, import_react2.createElement)(TemplateConnector, null, function(_a4) {
          var formatDate = _a4.formatDate, resources = _a4.resources, plainResources = _a4.plainResources;
          var dataItem = draftAppointment.dataItem, type = draftAppointment.type, fromPrev = draftAppointment.fromPrev, toNext = draftAppointment.toNext, durationType = draftAppointment.durationType, geometry = __rest3(draftAppointment, ["dataItem", "type", "fromPrev", "toNext", "durationType"]);
          return (0, import_react2.createElement)(DraftAppointment, __assign4({ data, resources: getAppointmentResources(dataItem, resources, plainResources), durationType, style: getAppointmentStyle(geometry), type, fromPrev, toNext, formatDate }, restParams));
        });
      })
    );
  };
  DragDropProviderBase2.components = {
    containerComponent: "Container",
    draftAppointmentComponent: "DraftAppointment",
    sourceAppointmentComponent: "SourceAppointment",
    resizeComponent: "Resize"
  };
  DragDropProviderBase2.defaultProps = {
    allowDrag: function() {
      return true;
    },
    allowResize: function() {
      return true;
    },
    scrollSpeed: SCROLL_SPEED_PX
  };
  return DragDropProviderBase2;
}(import_react2.PureComponent);
var DragDropProvider2 = DragDropProviderBase;
var pluginDependencies$7 = [
  { name: "Toolbar" },
  { name: "ViewState" }
];
var defaultMessages$2 = {
  today: "Today"
};
var TodayButtonBase = function(_super) {
  __extends3(TodayButtonBase2, _super);
  function TodayButtonBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  TodayButtonBase2.prototype.render = function() {
    var _a2 = this.props, Button = _a2.buttonComponent, messages = _a2.messages;
    var getMessage = getMessagesFormatter(__assign4(__assign4({}, defaultMessages$2), messages));
    return (0, import_react2.createElement)(
      Plugin,
      { name: "TodayButton", dependencies: pluginDependencies$7 },
      (0, import_react2.createElement)(
        Template,
        { name: "toolbarContent" },
        (0, import_react2.createElement)(TemplateConnector, null, function(getters, _a3) {
          var changeCurrentDate2 = _a3.changeCurrentDate;
          var setCurrentDate = function(nextDate) {
            return changeCurrentDate2({
              nextDate
            });
          };
          return (0, import_react2.createElement)(Button, { getMessage, setCurrentDate });
        }),
        (0, import_react2.createElement)(TemplatePlaceholder, null)
      )
    );
  };
  TodayButtonBase2.components = {
    buttonComponent: "Button"
  };
  return TodayButtonBase2;
}(import_react2.PureComponent);
var TodayButton = TodayButtonBase;
var _a;
var pluginDependencies$8 = [
  { name: "EditingState" }
];
var defaultAvailableOperations = [
  { value: RECURRENCE_EDIT_SCOPE.CURRENT },
  { value: RECURRENCE_EDIT_SCOPE.CURRENT_AND_FOLLOWING },
  { value: RECURRENCE_EDIT_SCOPE.ALL }
];
var defaultMessages$3 = (_a = {}, _a[RECURRENCE_EDIT_SCOPE.CURRENT] = "This appointment", _a[RECURRENCE_EDIT_SCOPE.CURRENT_AND_FOLLOWING] = "This and following appointments", _a[RECURRENCE_EDIT_SCOPE.ALL] = "All appointments", _a.menuEditingTitle = "Edit recurring appointment", _a.menuDeletingTitle = "Delete recurring appointment", _a.cancelButton = "Cancel", _a.commitButton = "OK", _a);
var EditRecurrenceMenuBase = function(_super) {
  __extends3(EditRecurrenceMenuBase2, _super);
  function EditRecurrenceMenuBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.modalContainer = (0, import_react2.createRef)();
    _this.state = {
      isOpen: false,
      deletedAppointmentData: null
    };
    _this.finishCommitAppointment = function(payload, _a2, _b) {
      var editingAppointment = _a2.editingAppointment;
      var commitChangedAppointment = _b.commitChangedAppointment;
      if (editingAppointment && !editingAppointment.rRule) {
        commitChangedAppointment();
      } else {
        _this.setState({
          isOpen: true,
          deletedAppointmentData: null
        });
      }
    };
    _this.finishDeleteAppointment = function(payload, getters, _a2) {
      var commitDeletedAppointment = _a2.commitDeletedAppointment;
      if (payload && !payload.rRule) {
        commitDeletedAppointment({ deletedAppointmentData: payload });
      } else {
        _this.setState({
          isOpen: true,
          deletedAppointmentData: payload
        });
      }
    };
    _this.commit = memoize(function(editAction, deleteAction, payload) {
      return function(type) {
        if (payload) {
          deleteAction({ deletedAppointmentData: payload, type });
        } else {
          editAction(type);
        }
        _this.closeMenu();
      };
    });
    _this.closeMenu = function() {
      _this.setState({ isOpen: false, deletedAppointmentData: null });
    };
    _this.cancelEditing = memoize(function(cancelAction, stopEditAction) {
      return function() {
        stopEditAction();
        cancelAction();
        _this.closeMenu();
      };
    });
    _this.availableOperations = memoize(function(getMessage, menuAvailableOperations) {
      return menuAvailableOperations.map(function(_a2) {
        var value = _a2.value;
        return {
          value,
          title: getMessage([value])
        };
      });
    });
    _this.getMessage = memoize(function(messages, menuMessages) {
      return getMessagesFormatter(__assign4(__assign4({}, menuMessages), messages));
    });
    return _this;
  }
  EditRecurrenceMenuBase2.prototype.render = function() {
    var _this = this;
    var _a2 = this.state, isOpen = _a2.isOpen, deletedAppointmentData = _a2.deletedAppointmentData;
    var _b = this.props, Layout = _b.layoutComponent, Overlay = _b.overlayComponent, Container = _b.containerComponent, buttonComponent = _b.buttonComponent, messages = _b.messages;
    var getMessage = this.getMessage(messages, defaultMessages$3);
    var availableOperations = this.availableOperations(getMessage, defaultAvailableOperations);
    return (0, import_react2.createElement)(
      Plugin,
      { name: "EditRecurrenceMenu", dependencies: pluginDependencies$8 },
      (0, import_react2.createElement)(Action, { name: "finishCommitAppointment", action: this.finishCommitAppointment }),
      (0, import_react2.createElement)(Action, { name: "finishDeleteAppointment", action: this.finishDeleteAppointment }),
      (0, import_react2.createElement)(
        Template,
        { name: "schedulerRoot" },
        (0, import_react2.createElement)(TemplatePlaceholder, null),
        (0, import_react2.createElement)(Container, { ref: this.modalContainer }),
        (0, import_react2.createElement)(TemplatePlaceholder, { name: "overlay" })
      ),
      (0, import_react2.createElement)(
        Template,
        { name: "overlay" },
        (0, import_react2.createElement)(TemplateConnector, null, function(getters, _a3) {
          var commitChangedAppointment = _a3.commitChangedAppointment, commitDeletedAppointment = _a3.commitDeletedAppointment, cancelChangedAppointment = _a3.cancelChangedAppointment, stopEditAppointment2 = _a3.stopEditAppointment;
          var commit = _this.commit(commitChangedAppointment, commitDeletedAppointment, deletedAppointmentData);
          var cancelEditing = _this.cancelEditing(cancelChangedAppointment, stopEditAppointment2);
          return (0, import_react2.createElement)(
            Overlay,
            { target: _this.modalContainer, visible: isOpen, onHide: _this.closeMenu },
            (0, import_react2.createElement)(Layout, { isDeleting: !!deletedAppointmentData, buttonComponent, handleClose: cancelEditing, commit, availableOperations, getMessage })
          );
        })
      )
    );
  };
  EditRecurrenceMenuBase2.components = {
    layoutComponent: "Layout",
    overlayComponent: "Overlay",
    buttonComponent: "Button",
    containerComponent: "Container"
  };
  return EditRecurrenceMenuBase2;
}(import_react2.PureComponent);
var EditRecurrenceMenu = EditRecurrenceMenuBase;
var pluginDependencies$9 = [
  { name: "EditingState" }
];
var IntegratedEditingBase = function(_super) {
  __extends3(IntegratedEditingBase2, _super);
  function IntegratedEditingBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.finishCommitAppointment = function(payload, getters, _a2) {
      var commitChangedAppointment = _a2.commitChangedAppointment;
      commitChangedAppointment();
    };
    _this.finishDeleteAppointment = function(payload, getters, _a2) {
      var commitDeletedAppointment = _a2.commitDeletedAppointment;
      commitDeletedAppointment({ deletedAppointmentData: payload });
    };
    return _this;
  }
  IntegratedEditingBase2.prototype.render = function() {
    return (0, import_react2.createElement)(
      Plugin,
      { name: "IntegratedEditing", dependencies: pluginDependencies$9 },
      (0, import_react2.createElement)(Action, { name: "finishCommitAppointment", action: this.finishCommitAppointment }),
      (0, import_react2.createElement)(Action, { name: "finishDeleteAppointment", action: this.finishDeleteAppointment })
    );
  };
  IntegratedEditingBase2.defaultProps = {
    totalCount: 0
  };
  return IntegratedEditingBase2;
}(import_react2.PureComponent);
var IntegratedEditing = IntegratedEditingBase;
var pluginDependencies$a = [
  { name: "Appointments" }
];
var addResourcesToTimeTableAppointments = function(_a2) {
  var timeTableAppointments = _a2.timeTableAppointments, resources = _a2.resources, plainResources = _a2.plainResources;
  return timeTableAppointments && addResourcesToAppointments(timeTableAppointments[0], resources, plainResources);
};
var addResourcesToAllDayAppointments = function(_a2) {
  var allDayAppointments = _a2.allDayAppointments, resources = _a2.resources, plainResources = _a2.plainResources;
  return allDayAppointments && addResourcesToAppointments(allDayAppointments[0], resources, plainResources);
};
var ResourcesBase = (0, import_react2.memo)(function(_a2) {
  var data = _a2.data, mainResourceName = _a2.mainResourceName, palette = _a2.palette;
  var convertResources = function(_a3) {
    var resources = _a3.resources;
    return convertResourcesToPlain(resources);
  };
  return (0, import_react2.createElement)(
    Plugin,
    { name: "Resources", dependencies: pluginDependencies$a },
    (0, import_react2.createElement)(Getter, { name: "resources", value: validateResources(data, mainResourceName, palette) }),
    (0, import_react2.createElement)(Getter, { name: "plainResources", computed: convertResources }),
    (0, import_react2.createElement)(Getter, { name: "timeTableAppointments", computed: addResourcesToTimeTableAppointments }),
    (0, import_react2.createElement)(Getter, { name: "allDayAppointments", computed: addResourcesToAllDayAppointments })
  );
});
var Resources = ResourcesBase;
var defaultMessages$4 = {
  discardButton: "Discard",
  deleteButton: "Delete",
  cancelButton: "Cancel",
  confirmDeleteMessage: "Are you sure you want to delete this appointment?",
  confirmCancelMessage: "Discard unsaved changes?"
};
var pluginDependencies$b = [
  { name: "EditingState" },
  { name: "EditRecurrenceMenu", optional: true },
  { name: "IntegratedEditing", optional: true }
];
var ACTION_TYPES = {
  CANCEL: "cancel",
  DELETE: "delete"
};
var ConfirmationDialogBase = function(_a2) {
  var messages = _a2.messages, Overlay = _a2.overlayComponent, Layout = _a2.layoutComponent, Container = _a2.containerComponent, buttonComponent = _a2.buttonComponent, ignoreDelete = _a2.ignoreDelete, ignoreCancel = _a2.ignoreCancel;
  var getMessage = getMessagesFormatter(__assign4(__assign4({}, defaultMessages$4), messages));
  var modalContainer = (0, import_react2.useRef)();
  var _b = __read4((0, import_react2.useState)(false), 2), visible = _b[0], setVisible = _b[1];
  var _c = __read4((0, import_react2.useState)(""), 2), actionType = _c[0], setActionType = _c[1];
  var _d = __read4((0, import_react2.useState)(""), 2), hideActionName = _d[0], setHideActionName = _d[1];
  var _e = __read4((0, import_react2.useState)({}), 2), appointmentData = _e[0], setAppointmentData2 = _e[1];
  var toggleVisibility = (0, import_react2.useCallback)(function() {
    setVisible(!visible);
  }, [visible, setVisible]);
  var confirmCancelChanges = (0, import_react2.useCallback)(function(hideAction) {
    toggleVisibility();
    setHideActionName(hideAction);
    setActionType(ACTION_TYPES.CANCEL);
  }, [toggleVisibility, setHideActionName, setActionType]);
  var confirmDelete = (0, import_react2.useCallback)(function(_a3) {
    var hideAction = _a3.hideActionName, changedAppointment = _a3.appointmentData;
    toggleVisibility();
    setHideActionName(hideAction);
    setActionType(ACTION_TYPES.DELETE);
    setAppointmentData2(changedAppointment);
  }, [toggleVisibility, setHideActionName, setActionType, setAppointmentData2]);
  var confirmAction = (0, import_react2.useCallback)(function(isNewAppointment, hideEditor, stopEditAppointment2, finishDeleteAppointment, cancelAddedAppointment2, cancelChangedAppointment) {
    return function() {
      hideEditor();
      toggleVisibility();
      if (isNewAppointment) {
        cancelAddedAppointment2();
      } else {
        stopEditAppointment2();
        cancelChangedAppointment();
      }
      if (actionType === ACTION_TYPES.DELETE) {
        finishDeleteAppointment(appointmentData);
      }
    };
  }, [toggleVisibility, actionType, appointmentData]);
  return (0, import_react2.createElement)(
    Plugin,
    { name: "ConfirmationDialog", dependencies: pluginDependencies$b },
    !ignoreCancel && (0, import_react2.createElement)(Action, { name: "openCancelConfirmationDialog", action: confirmCancelChanges }),
    !ignoreDelete && (0, import_react2.createElement)(Action, { name: "openDeleteConfirmationDialog", action: confirmDelete }),
    (0, import_react2.createElement)(
      Template,
      { name: "schedulerRoot" },
      (0, import_react2.createElement)(TemplatePlaceholder, null),
      (0, import_react2.createElement)(Container, { ref: modalContainer }),
      (0, import_react2.createElement)(TemplatePlaceholder, { name: "confirmationDialogOverlay" })
    ),
    (0, import_react2.createElement)(
      Template,
      { name: "confirmationDialogOverlay" },
      (0, import_react2.createElement)(TemplateConnector, null, function(_a3, actions) {
        var editingAppointment = _a3.editingAppointment;
        var handleConfirm = confirmAction(!editingAppointment, actions[hideActionName], actions.stopEditAppointment, actions.finishDeleteAppointment, actions.cancelAddedAppointment, actions.cancelChangedAppointment);
        return (0, import_react2.createElement)(
          Overlay,
          { target: modalContainer, visible, onHide: toggleVisibility },
          (0, import_react2.createElement)(Layout, { buttonComponent, handleCancel: toggleVisibility, handleConfirm, getMessage, isDeleting: actionType === ACTION_TYPES.DELETE, appointmentData })
        );
      })
    )
  );
};
ConfirmationDialogBase.components = {
  overlayComponent: "Overlay",
  containerComponent: "Container",
  layoutComponent: "Layout",
  buttonComponent: "Button"
};
ConfirmationDialogBase.defaultProps = {
  ignoreCancel: false,
  ignoreDelete: false
};
var ConfirmationDialog = ConfirmationDialogBase;
var GroupingStateBase = function(_super) {
  __extends3(GroupingStateBase2, _super);
  function GroupingStateBase2(props) {
    var _this = _super.call(this, props) || this;
    _this.state = {
      grouping: props.grouping,
      expandedGroups: props.expandedGroups || props.defaultExpandedGroups
    };
    _this.stateHelper = createStateHelper(_this, {
      expandedGroups: function() {
        var onExpandedGroupsChange = _this.props.onExpandedGroupsChange;
        return onExpandedGroupsChange;
      }
    });
    _this.toggleGroupExpanded = _this.stateHelper.applyReducer.bind(_this.stateHelper, toggleExpandedGroups);
    return _this;
  }
  GroupingStateBase2.getDerivedStateFromProps = function(nextProps, prevState) {
    var _a2 = nextProps.grouping, grouping = _a2 === void 0 ? prevState.grouping : _a2, _b = nextProps.expandedGroups, expandedGroups = _b === void 0 ? prevState.expandedGroups : _b;
    return { grouping, expandedGroups };
  };
  GroupingStateBase2.prototype.render = function() {
    var _a2 = this.state, grouping = _a2.grouping, expandedGroups = _a2.expandedGroups;
    var _b = this.props, groupByDate = _b.groupByDate, groupOrientation = _b.groupOrientation;
    return (0, import_react2.createElement)(
      Plugin,
      { name: "GroupingState" },
      (0, import_react2.createElement)(Getter, { name: "grouping", value: grouping }),
      (0, import_react2.createElement)(Getter, { name: "groupByDate", value: groupByDate }),
      (0, import_react2.createElement)(Getter, { name: "groupOrientation", value: groupOrientation }),
      (0, import_react2.createElement)(Getter, { name: "expandedGroups", value: expandedGroups }),
      (0, import_react2.createElement)(Action, { name: "toggleGroupExpanded", action: this.toggleGroupExpanded })
    );
  };
  GroupingStateBase2.defaultProps = {
    defaultExpandedGroups: [],
    groupByDate: function() {
      return false;
    },
    groupOrientation: function() {
      return HORIZONTAL_GROUP_ORIENTATION;
    }
  };
  return GroupingStateBase2;
}(import_react2.PureComponent);
var GroupingState = GroupingStateBase;
var pluginDependencies$c = [
  { name: "GroupingState" },
  { name: "IntegratedGrouping" },
  { name: "DayView", optional: true },
  { name: "MonthView", optional: true },
  { name: "WeekView", optional: true },
  { name: "ViewState", optional: true }
];
var GroupingPanelBase = function(_super) {
  __extends3(GroupingPanelBase2, _super);
  function GroupingPanelBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  GroupingPanelBase2.prototype.render = function() {
    var _a2 = this.props, HorizontalLayout = _a2.horizontalLayoutComponent, VerticalLayout = _a2.verticalLayoutComponent, rowComponent = _a2.rowComponent, cellComponent = _a2.cellComponent;
    return (0, import_react2.createElement)(
      Plugin,
      { name: "GroupingPanel", dependencies: pluginDependencies$c },
      (0, import_react2.createElement)(
        Template,
        { name: "groupingPanel" },
        (0, import_react2.createElement)(TemplateConnector, null, function(_a3) {
          var viewCellsData2 = _a3.viewCellsData, currentView = _a3.currentView, scrollingStrategy = _a3.scrollingStrategy, allDayPanelExists = _a3.allDayPanelExists, groupByDate = _a3.groupByDate, getGroupOrientation = _a3.groupOrientation, groups = _a3.groups;
          var groupOrientation = getGroupOrientation(currentView === null || currentView === void 0 ? void 0 : currentView.name);
          return groupOrientation === HORIZONTAL_GROUP_ORIENTATION ? (0, import_react2.createElement)(HorizontalLayout, { rowComponent, cellComponent, groups, colSpan: viewCellsData2[0].length, cellStyle: {
            left: scrollingStrategy.fixedLeftWidth ? scrollingStrategy.fixedLeftWidth : (currentView === null || currentView === void 0 ? void 0 : currentView.type) === VIEW_TYPES.MONTH ? HORIZONTAL_VIEW_LEFT_OFFSET : VERTICAL_VIEW_LEFT_OFFSET
          }, showHeaderForEveryDate: groupByDate === null || groupByDate === void 0 ? void 0 : groupByDate(currentView && currentView.name) }) : (0, import_react2.createElement)(VerticalLayout, { rowComponent, cellComponent, groups, rowSpan: viewCellsData2.length, viewType: currentView === null || currentView === void 0 ? void 0 : currentView.type, cellTextTopOffset: scrollingStrategy === null || scrollingStrategy === void 0 ? void 0 : scrollingStrategy.fixedTopHeight, alignWithAllDayRow: allDayPanelExists });
        })
      )
    );
  };
  GroupingPanelBase2.components = {
    horizontalLayoutComponent: "HorizontalLayout",
    verticalLayoutComponent: "VerticalLayout",
    rowComponent: "Row",
    cellComponent: "Cell"
  };
  return GroupingPanelBase2;
}(import_react2.PureComponent);
var GroupingPanel = GroupingPanelBase;
var pluginDependencies$d = [
  { name: "DayView", optional: true },
  { name: "WeekView", optional: true },
  { name: "MonthView", optional: true },
  { name: "DragDropProvider", optional: true },
  { name: "Appointments", optional: true }
];
var CurrentTimeIndicatorBase = function(_a2) {
  var indicatorComponent = _a2.indicatorComponent, shadePreviousAppointments = _a2.shadePreviousAppointments, shadePreviousCells = _a2.shadePreviousCells, updateInterval = _a2.updateInterval;
  var _b = __read4((0, import_react2.useState)(Date.now), 2), currentTime = _b[0], setCurrentTime = _b[1];
  (0, import_react2.useEffect)(function() {
    var tick = function() {
      return setCurrentTime(Date.now());
    };
    var intervalId = updateInterval ? window.setInterval(tick, updateInterval) : void 0;
    return function() {
      return window.clearInterval(intervalId);
    };
  }, [updateInterval]);
  return (0, import_react2.createElement)(
    Plugin,
    { name: "CurrentTimeIndicator", dependencies: pluginDependencies$d },
    (0, import_react2.createElement)(Template, { name: "cell", predicate: function(_a3) {
      var otherMonth = _a3.otherMonth;
      return !isMonthCell(otherMonth);
    } }, function(params) {
      return (0, import_react2.createElement)(TemplatePlaceholder, { params: __assign4(__assign4({}, params), { currentTimeIndicatorPosition: getCurrentTimeIndicatorTop(params, currentTime), currentTimeIndicatorComponent: indicatorComponent }) });
    }),
    (0, import_react2.createElement)(Template, { name: "cell" }, function(params) {
      return (0, import_react2.createElement)(TemplatePlaceholder, { params: __assign4(__assign4({}, params), { isShaded: isCellShaded(params, currentTime, shadePreviousCells) }) });
    }),
    (0, import_react2.createElement)(Template, { name: "appointmentContent" }, function(params) {
      return (0, import_react2.createElement)(TemplatePlaceholder, { params: __assign4(__assign4({}, params), { isShaded: isShadedAppointment(params, currentTime, shadePreviousAppointments) }) });
    }),
    (0, import_react2.createElement)(Template, { name: "draftAppointment" }, function(params) {
      return (0, import_react2.createElement)(TemplatePlaceholder, { params: __assign4(__assign4({}, params), { isShaded: isShadedAppointment(params, currentTime, shadePreviousAppointments) }) });
    })
  );
};
CurrentTimeIndicatorBase.defaultProps = {
  updateInterval: 6e4,
  shadePreviousCells: false,
  shadePreviousAppointments: false
};
CurrentTimeIndicatorBase.components = {
  indicatorComponent: "Indicator"
};
var CurrentTimeIndicator = CurrentTimeIndicatorBase;
var pluginDependencies$e = [
  { name: "Resources" },
  { name: "GroupingState" },
  { name: "DayView", optional: true },
  { name: "MonthView", optional: true },
  { name: "WeekView", optional: true }
];
var getViewCellsDataComputed = function(_a2) {
  var viewCellsData2 = _a2.viewCellsData, groups = _a2.groups, resourcesToGroupBy = _a2.resourcesToGroupBy, groupByDate = _a2.groupByDate, currentView = _a2.currentView, groupOrientation = _a2.groupOrientation;
  return expandViewCellsDataWithGroups(viewCellsData2, groups, resourcesToGroupBy, groupByDate(currentView.name), groupOrientation(currentView.name));
};
var getAllDayCellsDataComputed = function(_a2) {
  var allDayCellsData = _a2.allDayCellsData, groups = _a2.groups, resourcesToGroupBy = _a2.resourcesToGroupBy, groupByDate = _a2.groupByDate, currentView = _a2.currentView, groupOrientation = _a2.groupOrientation;
  return allDayCellsData && expandViewCellsDataWithGroups(allDayCellsData, groups, resourcesToGroupBy, groupByDate(currentView.name), groupOrientation(currentView.name));
};
var getGroupsComputed = function(_a2) {
  var resourcesToGroupBy = _a2.resourcesToGroupBy;
  return getGroupsFromResources(resourcesToGroupBy);
};
var getResourcesToGroupByComputed = function(_a2) {
  var resources = _a2.resources, grouping = _a2.grouping;
  return sortFilteredResources(filterResourcesByGrouping(resources, grouping), grouping);
};
var getGroupingComputed = function(_a2) {
  var grouping = _a2.grouping, resources = _a2.resources;
  return updateGroupingWithMainResource(grouping, resources);
};
var getTimeTableAppointmentsComputed = function(_a2) {
  var timeTableAppointments = _a2.timeTableAppointments, grouping = _a2.grouping, resourcesToGroupBy = _a2.resourcesToGroupBy, groups = _a2.groups, groupByDate = _a2.groupByDate, currentView = _a2.currentView, excludedDays = _a2.excludedDays;
  return timeTableAppointments && expandGroups(timeTableAppointments, grouping, resourcesToGroupBy, groups, excludedDays, groupByDate(currentView === null || currentView === void 0 ? void 0 : currentView.name) && (currentView === null || currentView === void 0 ? void 0 : currentView.type) === VIEW_TYPES.MONTH);
};
var getAllDayAppointmentsComputed = function(_a2) {
  var allDayAppointments = _a2.allDayAppointments, grouping = _a2.grouping, resourcesToGroupBy = _a2.resourcesToGroupBy, groups = _a2.groups, groupByDate = _a2.groupByDate, currentView = _a2.currentView, excludedDays = _a2.excludedDays;
  return allDayAppointments && expandGroups(allDayAppointments, grouping, resourcesToGroupBy, groups, excludedDays, groupByDate(currentView === null || currentView === void 0 ? void 0 : currentView.name));
};
var getGroupByDateComputed = function(_a2) {
  var currentView = _a2.currentView, groupByDate = _a2.groupByDate, groupOrientation = _a2.groupOrientation;
  return groupOrientation(currentView === null || currentView === void 0 ? void 0 : currentView.name) === VERTICAL_GROUP_ORIENTATION ? function() {
    return false;
  } : groupByDate;
};
var getTimeTableElementsMetaComputed = function(_a2) {
  var timeTableElementsMeta = _a2.timeTableElementsMeta, groupOrientation = _a2.groupOrientation, groups = _a2.groups, allDayPanelExists = _a2.allDayPanelExists, viewCellsData2 = _a2.viewCellsData, currentView = _a2.currentView;
  return updateTimeTableCellElementsMeta(timeTableElementsMeta, groupOrientation, groups, allDayPanelExists, viewCellsData2, currentView);
};
var getAllDayElementsMetaComputed = function(_a2) {
  var allDayElementsMeta = _a2.allDayElementsMeta, timeTableElementsMeta = _a2.timeTableElementsMeta, groupOrientation = _a2.groupOrientation, groups = _a2.groups, allDayPanelExists = _a2.allDayPanelExists, viewCellsData2 = _a2.viewCellsData, currentView = _a2.currentView;
  return updateAllDayCellElementsMeta(allDayElementsMeta, timeTableElementsMeta, groupOrientation, groups, allDayPanelExists, viewCellsData2, currentView);
};
var getTimeCellsDataComputed = function(_a2) {
  var viewCellsData2 = _a2.viewCellsData, timeCellsData2 = _a2.timeCellsData, currentView = _a2.currentView, groups = _a2.groups, resourcesToGroupBy = _a2.resourcesToGroupBy, groupOrientation = _a2.groupOrientation;
  return timeCellsData2 && updateTimeCellsData(viewCellsData2, timeCellsData2, groups, resourcesToGroupBy, groupOrientation(currentView.name));
};
var IntegratedGroupingBase = (0, import_react2.memo)(function() {
  return (0, import_react2.createElement)(
    Plugin,
    { name: "IntegratedGrouping", dependencies: pluginDependencies$e },
    (0, import_react2.createElement)(Getter, { name: "groupByDate", computed: getGroupByDateComputed }),
    (0, import_react2.createElement)(Getter, { name: "grouping", computed: getGroupingComputed }),
    (0, import_react2.createElement)(Getter, { name: "resourcesToGroupBy", computed: getResourcesToGroupByComputed }),
    (0, import_react2.createElement)(Getter, { name: "groups", computed: getGroupsComputed }),
    (0, import_react2.createElement)(Getter, { name: "viewCellsData", computed: getViewCellsDataComputed }),
    (0, import_react2.createElement)(Getter, { name: "allDayCellsData", computed: getAllDayCellsDataComputed }),
    (0, import_react2.createElement)(Getter, { name: "timeCellsData", computed: getTimeCellsDataComputed }),
    (0, import_react2.createElement)(Getter, { name: "timeTableAppointments", computed: getTimeTableAppointmentsComputed }),
    (0, import_react2.createElement)(Getter, { name: "allDayAppointments", computed: getAllDayAppointmentsComputed }),
    (0, import_react2.createElement)(Getter, { name: "allDayElementsMeta", computed: getAllDayElementsMetaComputed }),
    (0, import_react2.createElement)(Getter, { name: "timeTableElementsMeta", computed: getTimeTableElementsMetaComputed })
  );
});
var IntegratedGrouping = IntegratedGroupingBase;

export {
  withComponents,
  moment_default,
  VERTICAL_TYPE,
  HORIZONTAL_TYPE,
  POSITION_START,
  POSITION_END,
  AUTO_HEIGHT,
  DAY_OPTIONS,
  WEEK_DAY_OPTIONS,
  HOUR_MINUTE_OPTIONS,
  MONTH_YEAR_OPTIONS,
  DAY_SHORT_MONTH_OPTIONS,
  WEEKDAY_INTERVAL,
  VERTICAL_GROUP_ORIENTATION,
  HORIZONTAL_GROUP_ORIENTATION,
  VIEW_TYPES,
  viewBoundText,
  isDateValid,
  areDatesSame,
  RRULE_REPEAT_TYPES,
  REPEAT_TYPES,
  END_REPEAT_RADIO_GROUP,
  MONTHLY_RADIO_GROUP,
  YEARLY_RADIO_GROUP,
  TITLE_TEXT_EDITOR,
  MULTILINE_TEXT_EDITOR,
  ORDINARY_TEXT_EDITOR,
  NUMBER_EDITOR,
  TITLE,
  ORDINARY_LABEL,
  SAVE_BUTTON,
  DELETE_BUTTON,
  CANCEL_BUTTON,
  OUTLINED_SELECT,
  STANDARD_SELECT,
  getGroupsLastRow,
  getCellKey,
  getRowFromGroups,
  getVerticalRowFromGroups,
  getLabelsForAllGroups,
  prepareVerticalViewCellsData,
  OPEN_COMMAND_BUTTON,
  CLOSE_COMMAND_BUTTON,
  DELETE_COMMAND_BUTTON,
  getWeekNumberLabels,
  getDaysOfWeek,
  getMonths,
  getMonthsWithOf,
  getAvailableRecurrenceOptions,
  checkIsNaturalNumber,
  getRecurrenceOptions,
  changeRecurrenceOptions,
  handleStartDateChange,
  handleToDayOfWeekChange,
  getFrequencyString,
  getRadioGroupDisplayData,
  handleChangeFrequency,
  handleWeekDaysChange,
  getDaysOfWeekArray,
  getDaysOfWeekDates,
  getDayScaleCells,
  navigateByOneMonth,
  Scheduler,
  DayView,
  WeekView,
  MonthView,
  Toolbar,
  DateNavigator,
  ViewSwitcher,
  Appointments,
  AllDayPanel,
  ViewState,
  EditingState,
  AppointmentTooltip,
  AppointmentForm,
  DragDropProvider2 as DragDropProvider,
  TodayButton,
  EditRecurrenceMenu,
  IntegratedEditing,
  Resources,
  ConfirmationDialog,
  GroupingState,
  GroupingPanel,
  CurrentTimeIndicator,
  IntegratedGrouping
};
/*! Bundled license information:

@devexpress/dx-core/dist/dx-core.es.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

@devexpress/dx-react-core/dist/dx-react-core.es.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

moment/dist/moment.js:
  (*! moment.js *)
  (*! version : 2.29.4 *)
  (*! authors : Tim Wood, Iskren Chernev, Moment.js contributors *)
  (*! license : MIT *)
  (*! momentjs.com *)

@devexpress/dx-scheduler-core/dist/dx-scheduler-core.es.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

@devexpress/dx-react-scheduler/dist/dx-react-scheduler.es.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
//# sourceMappingURL=chunk-U4NPSS2I.js.map
